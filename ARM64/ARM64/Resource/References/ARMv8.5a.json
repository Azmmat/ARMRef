[{"mnemonic": "ZIP1", "short_desc": "Zip vectors (primary)", "full_desc": "Zip vectors (primary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"}, {"mnemonic": "UMOV", "short_desc": "Unsigned Move vector element to general-purpose register", "full_desc": "Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit variant", "UMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<imm5>\nFor the 64-bit variant: is the element index encoded in \"imm5<4>\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when '0xxxx1' size = 0;     // UMOV Wd, Vn.B\n    when '0xxx10' size = 1;     // UMOV Wd, Vn.H\n    when '0xx100' size = 2;     // UMOV Wd, Vn.S\n    when '1x1000' size = 3;     // UMOV Xd, Vn.D\n    otherwise     UnallocatedEncoding();\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = ZeroExtend(Elem[operand, index, esize], datasize);"}, {"mnemonic": "LDURSB", "short_desc": "Load Register Signed Byte (unscaled)", "full_desc": "Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FABS (vector)", "short_desc": "Floating-point Absolute value (vector)", "full_desc": "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABS  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FABS  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"}, {"mnemonic": "CMEQ (zero)", "short_desc": "Compare bitwise Equal to zero (vector)", "full_desc": "Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMEQ  <V><d>, <V><n>, #0\t; Scalar variant", "CMEQ  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "MRS", "short_desc": "Move System Register", "full_desc": "Move System Register allows the PE to read an AArch64 System register into a general-purpose register.", "syntax": ["MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)\t; System variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<CRm:CRn:o0:op1:op2>\nIs a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<CRm:CRn:o0:op1:op2>\nThe System register names are defined in 'AArch64 System Registers' in the System Register XML.", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field."], "decode": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');", "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "USHR", "short_desc": "Unsigned Shift Right (immediate)", "full_desc": "Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FDIV (scalar)", "short_desc": "Floating-point Divide (scalar)", "full_desc": "Floating-point Divide (scalar). This instruction divides the floating-point value of the first source SIMD&FP register by the floating-point value of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FDIV  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FDIV  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FDIV  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPDiv(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "NGC", "short_desc": "Negate with Carry", "full_desc": "Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register.", "syntax": ["NGC  <Wd>, <Wm>\t; 32-bit variant", "NGC  <Xd>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "LDADD, LDADDA, LDADDAL, LDADDL", "short_desc": "Atomic add on word or doubleword in memory", "full_desc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADDA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDADD  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDADDL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDADDA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDADD  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDADDL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDRH (immediate)", "short_desc": "Load Register Halfword (immediate)", "full_desc": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "STLLRB", "short_desc": "Store LORelease Register Byte", "full_desc": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STUR (SIMD&FP)", "short_desc": "Store SIMD&FP register (unscaled offset)", "full_desc": "Store SIMD&FP register (unscaled offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit variant", "STUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit variant", "STUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant", "STUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FRINTI (vector)", "short_desc": "Floating-point Round to Integral, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTI  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTI  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FADDP (vector)", "short_desc": "Floating-point Add Pairwise (vector)", "full_desc": "Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STRB (immediate)", "short_desc": "Store Register Byte (immediate)", "full_desc": "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "STRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SHA1SU1", "short_desc": "SHA1 schedule update 1", "syntax": ["SHA1SU1  <Vd>.4S, <Vn>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand1 EOR LSR(operand2, 32);\nresult<31:0>   = ROL(T<31:0>,   1);\nresult<63:32>  = ROL(T<63:32>,  1);\nresult<95:64>  = ROL(T<95:64>,  1);\nresult<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\nV[d] = result;"}, {"mnemonic": "LDLAR", "short_desc": "Load LOAcquire Register", "full_desc": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDLAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SQADD", "short_desc": "Signed saturating Add", "full_desc": "Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "MLA (vector)", "short_desc": "Multiply-Add to accumulator (vector)", "full_desc": "Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"}, {"mnemonic": "SSUBL, SSUBL2", "short_desc": "Signed Subtract Long", "full_desc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.\n\nThe SSUBL instruction extracts each source vector from the lower half of each source register, while the SSUBL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQSHRUN, SQSHRUN2", "short_desc": "Signed saturating Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SQRSHRUN.\n\nThe SQSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "LD2 (single structure)", "short_desc": "Load single 2-element structure to one lane of two registers", "full_desc": "Load single 2-element structure to one lane of two registers. This instruction loads a 2-element structure from memory and writes the result to the corresponding elements of the two SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset variant", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "FNMUL (scalar)", "short_desc": "Floating-point Multiply-Negate (scalar)", "full_desc": "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the negation of the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMUL  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FNMUL  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FNMUL  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean negated = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"}, {"mnemonic": "SEVL", "short_desc": "Send Event Local", "full_desc": "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction.", "syntax": ["SEVL\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "STLLR", "short_desc": "Store LORelease Register", "full_desc": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRSQRTE", "short_desc": "Floating-point Reciprocal Square Root Estimate", "full_desc": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRSQRTE  <Hd>, <Hn>\t; Scalar half precision variant", "FRSQRTE  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FMIN (scalar)", "short_desc": "Floating-point Minimum (scalar)", "full_desc": "Floating-point Minimum (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMIN  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMIN  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMIN  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CLZ (vector)", "short_desc": "Count Leading Zero bits (vector)", "full_desc": "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CLZ  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "PRFM (register)", "short_desc": "Prefetch Memory (register)", "full_desc": "Prefetch Memory (register) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; Integer variant"], "symbols": ["<Rt>\nIs the prefetch operation, defined as <type><target><policy>.", "<Rt>\n<type> is one of:", "<Rt>\n<target> is one of:", "<Rt>\n<policy> is one of:", "<Rt>\nFor more information on these prefetch operations, see Prefetch memory.", "<Rt>\nFor other encodings of the \"Rt\" field, use <imm5>.", "<Rt>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Rt>\nThis syntax is only for encodings that are not accessible using <prfop>.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "B.cond", "short_desc": "Branch conditionally", "full_desc": "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B.<cond>  <label>\t; 19-bit signed PC-relative branch offset variant"], "symbols": ["<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<imm19>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "bits(64) offset = SignExtend(imm19:'00', 64);\nbits(4) condition = cond;", "operation": "if ConditionHolds(condition) then\n    BranchTo(PC[] + offset, BranchType_JMP);"}, {"mnemonic": "SQRSHRN, SQRSHRN2", "short_desc": "Signed saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN.\n\nThe SQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "PRFM (unscaled offset)", "short_desc": "Prefetch Memory (unscaled offset)", "full_desc": "Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFUM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the prefetch operation, defined as <type><target><policy>.", "<Rt>\n<type> is one of:", "<Rt>\n<target> is one of:", "<Rt>\n<policy> is one of:", "<Rt>\nFor more information on these prefetch operations, see Prefetch memory.", "<Rt>\nFor other encodings of the \"Rt\" field, use <imm5>.", "<Rt>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Rt>\nThis syntax is only for encodings that are not accessible using <prfop>.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LSRV", "short_desc": "Logical Shift Right Variable", "full_desc": "Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSRV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSRV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "LSL (register)", "short_desc": "Logical Shift Left (register)", "full_desc": "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSL  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSL  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "ADD (shifted register)", "short_desc": "Add (shifted register)", "full_desc": "Add (shifted register) adds a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "FACGE", "short_desc": "Floating-point Absolute Compare Greater than or Equal (vector)", "full_desc": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FACGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FACGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FCMEQ (register)", "short_desc": "Floating-point Compare Equal (vector)", "full_desc": "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMEQ  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMEQ  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SMC", "short_desc": "Secure Monitor Call", "full_desc": "Secure Monitor Call causes an exception to EL3.\n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC instruction at EL1 or higher generates a Secure Monitor Call exception, recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.\n\nIf the value of HCR_EL2.TSC is 1, execution of an SMC instruction in a Non-secure EL1 state generates an exception that is taken to EL2, regardless of the value of SCR_EL3.SMD. For more information, see Traps to EL2 of Non-secure EL1 execution of SMC instructions.\n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC instruction is undefined.", "syntax": ["SMC  #<imm>\t; System variant"], "symbols": ["<imm16>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "if !HaveEL(EL3) || PSTATE.EL == EL0 then\n    UnallocatedEncoding();\n\nAArch64.CheckForSMCTrap(imm);\n\nif SCR_EL3.SMD == '1' then\n    // SMC disabled\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallSecureMonitor(imm);"}, {"mnemonic": "SSHLL, SSHLL2", "short_desc": "Signed Shift Left Long (immediate)", "full_desc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SSHLL instruction extracts vector elements from the lower half of the source register, while the SSHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCVTXN, FCVTXN2", "short_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector)", "full_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nThe FCVTXN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTXN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTXN  <Vb><d>, <Va><n>\t; Scalar variant", "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '0' then ReservedValue();\ninteger esize = 32;\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);\n\nVpart[d, part] = result;"}, {"mnemonic": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory", "full_desc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ADR", "short_desc": "Form PC-relative address", "full_desc": "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.", "syntax": ["ADR  <Xd>, <label>\t; Literal variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<immhi:immlo>\nIs the program label whose address is to be calculated. Its offset from the address of this instruction, in the range +/-1MB, is encoded in \"immhi:immlo\"."], "decode": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);", "operation": "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"}, {"mnemonic": "TRN2", "short_desc": "Transpose vectors (secondary)", "full_desc": "Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"}, {"mnemonic": "MOV (wide immediate)", "short_desc": "Move (wide immediate)", "full_desc": "Move (wide immediate) moves a 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit variant", "MOV  <Xd>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<hw:imm16>\nFor the 32-bit variant: is a 32-bit immediate which can be encoded in \"imm16:hw\".", "<hw:imm16>\nFor the 64-bit variant: is a 64-bit immediate which can be encoded in \"imm16:hw\".", "<hw>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<hw>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."]}, {"mnemonic": "STSETB, STSETLB", "short_desc": "Atomic bit set on byte in memory, without return", "full_desc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSETB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSETLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "CNT", "short_desc": "Population Count per byte", "full_desc": "Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CNT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '00' then ReservedValue();\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    count = BitCount(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "LDARH", "short_desc": "Load-Acquire Register Halfword", "full_desc": "Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UQXTN, UQXTN2", "short_desc": "Unsigned saturating extract Narrow", "full_desc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe UQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQXTN  <Vb><d>, <Va><n>\t; Scalar variant", "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "UHSUB", "short_desc": "Unsigned Halving Subtract", "full_desc": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "URECPE", "short_desc": "Unsigned Reciprocal Estimate", "full_desc": "Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URECPE  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRecipEstimate(element);\n\nV[d] = result;"}, {"mnemonic": "LDXRH", "short_desc": "Load Exclusive Register Halfword", "full_desc": "Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA1M", "short_desc": "SHA1 hash update (majority)", "syntax": ["SHA1M  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "SYS", "short_desc": "System instruction", "full_desc": "System instruction. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.", "syntax": ["SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}\t; System variant"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."], "decode": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');", "operation": "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "UBFIZ", "short_desc": "Unsigned Bitfield Insert in Zero", "full_desc": "Unsigned Bitfield Insert in Zero zeroes the destination register and copies any number of contiguous bits from a source register into any position in the destination register.", "syntax": ["UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "STSMAXB, STSMAXLB", "short_desc": "Atomic signed maximum on byte in memory, without return", "full_desc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMAXLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "FRSQRTS", "short_desc": "Floating-point Reciprocal Square Root Step", "full_desc": "Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRSQRTS  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FRSQRTS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "ORR (vector, immediate)", "short_desc": "Bitwise inclusive OR (vector, immediate)", "full_desc": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit variant", "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP register, encoded in the \"Rd\" field.", "<a:b:c:d:e:f:g:h>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "FRINTX (scalar)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nAn Inexact exception is raised when the result value is not numerically equal to the input value. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTX  <Hd>, <Hn>\t; Half-precision variant", "FRINTX  <Sd>, <Sn>\t; Single-precision variant", "FRINTX  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "NEGS", "short_desc": "Negate, setting flags", "full_desc": "Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NEGS  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "NEGS  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "MUL (by element)", "short_desc": "Multiply (vector, by element)", "full_desc": "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FCVTPU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTPU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SADDLV", "short_desc": "Signed Add Long across Vector", "full_desc": "Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"}, {"mnemonic": "CLS (vector)", "short_desc": "Count Leading Sign bits (vector)", "full_desc": "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CLS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "UMSUBL", "short_desc": "Unsigned Multiply-Subtract Long", "full_desc": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "CASB, CASAB, CASALB, CASLB", "short_desc": "Compare and Swap byte in memory", "full_desc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.", "syntax": ["CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Acquire variant", "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Acquire and release variant", "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No memory ordering variant", "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDSETH, LDSETAH, LDSETALH, LDSETLH", "short_desc": "Atomic bit set on halfword in memory", "full_desc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSETAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSETH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UMLAL, UMLAL2 (vector)", "short_desc": "Unsigned Multiply-Add Long (vector)", "full_desc": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "AESD", "short_desc": "AES single round decryption", "syntax": ["AESD  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"}, {"mnemonic": "STRH (register)", "short_desc": "Store Register Halfword (register)", "full_desc": "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "EOR (shifted register)", "short_desc": "Bitwise Exclusive OR (shifted register)", "full_desc": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "RSUBHN, RSUBHN2", "short_desc": "Rounding Subtract returning High Narrow", "full_desc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SUBHN.\n\nThe RSUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "LDRB (register)", "short_desc": "Load Register Byte (register)", "full_desc": "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register variant", "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<S>\nIs the index shift amount, it must be #0, encoded in \"S\" as 0 if omitted, or as 1 if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FABS (scalar)", "short_desc": "Floating-point Absolute value (scalar)", "full_desc": "Floating-point Absolute value (scalar). This instruction calculates the absolute value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABS  <Hd>, <Hn>\t; Half-precision variant", "FABS  <Sd>, <Sn>\t; Single-precision variant", "FABS  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STTRB", "short_desc": "Store Register Byte (unprivileged)", "full_desc": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDURSW", "short_desc": "Load Register Signed Word (unscaled)", "full_desc": "Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "BIC (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register)", "full_desc": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "UADALP", "short_desc": "Unsigned Add and Accumulate Long Pairwise", "full_desc": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"}, {"mnemonic": "EXTR", "short_desc": "Extract register", "full_desc": "Extract register extracts a register from a pair of registers.", "syntax": ["EXTR  <Wd>, <Wn>, <Wm>, #<lsb>\t; 32-bit variant", "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imms>\nFor the 32-bit variant: is the least significant bit position from which to extract, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the least significant bit position from which to extract, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger lsb;\n\nif N != sf then UnallocatedEncoding();\nif sf == '0' && imms<5> == '1' then ReservedValue();\nlsb = UInt(imms);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(2*datasize) concat = operand1:operand2;\n\nresult = concat<lsb+datasize-1:lsb>;\n\nX[d] = result;"}, {"mnemonic": "LD1 (multiple structures)", "short_desc": "Load multiple single-element structures to one, two, three, or four registers", "full_desc": "Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1  { <Vt>.<T> }, [<Xn|SP>]\t; One register variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers variant", "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset variant", "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "FRINTM (scalar)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTM  <Hd>, <Hn>\t; Half-precision variant", "FRINTM  <Sd>, <Sn>\t; Single-precision variant", "FRINTM  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "MOV (inverted wide immediate)", "short_desc": "Move (inverted wide immediate)", "full_desc": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit variant", "MOV  <Xd>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<hw:imm16>\nFor the 32-bit variant: is a 32-bit immediate, the bitwise inverse of which can be encoded in \"imm16:hw\", but excluding 0xffff0000 and 0x0000ffff", "<hw:imm16>\nFor the 64-bit variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in \"imm16:hw\".", "<hw>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<hw>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."]}, {"mnemonic": "SQDMULH (by element)", "short_desc": "Signed saturating Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "BL", "short_desc": "Branch with Link", "full_desc": "Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call.", "syntax": ["BL  <label>\t; 26-bit signed PC-relative branch offset variant"], "symbols": ["<imm26>\nIs the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."], "decode": "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);", "operation": "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"}, {"mnemonic": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", "short_desc": "CRC32C checksum", "full_desc": "In ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory for all implementations to implement it.", "syntax": ["CRC32CB  <Wd>, <Wn>, <Wm>\t; CRC32CB variant", "CRC32CH  <Wd>, <Wn>, <Wm>\t; CRC32CH variant", "CRC32CW  <Wd>, <Wn>, <Wm>\t; CRC32CW variant", "CRC32CX  <Wd>, <Wn>, <Xm>\t; CRC32CX variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Rm>\nIs the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');", "operation": "if !HaveCRCExt() then\n    UnallocatedEncoding();\n\nbits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "SMLAL, SMLAL2 (vector)", "short_desc": "Signed Multiply-Add Long (vector)", "full_desc": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLAL instruction extracts each source vector from the lower half of each source register, while the SMLAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "SHL", "short_desc": "Shift Left (immediate)", "full_desc": "Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);\n\nV[d] = result;"}, {"mnemonic": "LDRSW (register)", "short_desc": "Load Register Signed Word (register)", "full_desc": "Load Register Signed Word (register) calculates an address from a base register value and an offset register value, loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value can be shifted left by 0 or 2 bits. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDNP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nFor information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SRSHR", "short_desc": "Signed Rounding Shift Right (immediate)", "full_desc": "Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "STADD, STADDL", "short_desc": "Atomic add on word or doubleword in memory, without return", "full_desc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADD  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STADDL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STADD  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STADDL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory", "full_desc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDUMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ADDHN, ADDHN2", "short_desc": "Add returning High Narrow", "full_desc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see RADDHN.\n\nThe ADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the ADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "STLXP", "short_desc": "Store-Release Exclusive Pair of registers", "full_desc": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ISB", "short_desc": "Instruction Synchronization Barrier", "full_desc": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB).", "syntax": ["ISB  {<option>|#<imm>}\t; System variant"], "symbols": ["<>\nSpecifies an optional limitation on the barrier operation. Values are:", "<>\nAll other encodings of CRm are reserved. The corresponding instructions execute as full system barrier operations, but must not be relied upon by software.", "<CRm>\nIs an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field."], "decode": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;", "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"}, {"mnemonic": "SWPB, SWPAB, SWPALB, SWPLB", "short_desc": "Swap byte in memory", "full_desc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWPAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "SWPALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "SWPB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "SWPLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDPSW", "short_desc": "Load Pair of Registers Signed Word", "full_desc": "Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; Post-index variant", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; Pre-index variant", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; Signed offset variant"], "symbols": ["<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the post-index and pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SHA1H", "short_desc": "SHA1 fixed rotate", "syntax": ["SHA1H  <Sd>, <Sn>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed\nV[d] = ROL(operand, 30);"}, {"mnemonic": "LDRSB (register)", "short_desc": "Load Register Signed Byte (register)", "full_desc": "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 32-bit with extended register offset variant", "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 32-bit with shifted register offset variant", "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 64-bit with extended register offset variant", "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 64-bit with shifted register offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<S>\nIs the index shift amount, it must be #0, encoded in \"S\" as 0 if omitted, or as 1 if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SMOV", "short_desc": "Signed Move vector element to general-purpose register", "full_desc": "Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source SIMD&FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit variant", "SMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B\n    when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H\n    when '1xx100' size = 2;     // SMOV Xd, Vn.S\n    otherwise     UnallocatedEncoding();\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = SignExtend(Elem[operand, index, esize], datasize);"}, {"mnemonic": "STSMINB, STSMINLB", "short_desc": "Atomic signed minimum on byte in memory, without return", "full_desc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMINB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMINLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "FRINTZ (vector)", "short_desc": "Floating-point Round to Integral, toward Zero (vector)", "full_desc": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "MSR (register)", "short_desc": "Move general-purpose register to System Register", "full_desc": "Move general-purpose register to System Register allows the PE to write an AArch64 System register from a general-purpose register.", "syntax": ["MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>\t; System variant"], "symbols": ["<CRm:CRn:o0:op1:op2>\nIs a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<CRm:CRn:o0:op1:op2>\nThe System register names are defined in 'AArch64 System Registers' in the System Register XML.", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."], "decode": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');", "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "FADDP (scalar)", "short_desc": "Floating-point Add Pair of elements (scalar)", "full_desc": "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADDP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FADDP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_FADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "RORV", "short_desc": "Rotate Right Variable", "full_desc": "Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["RORV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "RORV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "SSHR", "short_desc": "Signed Shift Right (immediate)", "full_desc": "Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQRDMLAH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "CASP, CASPA, CASPAL, CASPL", "short_desc": "Compare and Swap Pair of words or doublewords in memory", "full_desc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are restored to the values held in the registers before the instruction was executed.", "syntax": ["CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit, acquire variant", "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit, acquire and release variant", "CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit, no memory ordering variant", "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit, release variant", "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit, acquire variant", "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit, acquire and release variant", "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit, no memory ordering variant", "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<>\nIs the 32-bit name of the second general-purpose register to be compared and loaded.", "<Rt>\nIs the 32-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<>\nIs the 32-bit name of the second general-purpose register to be conditionally stored.", "<Rs>\nIs the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<>\nIs the 64-bit name of the second general-purpose register to be compared and loaded.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<>\nIs the 64-bit name of the second general-purpose register to be conditionally stored.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\nif Rs<0> == '1' then UnallocatedEncoding();\nif Rt<0> == '1' then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 32 << UInt(sz);\ninteger regsize = datasize;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;", "operation": "bits(64) address;\nbits(2*datasize) comparevalue;\nbits(2*datasize) newvalue;\nbits(2*datasize) data;\n\nbits(datasize) s1 = X[s];\nbits(datasize) s2 = X[s+1];\nbits(datasize) t1 = X[t];\nbits(datasize) t2 = X[t+1];\ncomparevalue = if BigEndian() then s1:s2 else s2:s1;\nnewvalue     = if BigEndian() then t1:t2 else t2:t1;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, (2 * datasize) DIV 8, ldacctype];\nif data == comparevalue then\n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, (2 * datasize) DIV 8, stacctype] = newvalue;\n\nif BigEndian() then\n    X[s]   = ZeroExtend(data<2*datasize-1:datasize>, regsize);\n    X[s+1] = ZeroExtend(data<datasize-1:0>, regsize);\nelse\n    X[s]   = ZeroExtend(data<datasize-1:0>, regsize);\n    X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, regsize);"}, {"mnemonic": "SQXTUN, SQXTUN2", "short_desc": "Signed saturating extract Unsigned Narrow", "full_desc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQXTUN  <Vb><d>, <Va><n>\t; Scalar variant", "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "FCVTNU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTNU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SQDMLAL, SQDMLAL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Add Long", "full_desc": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts each source vector from the lower half of each source register, while the SQDMLAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DC", "short_desc": "Data Cache operation", "full_desc": "Data Cache operation. For more information, see A64 system instructions for cache maintenance.", "syntax": ["DC  <dc_op>, <Xt>\t; System variant"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "ST2 (multiple structures)", "short_desc": "Store multiple 2-element structures from two registers", "full_desc": "Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from two SIMD&FP registers to memory, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "LDNP", "short_desc": "Load Pair of Registers, with non-temporal hint", "full_desc": "Load Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers.\n\nFor information about memory accesses, see Load/Store addressing modes. For information about Non-temporal pair instructions, see Load/Store Non-temporal pair.", "syntax": ["LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        X[t]  = data1;\n        X[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "ADC", "short_desc": "Add with Carry", "full_desc": "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register.", "syntax": ["ADC  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ADC  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "CMP (immediate)", "short_desc": "Compare (immediate)", "full_desc": "Compare (immediate) subtracts an optionally-shifted immediate value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "CMP  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."]}, {"mnemonic": "YIELD", "short_desc": "YIELD", "full_desc": "YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.\n\nFor more information about the recommended use of this instruction, see The YIELD instruction.", "syntax": ["YIELD\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "HLT", "short_desc": "Halt instruction", "full_desc": "Halt instruction generates a Halt Instruction debug event.", "syntax": ["HLT  #<imm>\t; System variant"], "symbols": ["<imm16>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "if EDSCR.HDE == '0' || !HaltingAllowed() then UndefinedFault();", "operation": "Halt(DebugHalt_HaltInstruction);"}, {"mnemonic": "SUB (vector)", "short_desc": "Subtract (vector)", "full_desc": "Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "MOV (vector)", "short_desc": "Move vector", "full_desc": "Move vector. This instruction copies the vector in the source SIMD&FP register into the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<T>, <Vn>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "CMP (extended register)", "short_desc": "Compare (extended register)", "full_desc": "Compare (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."]}, {"mnemonic": "NEG (vector)", "short_desc": "Negate (vector)", "full_desc": "Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["NEG  <V><d>, <V><n>\t; Scalar variant", "NEG  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"}, {"mnemonic": "STXRH", "short_desc": "Store Exclusive Register Halfword", "full_desc": "Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRECPX", "short_desc": "Floating-point Reciprocal exponent (scalar)", "full_desc": "Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPX  <Hd>, <Hn>\t; Half-precision variant", "FRECPX  <V><d>, <V><n>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecpX(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CBNZ", "short_desc": "Compare and Branch on Nonzero", "full_desc": "Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.", "syntax": ["CBNZ  <Wt>, <label>\t; 32-bit variant", "CBNZ  <Xt>, <label>\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<imm19>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);", "operation": "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);"}, {"mnemonic": "B", "short_desc": "Branch", "full_desc": "Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B  <label>\t; 26-bit signed PC-relative branch offset variant"], "symbols": ["<imm26>\nIs the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."], "decode": "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);", "operation": "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"}, {"mnemonic": "ORR (shifted register)", "short_desc": "Bitwise OR (shifted register)", "full_desc": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "SABDL, SABDL2", "short_desc": "Signed Absolute Difference Long", "full_desc": "Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SABDL instruction writes the vector to the lower half of the destination register and clears the upper half, while the SABDL2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "FMIN (vector)", "short_desc": "Floating-point minimum (vector)", "full_desc": "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ST1 (single structure)", "short_desc": "Store a single-element structure from one lane of one register", "full_desc": "Store a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&FP register to memory.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset variant", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory", "full_desc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTL, FCVTL2", "short_desc": "Floating-point Convert to higher precision Long (vector)", "full_desc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&FP destination register.\n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 variant operates on the elements in the top 64 bits of the source register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);\n\nV[d] = result;"}, {"mnemonic": "CMGT (zero)", "short_desc": "Compare signed Greater than zero (vector)", "full_desc": "Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGT  <V><d>, <V><n>, #0\t; Scalar variant", "CMGT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "MUL", "short_desc": "Multiply", "syntax": ["MUL  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "MUL  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "MLS (vector)", "short_desc": "Multiply-Subtract from accumulator (vector)", "full_desc": "Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"}, {"mnemonic": "CMGE (register)", "short_desc": "Compare signed Greater than or Equal (vector)", "full_desc": "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGE  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "BIC (vector, register)", "short_desc": "Bitwise bit Clear (vector, register)", "full_desc": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "LDRSH (immediate)", "short_desc": "Load Register Signed Halfword (immediate)", "full_desc": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSH  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FCSEL", "short_desc": "Floating-point Conditional Select (scalar)", "full_desc": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP destination register to take the value from either one or the other of two SIMD&FP source registers. If the condition passes, the first SIMD&FP source register value is taken, otherwise the second SIMD&FP source register value is taken.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCSEL  <Hd>, <Hn>, <Hm>, <cond>\t; Half-precision variant", "FCSEL  <Sd>, <Sn>, <Sm>, <cond>\t; Single-precision variant", "FCSEL  <Dd>, <Dn>, <Dm>, <cond>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nbits(4) condition = cond;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\n\nresult = if ConditionHolds(condition) then V[n] else V[m];\n\nV[d] = result;"}, {"mnemonic": "SQSHRN, SQSHRN2", "short_desc": "Signed saturating Shift Right Narrow (immediate)", "full_desc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN.\n\nThe SQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "STLXR", "short_desc": "Store-Release Exclusive Register", "full_desc": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STSMAX, STSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory, without return", "full_desc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAX  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STSMAXL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STSMAX  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STSMAXL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "PSB CSYNC", "short_desc": "Profiling Synchronization Barrier", "full_desc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following DSB instruction completes when the writes to the profiling buffer have completed.", "syntax": ["PSB CSYNC\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "UADDW, UADDW2", "short_desc": "Unsigned Add Wide", "full_desc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.\n\nThe UADDW instruction extracts vector elements from the lower half of the second source register, while the UADDW2 instruction extracts vector elements from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "STP", "short_desc": "Store Pair of Registers", "full_desc": "Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDTRB", "short_desc": "Load Register Byte (unprivileged)", "full_desc": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMAXP (vector)", "short_desc": "Floating-point Maximum Pairwise (vector)", "full_desc": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "BFXIL", "short_desc": "Bitfield extract and insert at low end", "full_desc": "Bitfield extract and insert at low end copies any number of low-order bits from a source register into the same number of adjacent bits at the low end in the destination register, leaving other bits unchanged.", "syntax": ["BFXIL  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "LDAXRH", "short_desc": "Load-Acquire Exclusive Register Halfword", "full_desc": "Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHLL, SHLL2", "short_desc": "Shift Left Long (by element size)", "full_desc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SHLL instruction extracts vector elements from the lower half of the source register, while the SHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = esize;\nboolean unsigned = FALSE; // Or TRUE without change of functionality", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ST4 (single structure)", "short_desc": "Store single 4-element structure from one lane of four registers", "full_desc": "Store single 4-element structure from one lane of four registers. This instruction stores a 4-element structure to memory from corresponding elements of four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset variant", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "LDRB (immediate)", "short_desc": "Load Register Byte (immediate)", "full_desc": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FNEG (vector)", "short_desc": "Floating-point Negate (vector)", "full_desc": "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNEG  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FNEG  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"}, {"mnemonic": "ORR (immediate)", "short_desc": "Bitwise OR (immediate)", "full_desc": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "ORR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "FSUB (vector)", "short_desc": "Floating-point Subtract (vector)", "full_desc": "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"}, {"mnemonic": "UABD", "short_desc": "Unsigned Absolute Difference (vector)", "full_desc": "Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "MLS (by element)", "short_desc": "Multiply-Subtract from accumulator (vector, by element)", "full_desc": "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"}, {"mnemonic": "SUB (extended register)", "short_desc": "Subtract (extended register)", "full_desc": "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "BFM", "short_desc": "Bitfield Move", "full_desc": "Bitfield Move copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, leaving other bits unchanged.", "syntax": ["BFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "BFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "FCVTZS (scalar, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTZS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTZS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTZS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTZS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTZS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "TST (immediate)", "short_desc": "Test bits (immediate)", "syntax": ["TST  <Wn>, #<imm>\t; 32-bit variant", "TST  <Xn>, #<imm>\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."]}, {"mnemonic": "CMGE (zero)", "short_desc": "Compare signed Greater than or Equal to zero (vector)", "full_desc": "Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGE  <V><d>, <V><n>, #0\t; Scalar variant", "CMGE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "STRH (immediate)", "short_desc": "Store Register Halfword (immediate)", "full_desc": "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "STRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "ORN (vector)", "short_desc": "Bitwise inclusive OR NOT (vector)", "full_desc": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "LSR (register)", "short_desc": "Logical Shift Right (register)", "full_desc": "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "FRINTP (vector)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTP  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTP  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FADD (scalar)", "short_desc": "Floating-point Add (scalar)", "full_desc": "Floating-point Add (scalar). This instruction adds the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADD  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FADD  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FADD  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean sub_op = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FCMP", "short_desc": "Floating-point quiet Compare (scalar)", "full_desc": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nIt raises an Invalid Operation exception only if either operand is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMP  <Hn>, <Hm>\t; Half-precision variant", "FCMP  <Hn>, #0.0\t; Half-precision, zero variant", "FCMP  <Sn>, <Sm>\t; Single-precision variant", "FCMP  <Sn>, #0.0\t; Single-precision, zero variant", "FCMP  <Dn>, <Dm>\t; Double-precision variant", "FCMP  <Dn>, #0.0\t; Double-precision, zero variant"], "symbols": ["<Rn>\nFor the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nFor the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nFor the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"}, {"mnemonic": "LDEOR, LDEORA, LDEORAL, LDEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory", "full_desc": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEORA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDEOR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDEORL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDEORA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDEOR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDEORL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "TLBI", "short_desc": "TLB Invalidate operation", "full_desc": "TLB Invalidate operation. For more information, see A64 system instructions for TLB maintenance.", "syntax": ["TLBI  <tlbi_op>{, <Xt>}\t; System variant"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."]}, {"mnemonic": "LD3 (single structure)", "short_desc": "Load single 3-element structure to one lane of three registers)", "full_desc": "Load single 3-element structure to one lane of three registers). This instruction loads a 3-element structure from memory and writes the result to the corresponding elements of the three SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset variant", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "ORR (vector, register)", "short_desc": "Bitwise inclusive OR (vector, register)", "full_desc": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "MOVI", "short_desc": "Move Immediate (vector)", "full_desc": "Move Immediate (vector). This instruction places an immediate constant into every vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOVI  <Vd>.<T>, #<imm8>{, LSL #0}\t; 8-bit variant", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate variant", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate variant", "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones variant", "MOVI  <Dd>, #<imm>\t; 64-bit scalar variant", "MOVI  <Vd>.2D, #<imm>\t; 64-bit vector variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<a:b:c:d:e:f:g:h>\nIs a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh', encoded in \"a:b:c:d:e:f:g:h\".", "<a:b:c:d:e:f:g:h>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "PRFM (literal)", "short_desc": "Prefetch Memory (literal)", "full_desc": "Prefetch Memory (literal) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), <label>\t; Literal variant"], "symbols": ["<Rt>\nIs the prefetch operation, defined as <type><target><policy>.", "<Rt>\n<type> is one of:", "<Rt>\n<target> is one of:", "<Rt>\n<policy> is one of:", "<Rt>\nFor more information on these prefetch operations, see Prefetch memory.", "<Rt>\nFor other encodings of the \"Rt\" field, use <imm5>.", "<Rt>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Rt>\nThis syntax is only for encodings that are not accessible using <prfop>.", "<imm19>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "FRINTA (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTA  <Hd>, <Hn>\t; Half-precision variant", "FRINTA  <Sd>, <Sn>\t; Single-precision variant", "FRINTA  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "LDTRSH", "short_desc": "Load Register Signed Halfword (unprivileged)", "full_desc": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMADD", "short_desc": "Floating-point fused Multiply-Add (scalar)", "full_desc": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "UXTL, UXTL2", "short_desc": "Unsigned extend Long", "full_desc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe UXTL instruction extracts vector elements from the lower half of the source register, while the UXTL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "STURB", "short_desc": "Store Register Byte (unscaled)", "full_desc": "Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMINNMP (scalar)", "short_desc": "Floating-point Minimum Number of Pair of elements (scalar)", "full_desc": "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory", "full_desc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ADD (immediate)", "short_desc": "Add (immediate)", "full_desc": "Add (immediate) adds a register value and an optionally-shifted immediate value, and writes the result to the destination register.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "ADRP", "short_desc": "Form PC-relative address to 4KB page", "full_desc": "Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.", "syntax": ["ADRP  <Xd>, <label>\t; Literal variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<immhi:immlo>\nIs the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as \"immhi:immlo\" times 4096."], "decode": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);", "operation": "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"}, {"mnemonic": "FCVTMU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTMU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTMU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTMU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTMU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTMU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "CNEG", "short_desc": "Conditional Negate", "full_desc": "Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CNEG  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CNEG  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "SHA256H", "short_desc": "SHA256 hash update (part 1)", "syntax": ["SHA256H  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Rn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');", "operation": "CheckCryptoEnabled64();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"}, {"mnemonic": "FMINNMP (vector)", "short_desc": "Floating-point Minimum Number Pairwise (vector)", "full_desc": "Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ADD (extended register)", "short_desc": "Add (extended register)", "full_desc": "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "STR (immediate)", "short_desc": "Store Register (immediate)", "full_desc": "Store Register (immediate) stores a word or a doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "STR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "STR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<imm12>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SMLAL, SMLAL2 (by element)", "short_desc": "Signed Multiply-Add Long (vector, by element)", "full_desc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.\n\nThe SMLAL instruction extracts vector elements from the lower half of the first source register, while the SMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "SQXTN, SQXTN2", "short_desc": "Signed saturating extract Narrow", "full_desc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQXTN  <Vb><d>, <Va><n>\t; Scalar variant", "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "SHSUB", "short_desc": "Signed Halving Subtract", "full_desc": "Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "SQDMULH (vector)", "short_desc": "Signed saturating Doubling Multiply returning High half", "full_desc": "Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "STLRB", "short_desc": "Store-Release Register Byte", "full_desc": "Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STUMINH, STUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory, without return", "full_desc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMINH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMINLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "USHLL, USHLL2", "short_desc": "Unsigned Shift Left Long (immediate)", "full_desc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe USHLL instruction extracts vector elements from the lower half of the source register, while the USHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "BRK", "short_desc": "Breakpoint instruction", "full_desc": "Breakpoint instruction generates a Breakpoint Instruction exception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and captures the value of the immediate argument in ESR_ELx.ISS.", "syntax": ["BRK  #<imm>\t; System variant"], "symbols": ["<imm16>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) comment = imm16;", "operation": "AArch64.SoftwareBreakpoint(comment);"}, {"mnemonic": "SUBHN, SUBHN2", "short_desc": "Subtract returning High Narrow", "full_desc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nThe results are truncated. For rounded results, see RSUBHN.\n\nThe SUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "PRFM (immediate)", "short_desc": "Prefetch Memory (immediate)", "full_desc": "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the prefetch operation, defined as <type><target><policy>.", "<Rt>\n<type> is one of:", "<Rt>\n<target> is one of:", "<Rt>\n<policy> is one of:", "<Rt>\nFor more information on these prefetch operations, see Prefetch memory.", "<Rt>\nFor other encodings of the \"Rt\" field, use <imm5>.", "<Rt>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Rt>\nThis syntax is only for encodings that are not accessible using <prfop>.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "UMAX", "short_desc": "Unsigned Maximum (vector)", "full_desc": "Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SUQADD", "short_desc": "Signed saturating Accumulate of Unsigned value", "full_desc": "Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUQADD  <V><d>, <V><n>\t; Scalar variant", "SUQADD  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"}, {"mnemonic": "STRB (register)", "short_desc": "Store Register Byte (register)", "full_desc": "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register variant", "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<S>\nIs the index shift amount, it must be #0, encoded in \"S\" as 0 if omitted, or as 1 if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "IC", "short_desc": "Instruction Cache operation", "full_desc": "Instruction Cache operation. For more information, see A64 system instructions for cache maintenance.", "syntax": ["IC  <ic_op>{, <Xt>}\t; System variant"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."]}, {"mnemonic": "SUB (immediate)", "short_desc": "Subtract (immediate)", "full_desc": "Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "URHADD", "short_desc": "Unsigned Rounding Halving Add", "full_desc": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see UHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "FCMLE (zero)", "short_desc": "Floating-point Compare Less than or Equal to zero (vector)", "full_desc": "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLE  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMLE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "USUBL, USUBL2", "short_desc": "Unsigned Subtract Long", "full_desc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.\n\nThe USUBL instruction extracts each source vector from the lower half of each source register, while the USUBL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LD2R", "short_desc": "Load single 2-element structure and Replicate to all lanes of two registers", "full_desc": "Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "FMAXP (scalar)", "short_desc": "Floating-point Maximum of Pair of elements (scalar)", "full_desc": "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SABA", "short_desc": "Signed Absolute difference and Accumulate", "full_desc": "Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "SADDLP", "short_desc": "Signed Add Long Pairwise", "full_desc": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"}, {"mnemonic": "FCVTPS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTPS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "UQADD", "short_desc": "Unsigned saturating Add", "full_desc": "Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SQRSHL", "short_desc": "Signed saturating Rounding Shift Left (register)", "full_desc": "Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see SQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FMAXNMV", "short_desc": "Floating-point Maximum Number across Vector", "full_desc": "Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<>\nFor the half-precision variant: is the destination width specifier, H.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SQDMLAL, SQDMLAL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Add Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts vector elements from the lower half of the first source register, while the SQDMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "LDRH (register)", "short_desc": "Load Register Halfword (register)", "full_desc": "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SQRDMLAH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "LDADDB, LDADDAB, LDADDALB, LDADDLB", "short_desc": "Atomic add on byte in memory", "full_desc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADDAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDADDB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTNS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTNS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SADDW, SADDW2", "short_desc": "Signed Add Wide", "full_desc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.\n\nThe SADDW instruction extracts the second source vector from the lower half of the second source register, while the SADDW2 instruction extracts the second source vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SBFIZ", "short_desc": "Signed Bitfield Insert in Zero", "full_desc": "Signed Bitfield Insert in Zero zeroes the destination register and copies any number of contiguous bits from a source register into any position in the destination register, sign-extending the most significant bit of the transferred value.", "syntax": ["SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "STUMAX, STUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAX  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STUMAXL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STUMAX  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STUMAXL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "STR (register)", "short_desc": "Store Register (register)", "full_desc": "Store Register (register) calculates an address from a base register value and an offset register value, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "TBL", "short_desc": "Table vector Lookup", "full_desc": "Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nFor the four register table, three register table and two register table variant: is the name of the first SIMD&FP table register, encoded in the \"Rn\" field.", "<Rn>\nFor the single register table variant: is the name of the SIMD&FP table register, encoded in the \"Rn\" field.", "<Rn>\nIs the name of the second SIMD&FP table register, encoded as \"Rn\" plus 1 modulo 32.", "<Rn>\nIs the name of the third SIMD&FP table register, encoded as \"Rn\" plus 2 modulo 32.", "<Rn>\nIs the name of the fourth SIMD&FP table register, encoded as \"Rn\" plus 3 modulo 32.", "<Rm>\nIs the name of the SIMD&FP index register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"}, {"mnemonic": "LDRSW (literal)", "short_desc": "Load Register Signed Word (literal)", "full_desc": "Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, <label>\t; Literal variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<imm19>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "RBIT (vector)", "short_desc": "Reverse Bit order (vector)", "full_desc": "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RBIT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nbits(esize) rev;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    for i = 0 to esize-1\n        rev<esize-1-i> = element<i>;\n    Elem[result, e, esize] = rev;\n\nV[d] = result;"}, {"mnemonic": "STR (register, SIMD&FP)", "short_desc": "Store SIMD&FP register (register offset)", "full_desc": "Store SIMD&FP register (register offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-bit variant", "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-bit variant", "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<S>\nFor the 8-bit variant: is the index shift amount, it must be #0, encoded in \"S\" as 0 if omitted, or as 1 if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "ORN (shifted register)", "short_desc": "Bitwise OR NOT (shifted register)", "full_desc": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "MUL (vector)", "short_desc": "Multiply (vector)", "full_desc": "Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "ST3 (multiple structures)", "short_desc": "Store multiple 3-element structures from three registers", "full_desc": "Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to memory from three SIMD&FP registers, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "LDRSH (register)", "short_desc": "Load Register Signed Halfword (register)", "full_desc": "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FCVTMS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTMS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTMS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTMS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTMS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTMS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "LDR (literal)", "short_desc": "Load Register (literal)", "full_desc": "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDR  <Wt>, <label>\t; 32-bit variant", "LDR  <Xt>, <label>\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<imm19>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "BIC (vector, immediate)", "short_desc": "Bitwise bit Clear (vector, immediate)", "full_desc": "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit variant", "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP register, encoded in the \"Rd\" field.", "<a:b:c:d:e:f:g:h>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "FCMGT (register)", "short_desc": "Floating-point Compare Greater than (vector)", "full_desc": "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMAXNM (scalar)", "short_desc": "Floating-point Maximum Number (scalar)", "full_desc": "Floating-point Maximum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the larger of the two floating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNM  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMAXNM  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMAXNM  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "MOV (to/from SP)", "short_desc": "Move between register and stack pointer", "syntax": ["MOV  <Wd|WSP>, <Wn|WSP>\t; 32-bit variant", "MOV  <Xd|SP>, <Xn|SP>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "ADDS (shifted register)", "short_desc": "Add (shifted register), setting flags", "full_desc": "Add (shifted register), setting flags, adds a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "NOT", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["NOT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = NOT(element);\n\nV[d] = result;"}, {"mnemonic": "MNEG", "short_desc": "Multiply-Negate", "full_desc": "Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register.", "syntax": ["MNEG  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "MNEG  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "STLXRH", "short_desc": "Store-Release Exclusive Register Halfword", "full_desc": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CMLE (zero)", "short_desc": "Compare signed Less than or Equal to zero (vector)", "full_desc": "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMLE  <V><d>, <V><n>, #0\t; Scalar variant", "CMLE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "STEORH, STEORLH", "short_desc": "Atomic exclusive OR on halfword in memory, without return", "full_desc": "Atomic exclusive OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEORH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STEORLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "UABDL, UABDL2", "short_desc": "Unsigned Absolute Difference Long", "full_desc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UABDL instruction extracts each source vector from the lower half of each source register, while the UABDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "WFE", "short_desc": "Wait For Event", "full_desc": "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event.\n\nAs described in Wait For Event mechanism and Send event, the execution of a WFE instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See:", "syntax": ["WFE\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "SUB (shifted register)", "short_desc": "Subtract (shifted register)", "full_desc": "Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "STEOR, STEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory, without return", "full_desc": "Atomic exclusive OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEOR  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STEORL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STEOR  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STEORL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "SABD", "short_desc": "Signed Absolute Difference", "full_desc": "Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "LD4 (multiple structures)", "short_desc": "Load multiple 4-element structures to four registers", "full_desc": "Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "LDURB", "short_desc": "Load Register Byte (unscaled)", "full_desc": "Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "STNP", "short_desc": "Store Pair of Registers, with non-temporal hint", "full_desc": "Store Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes. For information about Non-temporal pair instructions, see Load/Store Non-temporal pair.", "syntax": ["STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        X[t]  = data1;\n        X[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "REV64", "short_desc": "Reverse elements in 64-bit doublewords (vector)", "full_desc": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV64  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "FCCMPE", "short_desc": "Floating-point Conditional signaling Compare (scalar)", "full_desc": "Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision variant", "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision variant", "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision variant"], "symbols": ["<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "LDLARB", "short_desc": "Load LOAcquire Register Byte", "full_desc": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", "short_desc": "Atomic bit clear on byte in memory", "full_desc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTZS (scalar, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit variant", "FCVTZS  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit variant", "FCVTZS  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit variant", "FCVTZS  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit variant", "FCVTZS  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit variant", "FCVTZS  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<scale>\nFor the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus \"scale\".", "<scale>\nFor the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "STUMAXH, STUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory, without return", "full_desc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMAXLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "RADDHN, RADDHN2", "short_desc": "Rounding Add returning High Narrow", "full_desc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see ADDHN.\n\nThe RADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "ADDS (immediate)", "short_desc": "Add (immediate), setting flags", "full_desc": "Add (immediate), setting flags, adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "UMLAL, UMLAL2 (by element)", "short_desc": "Unsigned Multiply-Add Long (vector, by element)", "full_desc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "CMP (shifted register)", "short_desc": "Compare (shifted register)", "full_desc": "Compare (shifted register) subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "CMP  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "ADDS (extended register)", "short_desc": "Add (extended register), setting flags", "full_desc": "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", "short_desc": "Atomic signed minimum on halfword in memory", "full_desc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA256SU1", "short_desc": "SHA256 schedule update 1", "syntax": ["SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nbits(128) T0 = operand3<31:0> : operand2<127:32>;\nbits(64) T1;\nbits(32) elt;\n\nT1 = operand3<127:64>;\nfor e = 0 to 1\n    elt = Elem[T1, e, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nT1 = result<63:0>;\nfor e = 2 to 3\n    elt = Elem[T1, e - 2, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nV[d] = result;"}, {"mnemonic": "ABS", "short_desc": "Absolute value (vector)", "full_desc": "Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ABS  <V><d>, <V><n>\t; Scalar variant", "ABS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"}, {"mnemonic": "FSQRT (vector)", "short_desc": "Floating-point Square Root (vector)", "full_desc": "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSQRT  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FSQRT  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPSqrt(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TBZ", "short_desc": "Test bit and Branch if Zero", "full_desc": "Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset variant"], "symbols": ["<Rt>\nIs the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<b40:b5>\nIs the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\".", "<imm14>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4."], "decode": "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);", "operation": "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);"}, {"mnemonic": "FNMSUB", "short_desc": "Floating-point Negated fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FMINP (vector)", "short_desc": "Floating-point Minimum Pairwise (vector)", "full_desc": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TRN1", "short_desc": "Transpose vectors (primary)", "full_desc": "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"}, {"mnemonic": "MLA (by element)", "short_desc": "Multiply-Add to accumulator (vector, by element)", "full_desc": "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"}, {"mnemonic": "MSR (immediate)", "short_desc": "Move immediate value to Special Register", "full_desc": "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see Process state, PSTATE.\n\nThe bits that can be written are D, A, I, F, and SP. This set of bits is expanded in extensions to the architecture as follows:", "syntax": ["MSR  <pstatefield>, #<imm>\t; System variant"], "symbols": ["<CRm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');\n\nbits(4) operand = CRm;\nPSTATEField field;\ncase op1:op2 of\n    when '000 011' \n        if !HaveUAOExt() then\n            UnallocatedEncoding();\n        field = PSTATEField_UAO;\n    when '000 100' \n        if !HavePANExt() then\n            UnallocatedEncoding();\n        field = PSTATEField_PAN;\n    when '000 101' field = PSTATEField_SP;\n    when '011 110' field = PSTATEField_DAIFSet;\n    when '011 111' field = PSTATEField_DAIFClr;\n    otherwise      UnallocatedEncoding();\n\n// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted\nif op1 == '011' && PSTATE.EL == EL0 && (IsInHost() || SCTLR_EL1.UMA == '0') then\n    AArch64.SystemRegisterTrap(EL1, '00', op2, op1, '0100', '11111', CRm, '0');", "operation": "case field of\n    when PSTATEField_SP    \n        PSTATE.SP = operand<0>;\n    when PSTATEField_DAIFSet\n        PSTATE.D = PSTATE.D OR operand<3>;\n        PSTATE.A = PSTATE.A OR operand<2>;\n        PSTATE.I = PSTATE.I OR operand<1>;\n        PSTATE.F = PSTATE.F OR operand<0>;\n    when PSTATEField_DAIFClr\n        PSTATE.D = PSTATE.D AND NOT(operand<3>);\n        PSTATE.A = PSTATE.A AND NOT(operand<2>);\n        PSTATE.I = PSTATE.I AND NOT(operand<1>);\n        PSTATE.F = PSTATE.F AND NOT(operand<0>);\n    when PSTATEField_PAN\n        PSTATE.PAN = operand<0>;\n    when PSTATEField_UAO\n        PSTATE.UAO = operand<0>;"}, {"mnemonic": "STADDH, STADDLH", "short_desc": "Atomic add on halfword in memory, without return", "full_desc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADDH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STADDLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "UABA", "short_desc": "Unsigned Absolute difference and Accumulate", "full_desc": "Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "BIF", "short_desc": "Bitwise Insert if False", "full_desc": "Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&FP register into the destination SIMD&FP register if the corresponding bit of the second source SIMD&FP register is 0, otherwise leaves the bit in the destination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "LD4R", "short_desc": "Load single 4-element structure and Replicate to all lanes of four registers", "full_desc": "Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "ERET", "short_desc": "Exception Return", "full_desc": "Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores PSTATE from the SPSR, and branches to the address held in the ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from AArch64 state.", "syntax": ["ERET\t; System variant"], "symbols": [], "decode": "if PSTATE.EL == EL0 then UnallocatedEncoding();", "operation": "AArch64.ExceptionReturn(ELR[], SPSR[]);"}, {"mnemonic": "FNEG (scalar)", "short_desc": "Floating-point Negate (scalar)", "full_desc": "Floating-point Negate (scalar). This instruction negates the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNEG  <Hd>, <Hn>\t; Half-precision variant", "FNEG  <Sd>, <Sn>\t; Single-precision variant", "FNEG  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SUBS (shifted register)", "short_desc": "Subtract (shifted register), setting flags", "full_desc": "Subtract (shifted register), setting flags, subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "LD3R", "short_desc": "Load single 3-element structure and Replicate to all lanes of three registers", "full_desc": "Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "STCLRH, STCLRLH", "short_desc": "Atomic bit clear on halfword in memory, without return", "full_desc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLRH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STCLRLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "UQRSHRN, UQRSHRN2", "short_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN.\n\nThe UQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "URSHR", "short_desc": "Unsigned Rounding Shift Right (immediate)", "full_desc": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "EXT", "short_desc": "Extract vector from pair of vectors", "full_desc": "Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source SIMD&FP register and the highest vector elements from the first source SIMD&FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif Q == '0' && imm4<3> == '1' then UnallocatedEncoding();\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger position = UInt(imm4) << 3;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) hi = V[m];\nbits(datasize) lo = V[n];\nbits(datasize*2) concat = hi : lo;\n\nV[d] = concat<position+datasize-1:position>;"}, {"mnemonic": "STR (immediate, SIMD&FP)", "short_desc": "Store SIMD&FP register (immediate offset)", "full_desc": "Store SIMD&FP register (immediate offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit variant", "STR  <St>, [<Xn|SP>], #<simm>\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit variant", "STR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit variant", "STR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit variant", "STR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit variant", "STR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nFor the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm12>\nFor the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2.", "<imm12>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<imm12>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8.", "<imm12>\nFor the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/16."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDRSB (immediate)", "short_desc": "Load Register Signed Byte (immediate)", "full_desc": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSB  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SMSUBL", "short_desc": "Signed Multiply-Subtract Long", "full_desc": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "LDEORB, LDEORAB, LDEORALB, LDEORLB", "short_desc": "Atomic exclusive OR on byte in memory", "full_desc": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEORAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDEORB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "MOV (to general)", "short_desc": "Move vector element to general-purpose register", "full_desc": "Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Wd>, <Vn>.S[<index>]\t; 32-bit variant", "MOV  <Xd>, <Vn>.D[<index>]\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<imm5>\nFor the 32-bit variant: is the element index encoded in \"imm5<4:3>\".", "<imm5>\nFor the 64-bit variant: is the element index encoded in \"imm5<4>\"."]}, {"mnemonic": "ZIP2", "short_desc": "Zip vectors (secondary)", "full_desc": "Zip vectors (secondary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"}, {"mnemonic": "LSLV", "short_desc": "Logical Shift Left Variable", "full_desc": "Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSLV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSLV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory", "full_desc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDSMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SMULH", "short_desc": "Signed Multiply High", "full_desc": "Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["SMULH  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"}, {"mnemonic": "SMAX", "short_desc": "Signed Maximum (vector)", "full_desc": "Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LDRSW (immediate)", "short_desc": "Load Register Signed Word (immediate)", "full_desc": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nIs the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMLA (by element)", "short_desc": "Floating-point fused Multiply-Add to accumulator (by element)", "full_desc": "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results in the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLA  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<M:Rm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<H:L:M>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "UBFM", "short_desc": "Unsigned Bitfield Move", "full_desc": "Unsigned Bitfield Move copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, with zeros in the upper and lower bits.", "syntax": ["UBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "UBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "LDSET, LDSETA, LDSETAL, LDSETL", "short_desc": "Atomic bit set on word or doubleword in memory", "full_desc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSETA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDSET  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDSETL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDSETA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDSET  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDSETL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "REV16", "short_desc": "Reverse bytes in 16-bit halfwords", "full_desc": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register.", "syntax": ["REV16  <Wd>, <Wn>\t; 32-bit variant", "REV16  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "AND (vector)", "short_desc": "Bitwise AND (vector)", "full_desc": "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "SMLSL, SMLSL2 (vector)", "short_desc": "Signed Multiply-Subtract Long (vector)", "full_desc": "Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts each source vector from the lower half of each source register, while the SMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "LD3 (multiple structures)", "short_desc": "Load multiple 3-element structures to three registers", "full_desc": "Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&FP registers, with de-interleaving.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "SSUBW, SSUBW2", "short_desc": "Signed Subtract Wide", "full_desc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.\n\nThe SSUBW instruction extracts the second source vector from the lower half of the second source register, while the SSUBW2 instruction extracts the second source vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQSHLU", "short_desc": "Signed saturating Shift Left Unsigned (immediate)", "full_desc": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHLU  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "UMULL, UMULL2 (by element)", "short_desc": "Unsigned Multiply Long (vector, by element)", "full_desc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMULL instruction extracts vector elements from the lower half of the first source register, while the UMULL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FCVTZS (vector, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FDIV (vector)", "short_desc": "Floating-point Divide (vector)", "full_desc": "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPDiv(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LDTRSW", "short_desc": "Load Register Signed Word (unprivileged)", "full_desc": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "STLRH", "short_desc": "Store-Release Register Halfword", "full_desc": "Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTPS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTPS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTPS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTPS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTPS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTPS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "FMULX", "short_desc": "Floating-point Multiply extended", "full_desc": "Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMULX  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FMULX  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "STUMINB, STUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory, without return", "full_desc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMINB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMINLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "ASR (immediate)", "short_desc": "Arithmetic Shift Right (immediate)", "full_desc": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register.", "syntax": ["ASR  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "ASR  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field."]}, {"mnemonic": "CSNEG", "short_desc": "Conditional Select Negation", "full_desc": "Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register.", "syntax": ["CSNEG  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSNEG  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "CMN (immediate)", "short_desc": "Compare Negative (immediate)", "full_desc": "Compare Negative (immediate) adds a register value and an optionally-shifted immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "CMN  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."]}, {"mnemonic": "LDR (literal, SIMD&FP)", "short_desc": "Load SIMD&FP Register (PC-relative literal)", "full_desc": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from the PC value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <St>, <label>\t; 32-bit variant", "LDR  <Dt>, <label>\t; 64-bit variant", "LDR  <Qt>, <label>\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<imm19>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 16;\n    when '11'\n        UnallocatedEncoding();\n\noffset = SignExtend(imm19:'00', 64);", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nCheckFPAdvSIMDEnabled64();\n\ndata = Mem[address, size, AccType_VEC];\nV[t] = data;"}, {"mnemonic": "SQDMLSL, SQDMLSL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long", "full_desc": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts each source vector from the lower half of each source register, while the SQDMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FRINTM (vector)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTM  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTM  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FADD (vector)", "short_desc": "Floating-point Add (vector)", "full_desc": "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SQRDMLSH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "CRC32B, CRC32H, CRC32W, CRC32X", "short_desc": "CRC32 checksum", "full_desc": "In ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory for all implementations to implement it.", "syntax": ["CRC32B  <Wd>, <Wn>, <Wm>\t; CRC32B variant", "CRC32H  <Wd>, <Wn>, <Wm>\t; CRC32H variant", "CRC32W  <Wd>, <Wn>, <Wm>\t; CRC32W variant", "CRC32X  <Wd>, <Wn>, <Xm>\t; CRC32X variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Rm>\nIs the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');", "operation": "if !HaveCRCExt() then\n    UnallocatedEncoding();\n\nbits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "SCVTF (scalar, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (scalar)", "full_desc": "Signed fixed-point Convert to Floating-point (scalar). This instruction converts the signed value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision variant", "SCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision variant", "SCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision variant", "SCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision variant", "SCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision variant", "SCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<scale>\nFor the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus \"scale\".", "<scale>\nFor the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "FCVTNS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTNS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTNS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTNS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTNS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTNS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "LDR (register)", "short_desc": "Load Register (register)", "full_desc": "Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDR (register, SIMD&FP)", "short_desc": "Load SIMD&FP Register (register offset)", "full_desc": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-bit variant", "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-bit variant", "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nWhen option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Rm>\nWhen option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<S>\nFor the 8-bit variant: is the index shift amount, it must be #0, encoded in \"S\" as 0 if omitted, or as 1 if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "MOVZ", "short_desc": "Move wide with zero", "full_desc": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVZ  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVZ  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm16>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<hw>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<hw>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "ST4 (multiple structures)", "short_desc": "Store multiple 4-element structures from four registers", "full_desc": "Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to memory from four SIMD&FP registers, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "CBZ", "short_desc": "Compare and Branch on Zero", "full_desc": "Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["CBZ  <Wt>, <label>\t; 32-bit variant", "CBZ  <Xt>, <label>\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<imm19>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);", "operation": "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);"}, {"mnemonic": "CMLT (zero)", "short_desc": "Compare signed Less than zero (vector)", "full_desc": "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMLT  <V><d>, <V><n>, #0\t; Scalar variant", "CMLT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "CMHI (register)", "short_desc": "Compare unsigned Higher (vector)", "full_desc": "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMHI  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "UABAL, UABAL2", "short_desc": "Unsigned Absolute difference and Accumulate Long", "full_desc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UABAL instruction extracts each source vector from the lower half of each source register, while the UABAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "CCMP (register)", "short_desc": "Conditional Compare (register)", "full_desc": "Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "TST (shifted register)", "short_desc": "Test (shifted register)", "full_desc": "Test (shifted register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "TST  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"]}, {"mnemonic": "LDXR", "short_desc": "Load Exclusive Register", "full_desc": "Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CSET", "short_desc": "Conditional Set", "full_desc": "Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.", "syntax": ["CSET  <Wd>, <cond>\t; 32-bit variant", "CSET  <Xd>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "SQABS", "short_desc": "Signed saturating Absolute value", "full_desc": "Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQABS  <V><d>, <V><n>\t; Scalar variant", "SQABS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DSB", "short_desc": "Data Synchronization Barrier", "full_desc": "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier.", "syntax": ["DSB  <option>|#<imm>\t; System variant"], "symbols": ["<>\nSpecifies the limitation on the barrier operation. Values are:", "<>\nAll other encodings of CRm that are not listed above are reserved, and can be encoded using the #<imm> syntax. It is implementation defined whether options other than SY are implemented. All unsupported and reserved options must execute as a full system barrier operation, but software must not rely on this behavior. For more information on whether an access is before or after a barrier instruction, see Data Memory Barrier (DMB) or see Data Synchronization Barrier (DSB).", "<CRm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;", "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"}, {"mnemonic": "LDAR", "short_desc": "Load-Acquire Register", "full_desc": "Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDR (immediate, SIMD&FP)", "short_desc": "Load SIMD&FP Register (immediate offset)", "full_desc": "Load SIMD&FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit variant", "LDR  <St>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit variant", "LDR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit variant", "LDR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit variant", "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit variant", "LDR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nFor the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm12>\nFor the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2.", "<imm12>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<imm12>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8.", "<imm12>\nFor the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/16."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LD1R", "short_desc": "Load one single-element structure and Replicate to all lanes (of one register)", "full_desc": "Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1R  { <Vt>.<T> }, [<Xn|SP>]\t; No offset variant", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "FMUL (vector)", "short_desc": "Floating-point Multiply (vector)", "full_desc": "Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ASRV", "short_desc": "Arithmetic Shift Right Variable", "full_desc": "Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASRV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ASRV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "FCMEQ (zero)", "short_desc": "Floating-point Compare Equal to zero (vector)", "full_desc": "Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMEQ  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMEQ  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SRSHL", "short_desc": "Signed Rounding Shift Left (register)", "full_desc": "Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For a truncating shift, see SSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "RSHRN, RSHRN2", "short_desc": "Rounding Shift Right Narrow (immediate)", "full_desc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"}, {"mnemonic": "LDXP", "short_desc": "Load Exclusive Pair of Registers", "full_desc": "Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CMN (shifted register)", "short_desc": "Compare Negative (shifted register)", "full_desc": "Compare Negative (shifted register) adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "CMN  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "FCVTZU (scalar, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTZU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTZU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTZU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTZU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTZU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "AESIMC", "short_desc": "AES inverse mix columns", "syntax": ["AESIMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"}, {"mnemonic": "EON (shifted register)", "short_desc": "Bitwise Exclusive OR NOT (shifted register)", "full_desc": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "UMULL", "short_desc": "Unsigned Multiply Long", "full_desc": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["UMULL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "MOV (element)", "short_desc": "Move vector element to another vector element", "full_desc": "Move vector element to another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "UQSUB", "short_desc": "Unsigned saturating Subtract", "full_desc": "Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "TBNZ", "short_desc": "Test bit and Branch if Nonzero", "full_desc": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBNZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset variant"], "symbols": ["<Rt>\nIs the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<b40:b5>\nIs the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\".", "<imm14>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4."], "decode": "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);", "operation": "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);"}, {"mnemonic": "PMULL, PMULL2", "short_desc": "Polynomial Multiply Long", "full_desc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0, 1}.\n\nThe PMULL instruction extracts each source vector from the lower half of each source register, while the PMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '01' || size == '10' then ReservedValue();\nif size == '11' && ! HaveCryptoExt() then UnallocatedEncoding();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "HINT", "short_desc": "Hint instruction", "full_desc": "Hint instruction is for the instruction set space that is reserved for architectural hint instructions.\n\nSome encodings described here are unallocated in this revision of the architecture, and behave as NOPs. These encodings might be allocated to other hint functionality in future revisions of the architecture.", "syntax": ["HINT  #<imm>\t; Hints 6 and 7 variant", "HINT  #<imm>\t; Hints 8 to 15, and 24 to 127 variant", "HINT  #<imm>\t; Hints 17 to 23 variant"], "symbols": ["<CRm:op2>\nIs a 7-bit unsigned immediate, in the range 0 to 127, excluding the allocated encodings described below, encoded in \"CRm:op2\".", "<CRm:op2>\nThe following encodings of \"CRm:op2\" are allocated:"], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "CMN (extended register)", "short_desc": "Compare Negative (extended register)", "full_desc": "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."]}, {"mnemonic": "UQSHL (immediate)", "short_desc": "Unsigned saturating Shift Left (immediate)", "full_desc": "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FMINNM (vector)", "short_desc": "Floating-point Minimum Number (vector)", "full_desc": "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "AND (shifted register)", "short_desc": "Bitwise AND (shifted register)", "full_desc": "Bitwise AND (shifted register) performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "SSHL", "short_desc": "Signed Shift Left (register)", "full_desc": "Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see SRSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "WFI", "short_desc": "Wait For Interrupt", "full_desc": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFI instruction that  would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See:", "syntax": ["WFI\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "ANDS (shifted register)", "short_desc": "Bitwise AND (shifted register), setting flags", "full_desc": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "LDTRSB", "short_desc": "Load Register Signed Byte (unprivileged)", "full_desc": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "STURH", "short_desc": "Store Register Halfword (unscaled)", "full_desc": "Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", "short_desc": "Atomic signed maximum on byte in memory", "full_desc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "MOVN", "short_desc": "Move wide with NOT", "full_desc": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVN  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVN  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm16>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<hw>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<hw>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "CSEL", "short_desc": "Conditional Select", "full_desc": "Conditional Select returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register.", "syntax": ["CSEL  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSEL  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "FRINTZ (scalar)", "short_desc": "Floating-point Round to Integral, toward Zero (scalar)", "full_desc": "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTZ  <Hd>, <Hn>\t; Half-precision variant", "FRINTZ  <Sd>, <Sn>\t; Single-precision variant", "FRINTZ  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "SHADD", "short_desc": "Signed Halving Add", "full_desc": "Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SRHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "UQSHRN, UQSHRN2", "short_desc": "Unsigned saturating Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN.\n\nThe UQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "SEV", "short_desc": "Send Event", "full_desc": "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see Wait for Event mechanism and Send event.", "syntax": ["SEV\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "LDTR", "short_desc": "Load Register (unprivileged)", "full_desc": "Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FNMADD", "short_desc": "Floating-point Negated fused Multiply-Add (scalar)", "full_desc": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FNMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SXTW", "short_desc": "Sign Extend Word", "full_desc": "Sign Extend Word sign-extends a word to the size of the register, and writes the result to the destination register.", "syntax": ["SXTW  <Xd>, <Wn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory", "full_desc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLRA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDCLR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDCLR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "AT", "short_desc": "Address Translate", "full_desc": "Address Translate. For more information, see A64 system instructions for address translation.", "syntax": ["AT  <at_op>, <Xt>\t; System variant"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Rt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "FABD", "short_desc": "Floating-point Absolute Difference (vector)", "full_desc": "Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABD  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FABD  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"}, {"mnemonic": "SBFX", "short_desc": "Signed Bitfield Extract", "full_desc": "Signed Bitfield Extract extracts any number of adjacent bits at any position from a register, sign-extends them to the size of the register, and writes the result to the destination register.", "syntax": ["SBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "SBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", "short_desc": "Atomic signed minimum on byte in memory", "full_desc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "NEG (shifted register)", "short_desc": "Negate (shifted register)", "full_desc": "Negate (shifted register) negates an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["NEG  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "NEG  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "AESE", "short_desc": "AES single round encryption", "syntax": ["AESE  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"}, {"mnemonic": "SCVTF (scalar, integer)", "short_desc": "Signed integer Convert to Floating-point (scalar)", "full_desc": "Signed integer Convert to Floating-point (scalar). This instruction converts the signed integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Wn>\t; 32-bit to half-precision variant", "SCVTF  <Sd>, <Wn>\t; 32-bit to single-precision variant", "SCVTF  <Dd>, <Wn>\t; 32-bit to double-precision variant", "SCVTF  <Hd>, <Xn>\t; 64-bit to half-precision variant", "SCVTF  <Sd>, <Xn>\t; 64-bit to single-precision variant", "SCVTF  <Dd>, <Xn>\t; 64-bit to double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "STSET, STSETL", "short_desc": "Atomic bit set on word or doubleword in memory, without return", "full_desc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSET  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STSETL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STSET  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STSETL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "AESMC", "short_desc": "AES mix columns", "syntax": ["AESMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"}, {"mnemonic": "LDUR", "short_desc": "Load Register (unscaled)", "full_desc": "Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LD4 (single structure)", "short_desc": "Load single 4-element structure to one lane of four registers", "full_desc": "Load single 4-element structure to one lane of four registers. This instruction loads a 4-element structure from memory and writes the result to the corresponding elements of the four SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset variant", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "UMINP", "short_desc": "Unsigned Minimum Pairwise", "full_desc": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "UXTB", "short_desc": "Unsigned Extend Byte", "full_desc": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTB  <Wd>, <Wn>\t; 32-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "SMADDL", "short_desc": "Signed Multiply-Add Long", "full_desc": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "FCVTNU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTNU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTNU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTNU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTNU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTNU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "SHA256H2", "short_desc": "SHA256 hash update (part 2)", "syntax": ["SHA256H2  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Rn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');", "operation": "CheckCryptoEnabled64();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"}, {"mnemonic": "CCMN (immediate)", "short_desc": "Conditional Compare Negative (immediate)", "full_desc": "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm5>\nIs a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "SXTH", "short_desc": "Sign Extend Halfword", "full_desc": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTH  <Wd>, <Wn>\t; 32-bit variant", "SXTH  <Xd>, <Wn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "CMGT (register)", "short_desc": "Compare signed Greater than (vector)", "full_desc": "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGT  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory", "full_desc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDUMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "USQADD", "short_desc": "Unsigned saturating Accumulate of Signed value", "full_desc": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USQADD  <V><d>, <V><n>\t; Scalar variant", "USQADD  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"}, {"mnemonic": "FCMGT (zero)", "short_desc": "Floating-point Compare Greater than zero (vector)", "full_desc": "Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGT  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMGT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMSUB", "short_desc": "Floating-point Fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STADDB, STADDLB", "short_desc": "Atomic add on byte in memory, without return", "full_desc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADDB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STADDLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "UMAXP", "short_desc": "Unsigned Maximum Pairwise", "full_desc": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "URSRA", "short_desc": "Unsigned Rounding Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ST3 (single structure)", "short_desc": "Store single 3-element structure from one lane of three registers", "full_desc": "Store single 3-element structure from one lane of three registers. This instruction stores a 3-element structure to memory from corresponding elements of three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset variant", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "CLZ", "short_desc": "Count leading zero bits", "syntax": ["CLZ  <Wd>, <Wn>\t; 32-bit variant", "CLZ  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;", "operation": "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "STCLRB, STCLRLB", "short_desc": "Atomic bit clear on byte in memory, without return", "full_desc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLRB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STCLRLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "CSINV", "short_desc": "Conditional Select Invert", "full_desc": "Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register.", "syntax": ["CSINV  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSINV  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "PMUL", "short_desc": "Polynomial Multiply", "full_desc": "Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0, 1}.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FSUB (scalar)", "short_desc": "Floating-point Subtract (scalar)", "full_desc": "Floating-point Subtract (scalar). This instruction subtracts the floating-point value of the second source SIMD&FP register from the floating-point value of the first source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSUB  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FSUB  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FSUB  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean sub_op = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FMOV (scalar, immediate)", "short_desc": "Floating-point move immediate (scalar)", "full_desc": "Floating-point move immediate (scalar). This instruction copies a floating-point immediate constant into the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Hd>, #<imm>\t; Half-precision variant", "FMOV  <Sd>, #<imm>\t; Single-precision variant", "FMOV  <Dd>, #<imm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<imm8>\nIs a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in the \"imm8\" field. For details of the range of constants available and the encoding of <imm>, see Modified immediate constants in A64 floating-point instructions."], "decode": "integer d = UInt(Rd);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nbits(datasize) imm = VFPExpandImm(imm8);", "operation": "CheckFPAdvSIMDEnabled64();\n\nV[d] = imm;"}, {"mnemonic": "MOVK", "short_desc": "Move wide with keep", "full_desc": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged.", "syntax": ["MOVK  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVK  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm16>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<hw>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<hw>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "FCVTZS (vector, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTZS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "XTN, XTN2", "short_desc": "Extract Narrow", "full_desc": "Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.\n\nThe XTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the XTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    Elem[result, e, esize] = element<esize-1:0>;\nVpart[d, part] = result;"}, {"mnemonic": "SQSHL (immediate)", "short_desc": "Signed saturating Shift Left (immediate)", "full_desc": "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FCVTMS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTMS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FRINTA (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTA  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTA  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "DUP (element)", "short_desc": "Duplicate vector element to vector or scalar", "full_desc": "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["DUP  <V><d>, <Vn>.<T>[<index>]\t; Scalar variant", "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \n\ninteger esize = 8 << size;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nelement = Elem[operand, index, esize];\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"}, {"mnemonic": "LDEORH, LDEORAH, LDEORALH, LDEORLH", "short_desc": "Atomic exclusive OR on halfword in memory", "full_desc": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEORAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDEORH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UZP2", "short_desc": "Unzip vectors (secondary)", "full_desc": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"}, {"mnemonic": "SUBS (immediate)", "short_desc": "Subtract (immediate), setting flags", "full_desc": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm12>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LDAXP", "short_desc": "Load-Acquire Exclusive Pair of Registers", "full_desc": "Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTPU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTPU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTPU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTPU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTPU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTPU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "REV16 (vector)", "short_desc": "Reverse elements in 16-bit halfwords (vector)", "full_desc": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV16  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "STP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers", "full_desc": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit variant", "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit variant", "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the \"imm7\" field as <imm>/16.", "<imm7>\nFor the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDADDH, LDADDAH, LDADDALH, LDADDLH", "short_desc": "Atomic add on halfword in memory", "full_desc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADDAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDADDH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "USHL", "short_desc": "Unsigned Shift Left (register)", "full_desc": "Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see URSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCMLT (zero)", "short_desc": "Floating-point Compare Less than zero (vector)", "full_desc": "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLT  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMLT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "LDAXR", "short_desc": "Load-Acquire Exclusive Register", "full_desc": "Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UADDLV", "short_desc": "Unsigned sum Long across Vector", "full_desc": "Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"}, {"mnemonic": "SUBS (extended register)", "short_desc": "Subtract (extended register), setting flags", "full_desc": "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<imm3>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "FMLS (by element)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (by element)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLS  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<M:Rm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<H:L:M>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "UBFX", "short_desc": "Unsigned Bitfield Extract", "full_desc": "Unsigned Bitfield Extract extracts any number of adjacent bits at any position from a register, zero-extends them to the size of the register, and writes the result to the destination register.", "syntax": ["UBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "UBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "SQDMULL, SQDMULL2 (by element)", "short_desc": "Signed saturating Doubling Multiply Long (by element)", "full_desc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts the first source vector from the lower half of the first source register, while the SQDMULL2 instruction extracts the first source vector from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SQRSHRUN, SQRSHRUN2", "short_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN.\n\nThe SQRSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "CMHS (register)", "short_desc": "Compare unsigned Higher or Same (vector)", "full_desc": "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMHS  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SQRDMULH (vector)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SXTB", "short_desc": "Signed Extend Byte", "full_desc": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTB  <Wd>, <Wn>\t; 32-bit variant", "SXTB  <Xd>, <Wn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "SMINV", "short_desc": "Signed Minimum across Vector", "full_desc": "Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "FCVTAU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTAU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SMAXV", "short_desc": "Signed Maximum across Vector", "full_desc": "Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MVN  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "LDP", "short_desc": "Load Pair of Registers", "full_desc": "Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "UXTH", "short_desc": "Unsigned Extend Halfword", "full_desc": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTH  <Wd>, <Wn>\t; 32-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "FMAX (vector)", "short_desc": "Floating-point Maximum (vector)", "full_desc": "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CSINC", "short_desc": "Conditional Select Increment", "full_desc": "Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1.", "syntax": ["CSINC  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSINC  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "UDIV", "short_desc": "Unsigned Divide", "full_desc": "Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["UDIV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "UDIV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "CSETM", "short_desc": "Conditional Set Mask", "full_desc": "Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0.", "syntax": ["CSETM  <Wd>, <cond>\t; 32-bit variant", "CSETM  <Xd>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "STLXRB", "short_desc": "Store-Release Exclusive Register Byte", "full_desc": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SADALP", "short_desc": "Signed Add and Accumulate Long Pairwise", "full_desc": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"}, {"mnemonic": "EOR (vector)", "short_desc": "Bitwise Exclusive OR (vector)", "full_desc": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "SMULL, SMULL2 (by element)", "short_desc": "Signed Multiply Long (vector, by element)", "full_desc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMULL instruction extracts vector elements from the lower half of the first source register, while the SMULL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"}, {"mnemonic": "STEORB, STEORLB", "short_desc": "Atomic exclusive OR on byte in memory, without return", "full_desc": "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEORB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STEORLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "ADDP (scalar)", "short_desc": "Add Pair of elements (scalar)", "full_desc": "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDP  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_ADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "UMLSL, UMLSL2 (vector)", "short_desc": "Unsigned Multiply-Subtract Long (vector)", "full_desc": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMLSL instruction extracts each source vector from the lower half of each source register, while the UMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "LDR (immediate)", "short_desc": "Load Register (immediate)", "full_desc": "Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes. The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it to the base register value.", "syntax": ["LDR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<imm12>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<imm12>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMAXV", "short_desc": "Floating-point Maximum across Vector", "full_desc": "Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<>\nFor the half-precision variant: is the destination width specifier, H.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "STSMIN, STSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory, without return", "full_desc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMIN  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STSMINL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STSMIN  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STSMINL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "FCVTZU (scalar, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit variant", "FCVTZU  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit variant", "FCVTZU  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit variant", "FCVTZU  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit variant", "FCVTZU  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit variant", "FCVTZU  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<scale>\nFor the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus \"scale\".", "<scale>\nFor the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "LDURH", "short_desc": "Load Register Halfword (unscaled)", "full_desc": "Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SBCS", "short_desc": "Subtract with Carry, setting flags", "full_desc": "Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SBCS  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SBCS  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "CAS, CASA, CASAL, CASL", "short_desc": "Compare and Swap word or doubleword in memory", "full_desc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in the register before the instruction was executed.", "syntax": ["CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit, acquire variant", "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit, acquire and release variant", "CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit, no memory ordering variant", "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit, release variant", "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit, acquire variant", "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit, acquire and release variant", "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit, no memory ordering variant", "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINTI (scalar)", "short_desc": "Floating-point Round to Integral, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTI  <Hd>, <Hn>\t; Half-precision variant", "FRINTI  <Sd>, <Sn>\t; Single-precision variant", "FRINTI  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "LDLARH", "short_desc": "Load LOAcquire Register Halfword", "full_desc": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CLS", "short_desc": "Count leading sign bits", "syntax": ["CLS  <Wd>, <Wn>\t; 32-bit variant", "CLS  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;", "operation": "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "STUMAXB, STUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory, without return", "full_desc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMAXLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "BFI", "short_desc": "Bitfield Insert", "full_desc": "Bitfield Insert copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, leaving other bits unchanged.", "syntax": ["BFI  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "BFI  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "FMAXNM (vector)", "short_desc": "Floating-point Maximum Number (vector)", "full_desc": "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TBX", "short_desc": "Table vector lookup extension", "full_desc": "Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nFor the four register table, three register table and two register table variant: is the name of the first SIMD&FP table register, encoded in the \"Rn\" field.", "<Rn>\nFor the single register table variant: is the name of the SIMD&FP table register, encoded in the \"Rn\" field.", "<Rn>\nIs the name of the second SIMD&FP table register, encoded as \"Rn\" plus 1 modulo 32.", "<Rn>\nIs the name of the third SIMD&FP table register, encoded as \"Rn\" plus 2 modulo 32.", "<Rn>\nIs the name of the fourth SIMD&FP table register, encoded as \"Rn\" plus 3 modulo 32.", "<Rm>\nIs the name of the SIMD&FP index register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"}, {"mnemonic": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", "short_desc": "Atomic bit clear on halfword in memory", "full_desc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA1SU0", "short_desc": "SHA1 schedule update 0", "syntax": ["SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\n\nresult = operand2<63:0> : operand1<127:64>;\nresult = result EOR operand1 EOR operand3;\nV[d] = result;"}, {"mnemonic": "FMINV", "short_desc": "Floating-point Minimum across Vector", "full_desc": "Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<>\nFor the half-precision variant: is the destination width specifier, H.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "UADDL, UADDL2", "short_desc": "Unsigned Add Long (vector)", "full_desc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UADDL instruction extracts each source vector from the lower half of each source register, while the UADDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "INS (general)", "short_desc": "Insert vector element from general-purpose register", "full_desc": "Insert vector element from general-purpose register. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["INS  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\n\nif size > 3 then UnallocatedEncoding();\ninteger index = UInt(imm5<4:size+1>);\n\ninteger esize = 8 << size;\ninteger datasize = 128;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nresult = V[d];\nElem[result, index, esize] = element;\nV[d] = result;"}, {"mnemonic": "STCLR, STCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory, without return", "full_desc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLR  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STCLRL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STCLR  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STCLRL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "UMADDL", "short_desc": "Unsigned Multiply-Add Long", "full_desc": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "RBIT", "short_desc": "Reverse Bits", "full_desc": "Reverse Bits reverses the bit order in a register.", "syntax": ["RBIT  <Wd>, <Wn>\t; 32-bit variant", "RBIT  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\nfor i = 0 to datasize-1\n    result<datasize-1-i> = operand<i>;\n\nX[d] = result;"}, {"mnemonic": "LDXRB", "short_desc": "Load Exclusive Register Byte", "full_desc": "Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CMTST", "short_desc": "Compare bitwise Test bits nonzero (vector)", "full_desc": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMTST  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "STSMAXH, STSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory, without return", "full_desc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMAXLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "URSQRTE", "short_desc": "Unsigned Reciprocal Square Root Estimate", "full_desc": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);\n\nV[d] = result;"}, {"mnemonic": "REV32 (vector)", "short_desc": "Reverse elements in 32-bit words (vector)", "full_desc": "Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV32  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "SHRN, SHRN2", "short_desc": "Shift Right Narrow (immediate)", "full_desc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"}, {"mnemonic": "FMLS (vector)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (vector)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "MOV (from general)", "short_desc": "Move general-purpose register to a vector element", "full_desc": "Move general-purpose register to a vector element. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."]}, {"mnemonic": "MOV (register)", "short_desc": "Move (register)", "full_desc": "Move (register) copies the value in a source register to the destination register.", "syntax": ["MOV  <Wd>, <Wm>\t; 32-bit variant", "MOV  <Xd>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "SQRDMULH (by element)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf any of the results overflows, they are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SCVTF (vector, integer)", "short_desc": "Signed integer Convert to Floating-point (vector)", "full_desc": "Signed integer Convert to Floating-point (vector). This instruction converts each element in a vector from signed integer to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Hn>\t; Scalar half precision variant", "SCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SQDMULL, SQDMULL2 (vector)", "short_desc": "Signed saturating Doubling Multiply Long", "full_desc": "Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts each source vector from the lower half of each source register, while the SQDMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "UHADD", "short_desc": "Unsigned Halving Add", "full_desc": "Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see URHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "FMUL (scalar)", "short_desc": "Floating-point Multiply (scalar)", "full_desc": "Floating-point Multiply (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMUL  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMUL  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean negated = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"}, {"mnemonic": "ADDP (vector)", "short_desc": "Add Pairwise (vector)", "full_desc": "Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[concat, 2*e, esize];\n    element2 = Elem[concat, (2*e)+1, esize];\n    Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "FMOV (register)", "short_desc": "Floating-point Move register without conversion", "full_desc": "Floating-point Move register without conversion. This instruction copies the floating-point value in the SIMD&FP source register to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Hd>, <Hn>\t; Half-precision variant", "FMOV  <Sd>, <Sn>\t; Single-precision variant", "FMOV  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STNP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "MADD", "short_desc": "Multiply-Add", "full_desc": "Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination register.", "syntax": ["MADD  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit variant", "MADD  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"}, {"mnemonic": "FMINP (scalar)", "short_desc": "Floating-point Minimum of Pair of elements (scalar)", "full_desc": "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "REV", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a register.", "syntax": ["REV  <Wd>, <Wn>\t; 32-bit variant", "REV  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "URSHL", "short_desc": "Unsigned Rounding Shift Left (register)", "full_desc": "Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "BICS (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register), setting flags", "full_desc": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "LDSETB, LDSETAB, LDSETALB, LDSETLB", "short_desc": "Atomic bit set on byte in memory", "full_desc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSETAB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDSETB  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "NGCS", "short_desc": "Negate with Carry, setting flags", "full_desc": "Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NGCS  <Wd>, <Wm>\t; 32-bit variant", "NGCS  <Xd>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "UQSHL (register)", "short_desc": "Unsigned saturating Shift Left (register)", "full_desc": "Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "CASH, CASAH, CASALH, CASLH", "short_desc": "Compare and Swap halfword in memory", "full_desc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.", "syntax": ["CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Acquire variant", "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Acquire and release variant", "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No memory ordering variant", "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "LSR (immediate)", "short_desc": "Logical Shift Right (immediate)", "full_desc": "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSR  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "LSR  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field."]}, {"mnemonic": "BLR", "short_desc": "Branch with Link to Register", "full_desc": "Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.", "syntax": ["BLR  <Xn>\t; Integer variant"], "symbols": ["<Rn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) target = X[n];\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"}, {"mnemonic": "SHA256SU0", "short_desc": "SHA256 schedule update 0", "syntax": ["SHA256SU0  <Vd>.4S, <Vn>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand2<31:0> : operand1<127:32>;\nbits(32) elt;\n\nfor e = 0 to 3\n    elt = Elem[T, e, 32];\n    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n    Elem[result, e, 32] = elt + Elem[operand1, e, 32];\nV[d] = result;"}, {"mnemonic": "EOR (immediate)", "short_desc": "Bitwise Exclusive OR (immediate)", "full_desc": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["EOR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "EOR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LD2 (multiple structures)", "short_desc": "Load multiple 2-element structures to two registers", "full_desc": "Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "ASR (register)", "short_desc": "Arithmetic Shift Right (register)", "full_desc": "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ASR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "UMLSL, UMLSL2 (by element)", "short_desc": "Unsigned Multiply-Subtract Long (vector, by element)", "full_desc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLSL instruction extracts vector elements from the lower half of the first source register, while the UMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "STTRH", "short_desc": "Store Register Halfword (unprivileged)", "full_desc": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "ADCS", "short_desc": "Add with Carry, setting flags", "full_desc": "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADCS  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ADCS  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "SMULL, SMULL2 (vector)", "short_desc": "Signed Multiply Long (vector)", "full_desc": "Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nThe destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMULL instruction extracts each source vector from the lower half of each source register, while the SMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQSUB", "short_desc": "Signed saturating Subtract", "full_desc": "Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DRPS", "short_desc": "Debug restore process state", "syntax": ["DRPS\t; System variant"], "symbols": [], "decode": "if !Halted() || PSTATE.EL == EL0 then UnallocatedEncoding();", "operation": "DRPSInstruction();"}, {"mnemonic": "FMAXNMP (scalar)", "short_desc": "Floating-point Maximum Number of Pair of elements (scalar)", "full_desc": "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SQNEG", "short_desc": "Signed saturating Negate", "full_desc": "Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQNEG  <V><d>, <V><n>\t; Scalar variant", "SQNEG  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "STXR", "short_desc": "Store Exclusive Register", "full_desc": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CMEQ (register)", "short_desc": "Compare bitwise Equal (vector)", "full_desc": "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMEQ  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "CCMP (immediate)", "short_desc": "Conditional Compare (immediate)", "full_desc": "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm5>\nIs a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "STXP", "short_desc": "Store Exclusive Pair of registers", "full_desc": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UMULH", "short_desc": "Unsigned Multiply High", "full_desc": "Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["UMULH  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"}, {"mnemonic": "LDURSH", "short_desc": "Load Register Signed Halfword (unscaled)", "full_desc": "Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "UMIN", "short_desc": "Unsigned Minimum (vector)", "full_desc": "Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCVT", "short_desc": "Floating-point Convert precision (scalar)", "full_desc": "Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&FP source register to the precision for the destination register data type using the rounding mode that is determined by the FPCR and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVT  <Sd>, <Hn>\t; Half-precision to single-precision variant", "FCVT  <Dd>, <Hn>\t; Half-precision to double-precision variant", "FCVT  <Hd>, <Sn>\t; Single-precision to half-precision variant", "FCVT  <Dd>, <Sn>\t; Single-precision to double-precision variant", "FCVT  <Hd>, <Dn>\t; Double-precision to half-precision variant", "FCVT  <Sd>, <Dn>\t; Double-precision to single-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif type == opc then UnallocatedEncoding();\n\ninteger srcsize;\ncase type of\n    when '00' srcsize = 32;\n    when '01' srcsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' srcsize = 16;\ninteger dstsize;\ncase opc of\n    when '00' dstsize = 32;\n    when '01' dstsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' dstsize = 16;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(dstsize) result;\nbits(srcsize) operand = V[n];\n\nresult = FPConvert(operand, FPCR);\nV[d] = result;"}, {"mnemonic": "FRINTN (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTN  <Hd>, <Hn>\t; Half-precision variant", "FRINTN  <Sd>, <Sn>\t; Single-precision variant", "FRINTN  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "UCVTF (scalar, integer)", "short_desc": "Unsigned integer Convert to Floating-point (scalar)", "full_desc": "Unsigned integer Convert to Floating-point (scalar). This instruction converts the unsigned integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Wn>\t; 32-bit to half-precision variant", "UCVTF  <Sd>, <Wn>\t; 32-bit to single-precision variant", "UCVTF  <Dd>, <Wn>\t; 32-bit to double-precision variant", "UCVTF  <Hd>, <Xn>\t; 64-bit to half-precision variant", "UCVTF  <Sd>, <Xn>\t; 64-bit to single-precision variant", "UCVTF  <Dd>, <Xn>\t; 64-bit to double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "STLLRH", "short_desc": "Store LORelease Register Halfword", "full_desc": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SMNEGL", "short_desc": "Signed Multiply-Negate Long", "full_desc": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["SMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "UZP1", "short_desc": "Unzip vectors (primary)", "full_desc": "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"}, {"mnemonic": "LD1 (single structure)", "short_desc": "Load one single-element structure to one lane of one register", "full_desc": "Load one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&FP register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset variant", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "RET", "short_desc": "Return from subroutine", "full_desc": "Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return.", "syntax": ["RET  {<Xn>}\t; Integer variant"], "symbols": ["<Rn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field. Defaults to X30 if absent."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) target = X[n];\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"}, {"mnemonic": "UCVTF (vector, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (vector)", "full_desc": "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FCMGE (zero)", "short_desc": "Floating-point Compare Greater than or Equal to zero (vector)", "full_desc": "Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGE  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMGE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMOV (general)", "short_desc": "Floating-point Move to or from general-purpose register without conversion", "full_desc": "Floating-point Move to or from general-purpose register without conversion. This instruction transfers the contents of a SIMD&FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FMOV  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FMOV  <Hd>, <Wn>\t; 32-bit to half-precision variant", "FMOV  <Sd>, <Wn>\t; 32-bit to single-precision variant", "FMOV  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FMOV  <Hd>, <Xn>\t; 64-bit to half-precision variant", "FMOV  <Dd>, <Xn>\t; 64-bit to double-precision variant", "FMOV  <Vd>.D[1], <Xn>\t; 64-bit to top half of 128-bit variant", "FMOV  <Xd>, <Dn>\t; Double-precision to 64-bit variant", "FMOV  <Xd>, <Vn>.D[1]\t; Top half of 128-bit to 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "MOV (scalar)", "short_desc": "Move vector element to scalar", "full_desc": "Move vector element to scalar. This instruction duplicates the specified vector element in the SIMD&FP source register into a scalar, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <V><d>, <Vn>.<T>[<index>]\t; Scalar variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT", "full_desc": "Bitwise NOT writes the bitwise inverse of a register value to the destination register.", "syntax": ["MVN  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "MVN  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<imm6>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<imm6>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"]}, {"mnemonic": "ANDS (immediate)", "short_desc": "Bitwise AND (immediate), setting flags", "full_desc": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, #<imm>\t; 32-bit variant", "ANDS  <Xd>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "ROR (register)", "short_desc": "Rotate Right (register)", "full_desc": "Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ROR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ROR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "SABAL, SABAL2", "short_desc": "Signed Absolute difference and Accumulate Long", "full_desc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SABAL instruction extracts each source vector from the lower half of each source register, while the SABAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "FCVTAS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTAS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTAS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTAS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTAS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTAS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "NOP", "short_desc": "No Operation", "full_desc": "No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.", "syntax": ["NOP\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "FCVTZU (vector, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "ESB", "short_desc": "Error Synchronization Barrier", "full_desc": "Error Synchronization Barrier is a synchronization barrier instruction to barrier between errors. This instruction can be used at all Exception levels and in Debug state. This instruction might update DISR_EL1 and VDISR_EL2.\n\nIn Debug state, this instruction behaves as if SError interrupts are masked at all Exception levels. See Error Synchronization Barrier in the ARM(R) Reliability, Availability, and Serviceability (RAS) Specification, ARMv8, for ARMv8-A architecture profile.", "syntax": ["ESB\t; System variant"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0010 000' \n        op = if HaveRASExt() then SystemHintOp_ESB else SystemHintOp_NOP;\n    when '0010 001'\n        op = if HaveStatisticalProfiling() then SystemHintOp_PSB else SystemHintOp_NOP;\n    otherwise  op = SystemHintOp_NOP;", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"}, {"mnemonic": "USUBW, USUBW2", "short_desc": "Unsigned Subtract Wide", "full_desc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.\n\nThe vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register.\n\nThe USUBW instruction extracts vector elements from the lower half of the first source register, while the USUBW2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SBFM", "short_desc": "Signed Bitfield Move", "full_desc": "Signed Bitfield Move copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, shifting in copies of the sign bit in the upper bits and zeros in the lower bits.", "syntax": ["SBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "SBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "SLI", "short_desc": "Shift Left and Insert (immediate)", "full_desc": "Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SLI  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSL(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSL(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"}, {"mnemonic": "SYSL", "short_desc": "System instruction with result", "full_desc": "System instruction with result. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.", "syntax": ["SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>\t; System variant"], "symbols": ["<Rt>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<CRn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<CRm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field."], "decode": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');", "operation": "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "USRA", "short_desc": "Unsigned Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "HVC", "short_desc": "Hypervisor Call", "full_desc": "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a service.\n\nThe HVC instruction is undefined:\n\nOn executing an HVC instruction, the PE records the exception as a Hypervisor Call exception in ESR_ELx, using the EC value 0x16, and the value of the immediate argument.", "syntax": ["HVC  #<imm>\t; System variant"], "symbols": ["<imm16>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && IsSecure()) then\n    UnallocatedEncoding();\n\nhvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);\nif hvc_enable == '0' then\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallHypervisor(imm);"}, {"mnemonic": "SHA1P", "short_desc": "SHA1 hash update (parity)", "syntax": ["SHA1P  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory", "full_desc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STTR", "short_desc": "Store Register (unprivileged)", "full_desc": "Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SMULL", "short_desc": "Signed Multiply Long", "full_desc": "Signed Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["SMULL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "SVC", "short_desc": "Supervisor Call", "full_desc": "Supervisor Call causes an exception to be taken to EL1.\n\nOn executing an SVC instruction, the PE records the exception as a Supervisor Call exception in ESR_ELx, using the EC value 0x15, and the value of the immediate argument.", "syntax": ["SVC  #<imm>\t; System variant"], "symbols": ["<imm16>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "AArch64.CallSupervisor(imm);"}, {"mnemonic": "SWP, SWPA, SWPAL, SWPL", "short_desc": "Swap word or doubleword in memory", "full_desc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWPA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "SWPAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "SWP  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "SWPL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "SWPA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "SWPAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "SWP  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "SWPL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STSETH, STSETLH", "short_desc": "Atomic bit set on halfword in memory, without return", "full_desc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSETH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSETLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "LDARB", "short_desc": "Load-Acquire Register Byte", "full_desc": "Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ROR (immediate)", "short_desc": "Rotate right (immediate)", "full_desc": "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.", "syntax": ["ROR  <Wd>, <Ws>, #<shift>\t; 32-bit variant", "ROR  <Xd>, <Xs>, #<shift>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<imms>\nFor the 32-bit variant: is the amount by which to rotate, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the amount by which to rotate, in the range 0 to 63, encoded in the \"imms\" field."]}, {"mnemonic": "FMINNM (scalar)", "short_desc": "Floating-point Minimum Number (scalar)", "full_desc": "Floating-point Minimum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNM  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMINNM  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMINNM  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STUMIN, STUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMIN  <Ws>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "STUMINL  <Ws>, [<Xn|SP>]\t; 32-bit, release variant", "STUMIN  <Xs>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "STUMINL  <Xs>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "STXRB", "short_desc": "Store Exclusive Register Byte", "full_desc": "Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "BR", "short_desc": "Branch to Register", "full_desc": "Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.", "syntax": ["BR  <Xn>\t; Integer variant"], "symbols": ["<Rn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) target = X[n];\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"}, {"mnemonic": "SXTL, SXTL2", "short_desc": "Signed extend Long", "full_desc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SXTL instruction extracts the source vector from the lower half of the source register, while the SXTL2 instruction extracts the source vector from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "FMOV (vector, immediate)", "short_desc": "Floating-point move immediate (vector)", "full_desc": "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Vd>.<T>, #<imm>\t; Half-precision variant", "FMOV  <Vd>.<T>, #<imm>\t; Single-precision variant", "FMOV  <Vd>.2D, #<imm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<a:b:c:d:e:f:g:h>\nIs a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in \"a:b:c:d:e:f:g:h\". For details of the range of constants available and the encoding of <imm>, see Modified immediate constants in A64 floating-point instructions."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\n\nimm8 = a:b:c:d:e:f:g:h;\nimm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);\n\nimm = Replicate(imm16, datasize DIV 16);", "operation": "CheckFPAdvSIMDEnabled64();\n\nV[rd] = imm;"}, {"mnemonic": "BIT", "short_desc": "Bitwise Insert if True", "full_desc": "Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&FP register into the SIMD&FP destination register if the corresponding bit of the second source SIMD&FP register is 1, otherwise leaves the bit in the destination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "FRINTP (scalar)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTP  <Hd>, <Hn>\t; Half-precision variant", "FRINTP  <Sd>, <Sn>\t; Single-precision variant", "FRINTP  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "STUR", "short_desc": "Store Register (unscaled)", "full_desc": "Store Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FMAXNMP (vector)", "short_desc": "Floating-point Maximum Number Pairwise (vector)", "full_desc": "Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FSQRT (scalar)", "short_desc": "Floating-point Square Root (scalar)", "full_desc": "Floating-point Square Root (scalar). This instruction calculates the square root of the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSQRT  <Hd>, <Hn>\t; Half-precision variant", "FSQRT  <Sd>, <Sn>\t; Single-precision variant", "FSQRT  <Dd>, <Dn>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SADDL, SADDL2", "short_desc": "Signed Add Long (vector)", "full_desc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SADDL instruction extracts each source vector from the lower half of each source register, while the SADDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory", "full_desc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMUL (by element)", "short_desc": "Floating-point Multiply (by element)", "full_desc": "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<M:Rm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<H:L:M>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ST2 (single structure)", "short_desc": "Store single 2-element structure from one lane of two registers", "full_desc": "Store single 2-element structure from one lane of two registers. This instruction stores a 2-element structure to memory from corresponding elements of two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset variant", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Q:S:size>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<Q:S:size>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<Q:S>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<Q>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "SRI", "short_desc": "Shift Right and Insert (immediate)", "full_desc": "Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRI  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSR(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSR(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"}, {"mnemonic": "FCVTMU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTMU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FACGT", "short_desc": "Floating-point Absolute Compare Greater than (vector)", "full_desc": "Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FACGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FACGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "REV64", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register.\n\nWhen assembling for ARMv8.2, an assembler must support this pseudo-instruction. It is optional whether an assembler supports this pseudo-instruction when assembling for an architecture earlier than ARMv8.2.", "syntax": ["REV64  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "FRECPS", "short_desc": "Floating-point Reciprocal Step", "full_desc": "Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPS  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FRECPS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "MSUB", "short_desc": "Multiply-Subtract", "full_desc": "Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register.", "syntax": ["MSUB  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit variant", "MSUB  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 32-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"}, {"mnemonic": "BSL", "short_desc": "Bitwise Select", "full_desc": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "UMINV", "short_desc": "Unsigned Minimum across Vector", "full_desc": "Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "CINV", "short_desc": "Conditional Invert", "full_desc": "Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINV  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CINV  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "ADDV", "short_desc": "Add across Vector", "full_desc": "Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = ReduceOp_ADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "MVNI", "short_desc": "Move inverted Immediate (vector)", "full_desc": "Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate variant", "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate variant", "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<a:b:c:d:e:f:g:h>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "UMNEGL", "short_desc": "Unsigned Multiply-Negate Long", "full_desc": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["UMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "SDIV", "short_desc": "Signed Divide", "full_desc": "Signed Divide divides a signed integer register value by another signed integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["SDIV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SDIV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "SBC", "short_desc": "Subtract with Carry", "full_desc": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.", "syntax": ["SBC  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SBC  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "Shared Pseudocode Functions", "short_desc": "This page displays common pseudocode functions shared by many pages", "syntax": [], "symbols": []}, {"mnemonic": "INS (element)", "short_desc": "Insert vector element from another vector element", "full_desc": "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\ninteger dst_index = UInt(imm5<4:size+1>);\ninteger src_index = UInt(imm4<3:size>);\ninteger idxdsize = if imm4<3> == '1' then 128 else 64; \n// imm4<size-1:0> is IGNORED \n\ninteger esize = 8 << size;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(128) result;\n\nresult = V[d];\nElem[result, dst_index, esize] = Elem[operand, src_index, esize];\nV[d] = result;"}, {"mnemonic": "LDTRH", "short_desc": "Load Register Halfword (unprivileged)", "full_desc": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nThe memory is restricted as if execution is at EL0 when:\n\nOtherwise, the access permission is for the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LDUR (SIMD&FP)", "short_desc": "Load SIMD&FP Register (unscaled offset)", "full_desc": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit variant", "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit variant", "LDUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant", "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm9>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SCVTF (vector, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (vector)", "full_desc": "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FMAX (scalar)", "short_desc": "Floating-point Maximum (scalar)", "full_desc": "Floating-point Maximum (scalar). This instruction compares the two source SIMD&FP registers, and writes the larger of the two floating-point values to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAX  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMAX  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMAX  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "DCPS1", "short_desc": "Debug Change PE State to EL1.", "full_desc": "Debug Change PE State to EL1, when executed in Debug state:\n\nThe target exception level of a DCPS1 instruction is:\n\nWhen the target Exception level of a DCPS1 instruction is ELx, on executing this instruction:\n\nThis instruction is undefined at EL0 in Non-secure state if EL2 is implemented and  HCR_EL2.TGE == 1.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS1  {#<imm>}\t; System variant"], "symbols": ["<imm16>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();", "operation": "DCPSInstruction(target_level);"}, {"mnemonic": "LDAXRB", "short_desc": "Load-Acquire Exclusive Register Byte", "full_desc": "Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusive Monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusive Monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusive Monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINTX (vector)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nAn Inexact exception is raised when the result value is not numerically equal to the input value. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTX  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTX  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "UMAXV", "short_desc": "Unsigned Maximum across Vector", "full_desc": "Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "DCPS3", "short_desc": "Debug Change PE State to EL3", "full_desc": "Debug Change PE State to EL3, when executed in Debug state:\n\nThe target exception level of a DCPS3 instruction is EL3.\n\nOn executing a DCPS3 instruction:\n\nThis instruction is undefined at all exception levels if either:\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS3  {#<imm>}\t; System variant"], "symbols": ["<imm16>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();", "operation": "DCPSInstruction(target_level);"}, {"mnemonic": "FCVTZU (vector, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTZU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FCCMP", "short_desc": "Floating-point Conditional quiet Compare (scalar)", "full_desc": "Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.\n\nIt raises an Invalid Operation exception only if either operand is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision variant", "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision variant", "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision variant"], "symbols": ["<Rn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "SQSHL (register)", "short_desc": "Signed saturating Shift Left (register)", "full_desc": "Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see SQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "AND (immediate)", "short_desc": "Bitwise AND (immediate)", "full_desc": "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["AND  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "AND  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LSL (immediate)", "short_desc": "Logical Shift Left (immediate)", "full_desc": "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSL  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "LSL  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63."]}, {"mnemonic": "FCVTN, FCVTN2", "short_desc": "Floating-point Convert to lower precision Narrow (vector)", "full_desc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.\n\nThe FCVTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);\n\nVpart[d, part] = result;"}, {"mnemonic": "SHA1C", "short_desc": "SHA1 hash update (choose)", "syntax": ["SHA1C  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();", "operation": "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "FMULX (by element)", "short_desc": "Floating-point Multiply extended (by element)", "full_desc": "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&FP register by the specified floating-point value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMULX  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<M:Rm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<H:L:M>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SSRA", "short_desc": "Signed Shift Right and Accumulate (immediate)", "full_desc": "Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FMLA (vector)", "short_desc": "Floating-point fused Multiply-Add to accumulator (vector)", "full_desc": "Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SWPH, SWPAH, SWPALH, SWPLH", "short_desc": "Swap halfword in memory", "full_desc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWPAH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire variant", "SWPALH  <Ws>, <Wt>, [<Xn|SP>]\t; Acquire and release variant", "SWPH  <Ws>, <Wt>, [<Xn|SP>]\t; No memory ordering variant", "SWPLH  <Ws>, <Wt>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINTN (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTN  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTN  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "LDP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers", "full_desc": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit variant", "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit variant", "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": ["<Rt>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rt>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm7>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm7>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm7>\nFor the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the \"imm7\" field as <imm>/16.", "<imm7>\nFor the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "CLREX", "short_desc": "Clear Exclusive", "full_desc": "Clear Exclusive clears the local monitor of the executing PE.", "syntax": ["CLREX  {#<imm>}\t; System variant"], "symbols": ["<CRm>\nIs an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field."], "decode": "// CRm field is ignored", "operation": "ClearExclusiveLocal(ProcessorID());"}, {"mnemonic": "UMULL, UMULL2 (vector)", "short_desc": "Unsigned Multiply long (vector)", "full_desc": "Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMULL instruction extracts each source vector from the lower half of each source register, while the UMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SMLSL, SMLSL2 (by element)", "short_desc": "Signed Multiply-Subtract Long (vector, by element)", "full_desc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts vector elements from the lower half of the first source register, while the SMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "STSMINH, STSMINLH", "short_desc": "Atomic signed minimum on halfword in memory, without return", "full_desc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMINH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMINLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;"}, {"mnemonic": "REV32", "short_desc": "Reverse bytes in 32-bit words", "full_desc": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register.", "syntax": ["REV32  <Xd>, <Xn>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "MOV (bitmask immediate)", "short_desc": "Move (bitmask immediate)", "full_desc": "Move (bitmask immediate) writes a bitmask immediate value to a register.", "syntax": ["MOV  <Wd|WSP>, #<imm>\t; 32-bit variant", "MOV  <Xd|SP>, #<imm>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<immr:imms>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\", but excluding values which could be encoded by MOVZ or MOVN.", "<N:immr:imms>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\", but excluding values which could be encoded by MOVZ or MOVN."]}, {"mnemonic": "SMINP", "short_desc": "Signed Minimum Pairwise", "full_desc": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCMPE", "short_desc": "Floating-point signaling Compare (scalar)", "full_desc": "Floating-point signaling Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMPE  <Hn>, <Hm>\t; Half-precision variant", "FCMPE  <Hn>, #0.0\t; Half-precision, zero variant", "FCMPE  <Sn>, <Sm>\t; Single-precision variant", "FCMPE  <Sn>, #0.0\t; Single-precision, zero variant", "FCMPE  <Dn>, <Dm>\t; Double-precision variant", "FCMPE  <Dn>, #0.0\t; Double-precision, zero variant"], "symbols": ["<Rn>\nFor the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nFor the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rn>\nFor the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nFor the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"}, {"mnemonic": "SMIN", "short_desc": "Signed Minimum (vector)", "full_desc": "Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ADD (vector)", "short_desc": "Add (vector)", "full_desc": "Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "CCMN (register)", "short_desc": "Conditional Compare Negative (register)", "full_desc": "Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": ["<Rn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "FCMGE (register)", "short_desc": "Floating-point Compare Greater than or Equal (vector)", "full_desc": "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "UCVTF (scalar, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (scalar)", "full_desc": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision variant", "UCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision variant", "UCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision variant", "UCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision variant", "UCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision variant", "UCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision variant"], "symbols": ["<Rd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<scale>\nFor the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus \"scale\".", "<scale>\nFor the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "UQRSHL", "short_desc": "Unsigned saturating Rounding Shift Left (register)", "full_desc": "Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see UQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "UADDLP", "short_desc": "Unsigned Add Long Pairwise", "full_desc": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"}, {"mnemonic": "FMINNMV", "short_desc": "Floating-point Minimum Number across Vector", "full_desc": "Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": ["<>\nFor the half-precision variant: is the destination width specifier, H.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "CINC", "short_desc": "Conditional Increment", "full_desc": "Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINC  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CINC  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm:Rn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "SQRDMLSH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "STLR", "short_desc": "Store-Release Register", "full_desc": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": ["<Rt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UCVTF (vector, integer)", "short_desc": "Unsigned integer Convert to Floating-point (vector)", "full_desc": "Unsigned integer Convert to Floating-point (vector). This instruction converts each element in a vector from an unsigned integer value to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Hn>\t; Scalar half precision variant", "UCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FRECPE", "short_desc": "Floating-point Reciprocal Estimate", "full_desc": "Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPE  <Hd>, <Hn>\t; Scalar half precision variant", "FRECPE  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SRSRA", "short_desc": "Signed Rounding Shift Right and Accumulate (immediate)", "full_desc": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": ["<Rd>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQDMLSL, SQDMLSL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts vector elements from the lower half of the first source register, while the SQDMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DMB", "short_desc": "Data Memory Barrier", "full_desc": "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier.", "syntax": ["DMB  <option>|#<imm>\t; System variant"], "symbols": ["<>\nSpecifies the limitation on the barrier operation. Values are:", "<>\nAll other encodings of CRm that are not listed above are reserved, and can be encoded using the #<imm> syntax. It is implementation defined whether options other than SY are implemented. All unsupported and reserved options must execute as a full system barrier operation, but software must not rely on this behavior. For more information on whether an access is before or after a barrier instruction, see Data Memory Barrier (DMB) or see Data Synchronization Barrier (DSB).", "<CRm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;", "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"}, {"mnemonic": "FCVTAU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTAU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTAU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTAU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTAU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTAU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01' \n        fltsize = 64;\n    when '10' \n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11' \n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    otherwise \n        UnallocatedEncoding();", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;"}, {"mnemonic": "SRHADD", "short_desc": "Signed Rounding Halving Add", "full_desc": "Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "ST1 (multiple structures)", "short_desc": "Store multiple single-element structures from one, two, three, or four registers", "full_desc": "Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to memory from one, two, three, or four SIMD&FP registers, without interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST1  { <Vt>.<T> }, [<Xn|SP>]\t; One register variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers variant", "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset variant", "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset variant"], "symbols": ["<Rt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Rt>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Rt>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Rm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"}, {"mnemonic": "BFC", "short_desc": "Bitfield Clear, leaving other bits unchanged", "syntax": ["BFC  <Wd>, #<lsb>, #<width>\t; 32-bit variant", "BFC  <Xd>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": ["<Rd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "DUP (general)", "short_desc": "Duplicate general-purpose register to vector", "full_desc": "Duplicate general-purpose register to vector. This instruction duplicates the contents of the source general-purpose register into a scalar or each element in a vector, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["DUP  <Vd>.<T>, <R><n>\t; Advanced SIMD variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\n// imm5<4:size+1> is IGNORED\n\nif size == 3 && Q == '0' then ReservedValue();\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"}, {"mnemonic": "FCVTAS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTAS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": ["<Rd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory", "full_desc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire variant", "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, acquire and release variant", "LDSMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, no memory ordering variant", "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit, release variant", "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire variant", "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, acquire and release variant", "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, no memory ordering variant", "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit, release variant"], "symbols": ["<Rs>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Rt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Rn>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase o3:opc of\n    when '0000' op = MemAtomicOp_ADD;\n    when '0001' op = MemAtomicOp_BIC;\n    when '0010' op = MemAtomicOp_EOR;\n    when '0011' op = MemAtomicOp_ORR;\n    when '0100' op = MemAtomicOp_SMAX;\n    when '0101' op = MemAtomicOp_SMIN;\n    when '0110' op = MemAtomicOp_UMAX;\n    when '0111' op = MemAtomicOp_UMIN;\n    when '1000' op = MemAtomicOp_SWP;\n    otherwise UnallocatedEncoding();", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n    when MemAtomicOp_SWP   result = value;\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\nMem[address, datasize DIV 8, stacctype] = result;\n\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SMAXP", "short_desc": "Signed Maximum Pairwise", "full_desc": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": ["<Rd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Rm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "DCPS2", "short_desc": "Debug Change PE State to EL2.", "full_desc": "Debug Change PE State to EL2, when executed in Debug state:\n\nThe target exception level of a DCPS2 instruction is:\n\nWhen the target Exception level of a DCPS2 instruction is ELx, on executing this instruction:\n\nThis instruction is undefined at the following exception levels:\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS2  {#<imm>}\t; System variant"], "symbols": ["<imm16>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();", "operation": "DCPSInstruction(target_level);"}]