{
    "ADC" : {
        "short_desc" : "Add with Carry",
        "full_desc" : "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register.",
        "syntax" : [
            "ADC\t<Wd>, <Wn>, <Wm> \t; 32-bit variant",
            "ADC\t<Xd>, <Xn>, <Xm> \t; 64-bit variant"
        ],
        "symbol" : [
            "<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.",
            "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.",
            "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.",
            "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.",
            "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.",
            "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."
        ],
        "decode" : "integer d = UInt(Rd);integer n = UInt(Rn);integer m = UInt(Rm);integer datasize = if sf == '1' then 64 else 32;",
        "operation" : "bits(datasize) result; bits(datasize) operand1 = X[n]; bits(datasize) operand2 = X[m];(result, -) = AddWithCarry(operand1, operand2, PSTATE.C); X[d] = result;"
    },
    "ADCS" : {
        "short_desc" : "Add with Carry, setting flags",
        "full_desc" : "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result.",
        "syntax" : [
            "ADCS\t<Wd>, <Wn>, <Wm> \t; 32-bit variant",
            "ADCS\t<Xd>, <Xn>, <Xm> \t; 64-bit variant"
        ],
        "symbol" : [
            "<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.",
            "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.",
            "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.",
            "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.",
            "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.",
            "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."
        ],
        "decode" : "integer d = UInt(Rd);integer n = UInt(Rn);integer m = UInt(Rm);integer datasize = if sf == '1' then 64 else 32;",
        "operation" : "bits(datasize) result; bits(datasize) operand1 = X[n]; bits(datasize) operand2 = X[m]; bits(4) nzcv;(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C); PSTATE.<N,Z,C,V> = nzcv;X[d] = result;"
    },
    "B.cond" : {
        "short_desc" : "Branch conditionally",
        "full_desc" : "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.",
        "syntax" : [
            "B.<cond>\t<label>"
        ],
        "symbol" : [
            "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way.",
            "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."
        ],
        "decode" : "bits(64) offset = SignExtend(imm19:'00', 64); bits(4) condition = cond;",
        "operation" : "if ConditionHolds(condition) then\nBranchTo(PC[] + offset, BranchType_JMP);"
    },
    "B.cond" : {
        "short_desc" : "Branch conditionally",
        "full_desc" : "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.",
        "syntax" : [
            "B.<cond>\t<label>"
        ],
        "symbol" : [
            "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way.",
            "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."
        ],
        "decode" : "bits(64) offset = SignExtend(imm19:'00', 64); bits(4) condition = cond;",
        "operation" : "if ConditionHolds(condition) then\nBranchTo(PC[] + offset, BranchType_JMP);"
    }
}
