[{"mnemonic": "LDNT1D (scalar plus scalar)", "short_desc": "Contiguous load non-temporal doublewords to vector (scalar index)", "syntax": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "ZIP1", "short_desc": "Zip vectors (primary)", "full_desc": "Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FMLAL, FMLAL2 (vector)", "short_desc": "Floating-point fused Multiply-Add Long to accumulator (vector)", "full_desc": "Floating-point fused Multiply-Add Long to accumulator (vector). This instruction multiplies corresponding half-precision floating-point values in the vectors in the two source SIMD&FP registers, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLAL variant", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLAL2 variant"], "symbols": []}, {"mnemonic": "TSB CSYNC", "short_desc": "Trace Synchronization Barrier", "full_desc": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions.\n\nIf ARMv8.4-Trace is not implemented, this instruction executes as a NOP.", "syntax": ["TSB CSYNC\t; System variant"], "symbols": []}, {"mnemonic": "UMOV", "short_desc": "Unsigned Move vector element to general-purpose register", "full_desc": "Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit variant", "UMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-reg,UMOV-64-reg variant"], "symbols": []}, {"mnemonic": "FMIN (immediate)", "short_desc": "Floating-point minimum with immediate (predicated)", "syntax": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDURSB", "short_desc": "Load Register Signed Byte (unscaled)", "full_desc": "Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FABS (vector)", "short_desc": "Floating-point Absolute value (vector)", "full_desc": "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABS  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FABS  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "CMEQ (zero)", "short_desc": "Compare bitwise Equal to zero (vector)", "full_desc": "Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMEQ  <V><d>, <V><n>, #0\t; Scalar variant", "CMEQ  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": []}, {"mnemonic": "MRS", "short_desc": "Move System Register", "full_desc": "Move System Register allows the PE to read an AArch64 System register into a general-purpose register.", "syntax": ["MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)\t; System variant"], "symbols": []}, {"mnemonic": "MOV (immediate, predicated, merging)", "short_desc": "Move signed integer immediate to vector elements (merging)", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "RDFFR, RDFFRS (predicated)", "short_desc": "Return predicate of succesfully loaded elements", "syntax": ["RDFFR   <Pd>.B, <Pg>/Z\t; Not setting the condition flags variant", "RDFFRS  <Pd>.B, <Pg>/Z\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "USHR", "short_desc": "Unsigned Shift Right (immediate)", "full_desc": "Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "FDIV (scalar)", "short_desc": "Floating-point Divide (scalar)", "full_desc": "Floating-point Divide (scalar). This instruction divides the floating-point value of the first source SIMD&FP register by the floating-point value of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FDIV  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FDIV  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FDIV  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "NGC", "short_desc": "Negate with Carry", "full_desc": "Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register.", "syntax": ["NGC  <Wd>, <Wm>\t; 32-bit variant", "NGC  <Xd>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SM3PARTW2", "short_desc": "SM3PARTW2", "full_desc": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LDADD, LDADDA, LDADDAL, LDADDL", "short_desc": "Atomic add on word or doubleword in memory", "full_desc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADD  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADD variant", "LDADDA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDA variant", "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDAL variant", "LDADDL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDL variant", "LDADD  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADD variant", "LDADDA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDA variant", "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDAL variant", "LDADDL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDL variant"], "symbols": []}, {"mnemonic": "LDRH (immediate)", "short_desc": "Load Register Halfword (immediate)", "full_desc": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "STLLRB", "short_desc": "Store LORelease Register Byte", "full_desc": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "UCVTF", "short_desc": "Unsigned integer convert to floating-point (predicated)", "syntax": ["UCVTF   <Zd>.H, <Pg>/M, <Zn>.H\t; 16-bit to half-precision variant", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.S\t; 32-bit to half-precision variant", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.S\t; 32-bit to single-precision variant", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.S\t; 32-bit to double-precision variant", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.D\t; 64-bit to half-precision variant", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.D\t; 64-bit to single-precision variant", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.D\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "STUR (SIMD&FP)", "short_desc": "Store SIMD&FP register (unscaled offset)", "full_desc": "Store SIMD&FP register (unscaled offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit variant", "STUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit variant", "STUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant", "STUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "BLRAA, BLRAAZ, BLRAB, BLRABZ", "short_desc": "Branch with Link to Register, with pointer authentication", "full_desc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by <Xn>, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4.\n\nThe modifier is:\n\nKey A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.", "syntax": ["BLRAAZ  <Xn>\t; Key A, zero modifier variant", "BLRAA  <Xn>, <Xm|SP>\t; Key A, register modifier variant", "BLRABZ  <Xn>\t; Key B, zero modifier variant", "BLRAB  <Xn>, <Xm|SP>\t; Key B, register modifier variant"], "symbols": []}, {"mnemonic": "FRINTI (vector)", "short_desc": "Floating-point Round to Integral, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTI  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTI  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FADDP (vector)", "short_desc": "Floating-point Add Pairwise (vector)", "full_desc": "Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ASRR", "short_desc": "Reversed arithmetic shift right by vector (predicated)", "syntax": ["ASRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STRB (immediate)", "short_desc": "Store Register Byte (immediate)", "full_desc": "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "STRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "FCVTZS", "short_desc": "Floating-point convert to signed integer, rounding toward zero (predicated)", "syntax": ["FCVTZS  <Zd>.H, <Pg>/M, <Zn>.H\t; Half-precision to 16-bit variant", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to 32-bit variant", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to 64-bit variant", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.S\t; Single-precision to 32-bit variant", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to 64-bit variant", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to 32-bit variant", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.D\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "SQDECH (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count", "syntax": ["SQDECH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SHA1SU1", "short_desc": "SHA1 schedule update 1", "full_desc": "SHA1 schedule update 1.", "syntax": ["SHA1SU1  <Vd>.4S, <Vn>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FAC<cc>", "short_desc": "Floating-point absolute compare vectors", "syntax": ["FACGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than variant", "FACGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal variant"], "symbols": []}, {"mnemonic": "LDLAR", "short_desc": "Load LOAcquire Register", "full_desc": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDLAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQADD", "short_desc": "Signed saturating Add", "full_desc": "Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "FMLS (indexed)", "short_desc": "Floating-point fused multiply-subtract by indexed elements (Zda = Zda + -Zn * Zm[indexed])", "syntax": ["FMLS    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision variant", "FMLS    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision variant", "FMLS    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LDFF1D (scalar plus vector)", "short_desc": "Gather load first-fault doublewords to vector (vector index)", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset variant", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset variant", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "LD4H (scalar plus scalar)", "short_desc": "Contiguous load four-halfword structures to four vectors (scalar index)", "syntax": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "EXT", "short_desc": "Extract vector from pair of vectors", "syntax": ["EXT     <Zdn>.B, <Zdn>.B, <Zm>.B, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "MLA (vector)", "short_desc": "Multiply-Add to accumulator (vector)", "full_desc": "Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SSUBL, SSUBL2", "short_desc": "Signed Subtract Long", "full_desc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.\n\nThe SSUBL instruction extracts each source vector from the lower half of each source register, while the SSUBL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LD3H (scalar plus immediate)", "short_desc": "Contiguous load three-halfword structures to three vectors (immediate index)", "syntax": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SQSHRUN, SQSHRUN2", "short_desc": "Signed saturating Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SQRSHRUN.\n\nThe SQSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "LD2 (single structure)", "short_desc": "Load single 2-element structure to one lane of two registers", "full_desc": "Load single 2-element structure to one lane of two registers. This instruction loads a 2-element structure from memory and writes the result to the corresponding elements of the two SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset variant", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset variant", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset variant", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset variant", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "BFMLALB (indexed)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (bottom, indexed)", "syntax": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "FNMUL (scalar)", "short_desc": "Floating-point Multiply-Negate (scalar)", "full_desc": "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the negation of the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMUL  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FNMUL  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FNMUL  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "CMPLO (vectors)", "short_desc": "Compare unsigned lower than vector, setting the condition flags", "syntax": ["CMPLO   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Higher variant"], "symbols": []}, {"mnemonic": "FSCALE", "short_desc": "Floating-point adjust exponent by vector (predicated)", "syntax": ["FSCALE  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SEVL", "short_desc": "Send Event Local", "full_desc": "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction.", "syntax": ["SEVL\t; System variant"], "symbols": []}, {"mnemonic": "CPY (immediate, zeroing)", "short_desc": "Copy signed integer immediate to vector elements (zeroing)", "syntax": ["CPY     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "ABS", "short_desc": "Absolute value (predicated)", "syntax": ["ABS     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STLLR", "short_desc": "Store LORelease Register", "full_desc": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BIC (immediate)", "short_desc": "Bitwise clear bits using immediate (unpredicated)", "syntax": ["BIC     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "UDOT (by element)", "short_desc": "Dot Product unsigned arithmetic (vector, by element)", "full_desc": "Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SM3TT2B", "short_desc": "SM3TT2B", "full_desc": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:\n\nA three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 19.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FRSQRTE", "short_desc": "Floating-point Reciprocal Square Root Estimate", "full_desc": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRSQRTE  <Hd>, <Hn>\t; Scalar half precision variant", "FRSQRTE  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SDOT (vector)", "short_desc": "Dot Product signed arithmetic (vector)", "full_desc": "Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "LD1RQD (scalar plus immediate)", "short_desc": "Contiguous load and replicate two doublewords (immediate index)", "syntax": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDAPUR", "short_desc": "Load-Acquire RCpc Register (unscaled)", "full_desc": "Load-Acquire RCpc Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDAPUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMIN (scalar)", "short_desc": "Floating-point Minimum (scalar)", "full_desc": "Floating-point Minimum (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMIN  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMIN  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMIN  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LD1ROH (scalar plus immediate)", "short_desc": "Contiguous load and replicate sixteen halfwords (immediate index)", "syntax": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "CLZ (vector)", "short_desc": "Count Leading Zero bits (vector)", "full_desc": "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CLZ  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "PRFM (register)", "short_desc": "Prefetch Memory (register)", "full_desc": "Prefetch Memory (register) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; Integer variant"], "symbols": []}, {"mnemonic": "B.cond", "short_desc": "Branch conditionally", "full_desc": "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B.<cond>  <label>\t; 19-bit signed PC-relative branch offset variant"], "symbols": []}, {"mnemonic": "SQRSHRN, SQRSHRN2", "short_desc": "Signed saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN.\n\nThe SQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "UQSUB (immediate)", "short_desc": "Unsigned saturating subtract immediate (unpredicated)", "syntax": ["UQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "LDAPURB", "short_desc": "Load-Acquire RCpc Register Byte (unscaled)", "full_desc": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "PRFUM", "short_desc": "Prefetch Memory (unscaled offset)", "full_desc": "Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFUM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "MLS", "short_desc": "Multiply-subtract vectors (predicated), writing addend [Zda = Zda - Zn * Zm]", "syntax": ["MLS     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LSRV", "short_desc": "Logical Shift Right Variable", "full_desc": "Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSRV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSRV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LSL (register)", "short_desc": "Logical Shift Left (register)", "full_desc": "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSL  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSL  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ADD (shifted register)", "short_desc": "Add (shifted register)", "full_desc": "Add (shifted register) adds a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FACGE", "short_desc": "Floating-point Absolute Compare Greater than or Equal (vector)", "full_desc": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FACGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FACGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FCMEQ (register)", "short_desc": "Floating-point Compare Equal (vector)", "full_desc": "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMEQ  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMEQ  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SMC", "short_desc": "Secure Monitor Call", "full_desc": "Secure Monitor Call causes an exception to EL3.\n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC instruction at EL1 or higher generates a Secure Monitor Call exception, recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.\n\nIf the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security state, execution of an SMC instruction at EL1 generates an exception that is taken to EL2, regardless of the value of SCR_EL3.SMD. For more information, see Traps to EL2 of Non-secure EL1 execution of SMC instructions.\n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC instruction is undefined.", "syntax": ["SMC  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "SSHLL, SSHLL2", "short_desc": "Signed Shift Left Long (immediate)", "full_desc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SSHLL instruction extracts vector elements from the lower half of the source register, while the SSHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCMLA (by element)", "short_desc": "Floating-point Complex Multiply Accumulate (by element)", "full_desc": "Floating-point Complex Multiply Accumulate (by element).\n\nThis instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on complex numbers from the first source register and the destination register with the specified complex number from the second source register:\n\nThe multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>\t;  variant", "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>\t;  variant"], "symbols": []}, {"mnemonic": "UDIVR", "short_desc": "Unsigned reversed divide (predicated)", "syntax": ["UDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTXN, FCVTXN2", "short_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector)", "full_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nThe FCVTXN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTXN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTXN  <Vb><d>, <Va><n>\t; Scalar variant", "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": []}, {"mnemonic": "ASR (wide elements, unpredicated)", "short_desc": "Arithmetic shift right by 64-bit wide elements (unpredicated)", "syntax": ["ASR     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "UMIN (vectors)", "short_desc": "Unsigned minimum vectors (predicated)", "syntax": ["UMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST2W (scalar plus scalar)", "short_desc": "Contiguous store two-word structures from two vectors (scalar index)", "syntax": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory", "full_desc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINAB variant", "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINALB variant", "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINB variant", "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINLB variant"], "symbols": []}, {"mnemonic": "ADR", "short_desc": "Form PC-relative address", "full_desc": "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.", "syntax": ["ADR  <Xd>, <label>\t; Literal variant"], "symbols": []}, {"mnemonic": "TRN2", "short_desc": "Transpose vectors (secondary)", "full_desc": "Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LD2D (scalar plus immediate)", "short_desc": "Contiguous load two-doubleword structures to two vectors (immediate index)", "syntax": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (wide immediate)", "short_desc": "Move (wide immediate)", "full_desc": "Move (wide immediate) moves a 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit variant", "MOV  <Xd>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQDECW (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 32-bit predicate constraint element count", "syntax": ["UQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "CNT", "short_desc": "Population Count per byte", "full_desc": "Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CNT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "INDEX (immediates)", "short_desc": "Create index starting from and incremented by immediate", "syntax": ["INDEX   <Zd>.<T>, #<imm1>, #<imm2>\t; SVE variant"], "symbols": []}, {"mnemonic": "EOR (vectors, predicated)", "short_desc": "Bitwise exclusive OR vectors (predicated)", "syntax": ["EOR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDARH", "short_desc": "Load-Acquire Register Halfword", "full_desc": "Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "UQXTN, UQXTN2", "short_desc": "Unsigned saturating extract Narrow", "full_desc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe UQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQXTN  <Vb><d>, <Va><n>\t; Scalar variant", "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": []}, {"mnemonic": "UHSUB", "short_desc": "Unsigned Halving Subtract", "full_desc": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "XPACD, XPACI, XPACLRI", "short_desc": "Strip Pointer Authentication Code", "full_desc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI.\n\nThe XPACD instruction is used for data addresses, and XPACI and XPACLRI are used for instruction addresses.", "syntax": ["XPACD  <Xd>\t; XPACD variant", "XPACI  <Xd>\t; XPACI variant", "XPACLRI\t; System variant"], "symbols": []}, {"mnemonic": "FSQRT", "short_desc": "Floating-point square root (predicated)", "syntax": ["FSQRT   <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UZP1, UZP2 (vectors)", "short_desc": "Concatenate even or odd elements from two vectors", "syntax": ["UZP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Even variant", "UZP1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Even (quadwords) variant", "UZP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Odd variant", "UZP2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Odd (quadwords) variant"], "symbols": []}, {"mnemonic": "STNT1H (scalar plus immediate)", "short_desc": "Contiguous store non-temporal halfwords from vector (immediate index)", "syntax": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDGM", "short_desc": "Load Tag Multiple", "full_desc": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read from address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the destination register not written with an Allocation Tag are set to 0.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "syntax": ["LDGM  <Xt>, [<Xn|SP>]\t; Integer variant"], "symbols": []}, {"mnemonic": "LD1RQW (scalar plus immediate)", "short_desc": "Contiguous load and replicate four words (immediate index)", "syntax": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "STZGM", "short_desc": "Store Tag and Zero Multiple", "full_desc": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation Tags and stores zero to the associated data locations, where the size of N is identified in DCZID_EL0.BS, and the Allocation Tag written to address A is taken from the source register bits<3:0>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "syntax": ["STZGM  <Xt>, [<Xn|SP>]\t; Integer variant"], "symbols": []}, {"mnemonic": "FCM<cc> (zero)", "short_desc": "Floating-point compare vector with zero", "syntax": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Equal variant", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Greater than variant", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Greater than or equal variant", "FCMLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Less than variant", "FCMLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Less than or equal variant", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Not equal variant"], "symbols": []}, {"mnemonic": "LDFF1B (vector plus immediate)", "short_desc": "Gather load first-fault unsigned bytes to vector (immediate index)", "syntax": ["LDFF1B  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "URECPE", "short_desc": "Unsigned Reciprocal Estimate", "full_desc": "Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URECPE  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "LDFF1B (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned bytes to vector (scalar index)", "syntax": ["LDFF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 8-bit element variant", "LDFF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 16-bit element variant", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 32-bit element variant", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDXRH", "short_desc": "Load Exclusive Register Halfword", "full_desc": "Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "SHA1M", "short_desc": "SHA1 hash update (majority)", "full_desc": "SHA1 hash update (majority).", "syntax": ["SHA1M  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SYS", "short_desc": "System instruction", "full_desc": "System instruction. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.", "syntax": ["SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}\t; System variant"], "symbols": []}, {"mnemonic": "REV (predicate)", "short_desc": "Reverse all elements in a predicate", "syntax": ["REV     <Pd>.<T>, <Pn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SPLICE", "short_desc": "Splice two vectors under predicate control", "syntax": ["SPLICE  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UBFIZ", "short_desc": "Unsigned Bitfield Insert in Zero", "full_desc": "Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, setting the destination bits above and below the bitfield to zero.", "syntax": ["UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CNT", "short_desc": "Count non-zero bits (predicated)", "syntax": ["CNT     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SQDECB", "short_desc": "Signed saturating decrement scalar by multiple of 8-bit predicate constraint element count", "syntax": ["SQDECB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQINCD (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 64-bit predicate constraint element count", "syntax": ["UQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFH (scalar plus vector)", "short_desc": "Gather prefetch halfwords (scalar plus vector)", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant"], "symbols": []}, {"mnemonic": "FRSQRTS", "short_desc": "Floating-point Reciprocal Square Root Step", "full_desc": "Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRSQRTS  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FRSQRTS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDFF1SW (scalar plus vector)", "short_desc": "Gather load first-fault signed words to vector (vector index)", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "ORR (vector, immediate)", "short_desc": "Bitwise inclusive OR (vector, immediate)", "full_desc": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit variant", "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit variant"], "symbols": []}, {"mnemonic": "ST1H (scalar plus vector)", "short_desc": "Scatter store halfwords from a vector (vector index)", "syntax": ["ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "ST2D (scalar plus scalar)", "short_desc": "Contiguous store two-doubleword structures from two vectors (scalar index)", "syntax": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "SMULH", "short_desc": "Signed multiply returning high half (predicated)", "syntax": ["SMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD2W (scalar plus immediate)", "short_desc": "Contiguous load two-word structures to two vectors (immediate index)", "syntax": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "BIC (vectors, predicated)", "short_desc": "Bitwise clear vectors (predicated)", "syntax": ["BIC     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINTX (scalar)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nWhen the result value is not numerically equal to the input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTX  <Hd>, <Hn>\t; Half-precision variant", "FRINTX  <Sd>, <Sn>\t; Single-precision variant", "FRINTX  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "NEGS", "short_desc": "Negate, setting flags", "full_desc": "Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NEGS  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "NEGS  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CMP<cc> (immediate)", "short_desc": "Compare vector to immediate", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Equal variant", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Greater than variant", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Greater than or equal variant", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Higher variant", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Higher or same variant", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Less than variant", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Less than or equal variant", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Lower variant", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Lower or same variant", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Not equal variant"], "symbols": []}, {"mnemonic": "ASRD", "short_desc": "Arithmetic shift right for divide by immediate (predicated)", "syntax": ["ASRD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1RSB", "short_desc": "Load and broadcast signed byte to vector", "syntax": ["LD1RSB  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element variant", "LD1RSB  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element variant", "LD1RSB  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "MUL (by element)", "short_desc": "Multiply (vector, by element)", "full_desc": "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTPU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTPU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SETF8, SETF16", "short_desc": "Evaluation of 8 or 16 bit flag values", "full_desc": "Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8 bit value, and SETF16 treats the value as an 16 bit value.\n\nThe PSTATE.C flag is not affected by these instructions.", "syntax": ["SETF8  <Wn>\t; SETF8 variant", "SETF16  <Wn>\t; SETF16 variant"], "symbols": []}, {"mnemonic": "UQDECP (scalar)", "short_desc": "Unsigned saturating decrement scalar by count of true predicate elements", "syntax": ["UQDECP  <Wdn>, <Pm>.<T>\t; 32-bit variant", "UQDECP  <Xdn>, <Pm>.<T>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1RB", "short_desc": "Load and broadcast unsigned byte to vector", "syntax": ["LD1RB   { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 8-bit element variant", "LD1RB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element variant", "LD1RB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element variant", "LD1RB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SADDLV", "short_desc": "Signed Add Long across Vector", "full_desc": "Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LDFF1SB (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed bytes to vector (scalar index)", "syntax": ["LDFF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 16-bit element variant", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 32-bit element variant", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDFF1SB (vector plus immediate)", "short_desc": "Gather load first-fault signed bytes to vector (immediate index)", "syntax": ["LDFF1SB { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LSR (wide elements, unpredicated)", "short_desc": "Logical shift right by 64-bit wide elements (unpredicated)", "syntax": ["LSR     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "STUMINB, STUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory, without return", "full_desc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMINB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMINLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "CLS (vector)", "short_desc": "Count Leading Sign bits (vector)", "full_desc": "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CLS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "UMSUBL", "short_desc": "Unsigned Multiply-Subtract Long", "full_desc": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BTI", "short_desc": "Branch Target Identification", "full_desc": "Branch Target Identification. A BTI instruction is used to guard against the execution of instructions which are not the intended target of a branch.\n\nOutside of a guarded memory region, a BTI instruction executes as a NOP. Within a guarded memory region while PSTATE.BTYPE != 0b00, a BTI instruction compatible with the current value of PSTATE.BTYPE will not generate a Branch Target Exception and will allow execution of subsequent instructions within the memory region.\n\nThe operand <targets> passed to a BTI instruction determines the values of PSTATE.BTYPE which the BTI instruction is compatible with.", "syntax": ["BTI  {<targets>}\t; System variant"], "symbols": []}, {"mnemonic": "LDNT1W (scalar plus scalar)", "short_desc": "Contiguous load non-temporal words to vector (scalar index)", "syntax": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "CASB, CASAB, CASALB, CASLB", "short_desc": "Compare and Swap byte in memory", "full_desc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.", "syntax": ["CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASAB variant", "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASALB variant", "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASB variant", "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASLB variant"], "symbols": []}, {"mnemonic": "LDSETH, LDSETAH, LDSETALH, LDSETLH", "short_desc": "Atomic bit set on halfword in memory", "full_desc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSETAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETAH variant", "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETALH variant", "LDSETH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETH variant", "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETLH variant"], "symbols": []}, {"mnemonic": "SQSUB (vectors)", "short_desc": "Signed saturating subtract vectors (unpredicated)", "syntax": ["SQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UMLAL, UMLAL2 (vector)", "short_desc": "Unsigned Multiply-Add Long (vector)", "full_desc": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "AESD", "short_desc": "AES single round decryption", "full_desc": "AES single round decryption.", "syntax": ["AESD  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "STRH (register)", "short_desc": "Store Register Halfword (register)", "full_desc": "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant"], "symbols": []}, {"mnemonic": "REV (vector)", "short_desc": "Reverse all elements in a vector (unpredicated)", "syntax": ["REV     <Zd>.<T>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "EOR (shifted register)", "short_desc": "Bitwise Exclusive OR (shifted register)", "full_desc": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "MOV (scalar, unpredicated)", "short_desc": "Move general-purpose register to vector elements (unpredicated)", "syntax": ["MOV     <Zd>.<T>, <R><n|SP>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST4H (scalar plus immediate)", "short_desc": "Contiguous store four-halfword structures from four vectors (immediate index)", "syntax": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDFF1W (scalar plus vector)", "short_desc": "Gather load first-fault unsigned words to vector (vector index)", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "UMMLA", "short_desc": "Unsigned integer matrix multiply-accumulate", "syntax": ["UMMLA   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "ST3H (scalar plus scalar)", "short_desc": "Contiguous store three-halfword structures from three vectors (scalar index)", "syntax": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "RSUBHN, RSUBHN2", "short_desc": "Rounding Subtract returning High Narrow", "full_desc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SUBHN.\n\nThe RSUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LDRB (register)", "short_desc": "Load Register Byte (register)", "full_desc": "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register variant", "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register variant"], "symbols": []}, {"mnemonic": "FABS (scalar)", "short_desc": "Floating-point Absolute value (scalar)", "full_desc": "Floating-point Absolute value (scalar). This instruction calculates the absolute value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABS  <Hd>, <Hn>\t; Half-precision variant", "FABS  <Sd>, <Sn>\t; Single-precision variant", "FABS  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "STLURB", "short_desc": "Store-Release Register Byte (unscaled)", "full_desc": "Store-Release Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "STTRB", "short_desc": "Store Register Byte (unprivileged)", "full_desc": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "DECP (scalar)", "short_desc": "Decrement scalar by count of true predicate elements", "syntax": ["DECP    <Xdn>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDURSW", "short_desc": "Load Register Signed Word (unscaled)", "full_desc": "Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "BIC (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register)", "full_desc": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UADALP", "short_desc": "Unsigned Add and Accumulate Long Pairwise", "full_desc": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "RDFFR (unpredicated)", "short_desc": "Read the first-fault register", "syntax": ["RDFFR   <Pd>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "EXTR", "short_desc": "Extract register", "full_desc": "Extract register extracts a register from a pair of registers.", "syntax": ["EXTR  <Wd>, <Wn>, <Wm>, #<lsb>\t; 32-bit variant", "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1 (multiple structures)", "short_desc": "Load multiple single-element structures to one, two, three, or four registers", "full_desc": "Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1  { <Vt>.<T> }, [<Xn|SP>]\t; One register variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers variant", "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset variant", "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset variant", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset variant"], "symbols": []}, {"mnemonic": "STZ2G", "short_desc": "Store Allocation Tags, Zeroing", "full_desc": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.", "syntax": ["STZ2G  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index variant", "STZ2G  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "FRINTM (scalar)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTM  <Hd>, <Hn>\t; Half-precision variant", "FRINTM  <Sd>, <Sn>\t; Single-precision variant", "FRINTM  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "MOV (inverted wide immediate)", "short_desc": "Move (inverted wide immediate)", "full_desc": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit variant", "MOV  <Xd>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STZG", "short_desc": "Store Allocation Tag, Zeroing", "full_desc": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the associated data location. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.", "syntax": ["STZG  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index variant", "STZG  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "SQDMULH (by element)", "short_desc": "Signed saturating Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "XAFLAG", "short_desc": "Convert floating-point condition flags from external format to Arm format", "full_desc": "Convert floating-point condition flags from external format to Arm format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the result of an Arm floating-point scalar compare instruction.", "syntax": ["XAFLAG\t; System variant"], "symbols": []}, {"mnemonic": "SQINCD (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count", "syntax": ["SQINCD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LSL (wide elements, unpredicated)", "short_desc": "Logical shift left by 64-bit wide elements (unpredicated)", "syntax": ["LSL     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "BL", "short_desc": "Branch with Link", "full_desc": "Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call.", "syntax": ["BL  <label>\t; 26-bit signed PC-relative branch offset variant"], "symbols": []}, {"mnemonic": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", "short_desc": "CRC32C checksum", "full_desc": "In Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for all implementations to implement it.", "syntax": ["CRC32CB  <Wd>, <Wn>, <Wm>\t; CRC32CB variant", "CRC32CH  <Wd>, <Wn>, <Wm>\t; CRC32CH variant", "CRC32CW  <Wd>, <Wn>, <Wm>\t; CRC32CW variant", "CRC32CX  <Wd>, <Wn>, <Xm>\t; CRC32CX variant"], "symbols": []}, {"mnemonic": "SMLAL, SMLAL2 (vector)", "short_desc": "Signed Multiply-Add Long (vector)", "full_desc": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLAL instruction extracts each source vector from the lower half of each source register, while the SMLAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "SHL", "short_desc": "Shift Left (immediate)", "full_desc": "Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "LDRSW (register)", "short_desc": "Load Register Signed Word (register)", "full_desc": "Load Register Signed Word (register) calculates an address from a base register value and an offset register value, loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value can be shifted left by 0 or 2 bits. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FTMAD", "short_desc": "Floating-point trigonometric multiply-add coefficient", "syntax": ["FTMAD   <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nFor information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "SRSHR", "short_desc": "Signed Rounding Shift Right (immediate)", "full_desc": "Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "DECB, DECD, DECH, DECW (scalar)", "short_desc": "Decrement scalar by multiple of predicate constraint element count", "syntax": ["DECB    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Byte variant", "DECD    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Doubleword variant", "DECH    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Halfword variant", "DECW    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Word variant"], "symbols": []}, {"mnemonic": "LD1RQB (scalar plus scalar)", "short_desc": "Contiguous load and replicate sixteen bytes (scalar index)", "syntax": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNF1SW", "short_desc": "Contiguous load non-fault signed words to vector (immediate index)", "syntax": ["LDNF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDR (predicate)", "short_desc": "Load predicate register", "syntax": ["LDR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (vector, predicated)", "short_desc": "Move vector elements (predicated)", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory", "full_desc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMIN variant", "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINA variant", "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINAL variant", "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINL variant", "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMIN variant", "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINA variant", "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINAL variant", "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINL variant"], "symbols": []}, {"mnemonic": "STUMAXB, STUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory, without return", "full_desc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMAXLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "LDAPURSB", "short_desc": "Load-Acquire RCpc Register Signed Byte (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPURSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDAPURSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ADDHN, ADDHN2", "short_desc": "Add returning High Narrow", "full_desc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see RADDHN.\n\nThe ADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the ADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "STLXP", "short_desc": "Store-Release Exclusive Pair of registers", "full_desc": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQSUB (immediate)", "short_desc": "Signed saturating subtract immediate (unpredicated)", "syntax": ["SQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "SDIVR", "short_desc": "Signed reversed divide (predicated)", "syntax": ["SDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ISB", "short_desc": "Instruction Synchronization Barrier", "full_desc": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB).", "syntax": ["ISB  {<option>|#<imm>}\t; System variant"], "symbols": []}, {"mnemonic": "SWPB, SWPAB, SWPALB, SWPLB", "short_desc": "Swap byte in memory", "full_desc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWPAB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPAB variant", "SWPALB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPALB variant", "SWPB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPB variant", "SWPLB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPLB variant"], "symbols": []}, {"mnemonic": "LDPSW", "short_desc": "Load Pair of Registers Signed Word", "full_desc": "Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; Post-index variant", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; Pre-index variant", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "SHA1H", "short_desc": "SHA1 fixed rotate", "full_desc": "SHA1 fixed rotate.", "syntax": ["SHA1H  <Sd>, <Sn>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LD2B (scalar plus scalar)", "short_desc": "Contiguous load two-byte structures to two vectors (scalar index)", "syntax": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDRSB (register)", "short_desc": "Load Register Signed Byte (register)", "full_desc": "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 32-bit with extended register offset variant", "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 32-bit with shifted register offset variant", "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 64-bit with extended register offset variant", "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 64-bit with shifted register offset variant"], "symbols": []}, {"mnemonic": "FSUB (vectors, unpredicated)", "short_desc": "Floating-point subtract vectors (unpredicated)", "syntax": ["FSUB    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMULX", "short_desc": "Floating-point multiply-extended vectors (predicated)", "syntax": ["FMULX   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LASTA (scalar)", "short_desc": "Extract element after last to general-purpose register", "syntax": ["LASTA   <R><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SMOV", "short_desc": "Signed Move vector element to general-purpose register", "full_desc": "Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source SIMD&FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit variant", "SMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-reg,SMOV-64-reg variant"], "symbols": []}, {"mnemonic": "BFMLALT (indexed)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (top, indexed)", "syntax": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDAPRB", "short_desc": "Load-Acquire RCpc Register Byte", "full_desc": "Load-Acquire RCpc Register Byte derives an address from a base register value, loads a byte from the derived address in memory, zero-extends it and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPRB  <Wt>, [<Xn|SP> {,#0}]\t; Integer variant"], "symbols": []}, {"mnemonic": "NAND, NANDS", "short_desc": "Bitwise NAND predicates", "syntax": ["NAND    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "NANDS   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "FRINTZ (vector)", "short_desc": "Floating-point Round to Integral, toward Zero (vector)", "full_desc": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "MSR (register)", "short_desc": "Move general-purpose register to System Register", "full_desc": "Move general-purpose register to System Register allows the PE to write an AArch64 System register from a general-purpose register.", "syntax": ["MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "FADDP (scalar)", "short_desc": "Floating-point Add Pair of elements (scalar)", "full_desc": "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADDP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FADDP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDNT1B (scalar plus immediate)", "short_desc": "Contiguous load non-temporal bytes to vector (immediate index)", "syntax": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "NOT (vector)", "short_desc": "Bitwise invert vector (predicated)", "syntax": ["NOT     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "RORV", "short_desc": "Rotate Right Variable", "full_desc": "Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["RORV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "RORV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SSHR", "short_desc": "Signed Shift Right (immediate)", "full_desc": "Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQRDMLAH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "CASP, CASPA, CASPAL, CASPL", "short_desc": "Compare and Swap Pair of words or doublewords in memory", "full_desc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are restored to the values held in the registers before the instruction was executed.", "syntax": ["CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASP variant", "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPA variant", "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPAL variant", "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPL variant", "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASP variant", "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPA variant", "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPAL variant", "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPL variant"], "symbols": []}, {"mnemonic": "IRG", "short_desc": "Insert Random Tag", "full_desc": "Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register. Any tags specified in the optional second source register or in GCR_EL1.Exclude are excluded from the selection of the random Logical Address Tag.", "syntax": ["IRG  <Xd|SP>, <Xn|SP>{, <Xm>}\t; Integer variant"], "symbols": []}, {"mnemonic": "CMPP", "short_desc": "Compare with Tag", "full_desc": "Compare with Tag subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, updates the condition flags based on the result of the subtraction, and discards the result.", "syntax": ["CMPP  <Xn|SP>, <Xm|SP>\t; Integer variant"], "symbols": []}, {"mnemonic": "CMP<cc> (vectors)", "short_desc": "Compare vectors", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Equal variant", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than variant", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal variant", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Higher variant", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Higher or same variant", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Not equal variant"], "symbols": []}, {"mnemonic": "SQXTUN, SQXTUN2", "short_desc": "Signed saturating extract Unsigned Narrow", "full_desc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQXTUN  <Vb><d>, <Va><n>\t; Scalar variant", "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTNU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTNU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "STADD, STADDL", "short_desc": "Atomic add on word or doubleword in memory, without return", "full_desc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADD  <Ws>, [<Xn|SP>]\t; 32-bit LDADD alias variant", "STADDL  <Ws>, [<Xn|SP>]\t; 32-bit LDADDL alias variant", "STADD  <Xs>, [<Xn|SP>]\t; 64-bit LDADD alias variant", "STADDL  <Xs>, [<Xn|SP>]\t; 64-bit LDADDL alias variant"], "symbols": []}, {"mnemonic": "STSETH, STSETLH", "short_desc": "Atomic bit set on halfword in memory, without return", "full_desc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSETH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSETLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "SQDMLAL, SQDMLAL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Add Long", "full_desc": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts each source vector from the lower half of each source register, while the SQDMLAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "ST1H (scalar plus immediate)", "short_desc": "Contiguous store halfwords from vector (immediate index)", "syntax": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFH (scalar plus immediate)", "short_desc": "Contiguous prefetch halfwords (immediate index)", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "DC", "short_desc": "Data Cache operation", "full_desc": "Data Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions.", "syntax": ["DC  <dc_op>, <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "ST2 (multiple structures)", "short_desc": "Store multiple 2-element structures from two registers", "full_desc": "Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from two SIMD&FP registers to memory, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "FCMLA (indexed)", "short_desc": "Floating-point complex multiply-add by indexed values with rotate", "syntax": ["FCMLA   <Zda>.H, <Zn>.H, <Zm>.H[<imm>], <const>\t; Half-precision variant", "FCMLA   <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>\t; Single-precision variant"], "symbols": []}, {"mnemonic": "FABD", "short_desc": "Floating-point absolute difference (predicated)", "syntax": ["FABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FSUBR (vectors)", "short_desc": "Floating-point reversed subtract vectors (predicated)", "syntax": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "INDEX (scalars)", "short_desc": "Create index starting from and incremented by general-purpose register", "syntax": ["INDEX   <Zd>.<T>, <R><n>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "CMPLT (vectors)", "short_desc": "Compare signed less than vector, setting the condition flags", "syntax": ["CMPLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than variant"], "symbols": []}, {"mnemonic": "LDNF1H", "short_desc": "Contiguous load non-fault unsigned halfwords to vector (immediate index)", "syntax": ["LDNF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LDNF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LDNF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDNP", "short_desc": "Load Pair of Registers, with non-temporal hint", "full_desc": "Load Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers.\n\nFor information about memory accesses, see Load/Store addressing modes. For information about Non-temporal pair instructions, see Load/Store Non-temporal pair.", "syntax": ["LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SM4E", "short_desc": "SM4 Encode", "full_desc": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM4E  <Vd>.4S, <Vn>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LASTB (SIMD&FP scalar)", "short_desc": "Extract last element to SIMD&FP scalar register", "syntax": ["LASTB   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADC", "short_desc": "Add with Carry", "full_desc": "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register.", "syntax": ["ADC  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ADC  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CMP (immediate)", "short_desc": "Compare (immediate)", "full_desc": "Compare (immediate) subtracts an optionally-shifted immediate value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "CMP  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "YIELD", "short_desc": "YIELD", "full_desc": "YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.\n\nFor more information about the recommended use of this instruction, see The YIELD instruction.", "syntax": ["YIELD\t; System variant"], "symbols": []}, {"mnemonic": "FCVTZU", "short_desc": "Floating-point convert to unsigned integer, rounding toward zero (predicated)", "syntax": ["FCVTZU  <Zd>.H, <Pg>/M, <Zn>.H\t; Half-precision to 16-bit variant", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to 32-bit variant", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to 64-bit variant", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.S\t; Single-precision to 32-bit variant", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to 64-bit variant", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to 32-bit variant", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.D\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "STG", "short_desc": "Store Allocation Tag", "full_desc": "Store Allocation Tag stores an Allocation Tag to memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.", "syntax": ["STG  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index variant", "STG  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "CPY (immediate, merging)", "short_desc": "Copy signed integer immediate to vector elements (merging)", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "HLT", "short_desc": "Halt instruction", "full_desc": "Halt instruction. A HLTinstruction can generate a Halt Instruction debug event, which causes entry into Debug state.", "syntax": ["HLT  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "SUB (vector)", "short_desc": "Subtract (vector)", "full_desc": "Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "MOV (vector)", "short_desc": "Move vector", "full_desc": "Move vector. This instruction copies the vector in the source SIMD&FP register into the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<T>, <Vn>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "CMP (extended register)", "short_desc": "Compare (extended register)", "full_desc": "Compare (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "NEG (vector)", "short_desc": "Negate (vector)", "full_desc": "Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["NEG  <V><d>, <V><n>\t; Scalar variant", "NEG  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "STXRH", "short_desc": "Store Exclusive Register Halfword", "full_desc": "Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "LD1H (vector plus immediate)", "short_desc": "Gather load unsigned halfwords to vector (immediate index)", "syntax": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1H (scalar plus scalar)", "short_desc": "Contiguous load unsigned halfwords to vector (scalar index)", "syntax": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 16-bit element variant", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 32-bit element variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "BFDOT (vector)", "short_desc": "BFloat16 floating-point dot product (vector)", "full_desc": "BFloat16 floating-point dot product (vector). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Within each pair, the elements in the first source vector are multiplied by the corresponding elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the FPCR and does not update the FPSR exception status.", "syntax": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "CNOT", "short_desc": "Logically invert boolean condition in vector (predicated)", "syntax": ["CNOT    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRECPX", "short_desc": "Floating-point Reciprocal exponent (scalar)", "full_desc": "Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPX  <Hd>, <Hn>\t; Half-precision variant", "FRECPX  <V><d>, <V><n>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "CBNZ", "short_desc": "Compare and Branch on Nonzero", "full_desc": "Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.", "syntax": ["CBNZ  <Wt>, <label>\t; 32-bit variant", "CBNZ  <Xt>, <label>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "B", "short_desc": "Branch", "full_desc": "Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B  <label>\t; 26-bit signed PC-relative branch offset variant"], "symbols": []}, {"mnemonic": "ORR (shifted register)", "short_desc": "Bitwise OR (shifted register)", "full_desc": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQSUB (vectors)", "short_desc": "Unsigned saturating subtract vectors (unpredicated)", "syntax": ["UQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SABDL, SABDL2", "short_desc": "Signed Absolute Difference Long", "full_desc": "Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SABDL instruction writes the vector to the lower half of the destination register and clears the upper half, while the SABDL2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LSR (wide elements, predicated)", "short_desc": "Logical shift right by 64-bit wide elements (predicated)", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "FMIN (vector)", "short_desc": "Floating-point minimum (vector)", "full_desc": "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "CLS", "short_desc": "Count leading sign bits (predicated)", "syntax": ["CLS     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SABD", "short_desc": "Signed absolute difference (predicated)", "syntax": ["SABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1 (single structure)", "short_desc": "Store a single-element structure from one lane of one register", "full_desc": "Store a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&FP register to memory.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset variant", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset variant", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset variant", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset variant", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory", "full_desc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXAB variant", "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXALB variant", "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXB variant", "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXLB variant"], "symbols": []}, {"mnemonic": "FCVTL, FCVTL2", "short_desc": "Floating-point Convert to higher precision Long (vector)", "full_desc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&FP destination register.\n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 variant operates on the elements in the top 64 bits of the source register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "RAX1", "short_desc": "Rotate and Exclusive OR", "full_desc": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a source SIMD&FP register left by 1, performs a bitwise exclusive OR of the resulting 128-bit vector and the vector in another source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "CMGT (zero)", "short_desc": "Compare signed Greater than zero (vector)", "full_desc": "Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGT  <V><d>, <V><n>, #0\t; Scalar variant", "CMGT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": []}, {"mnemonic": "MUL", "short_desc": "Multiply", "syntax": ["MUL  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "MUL  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STCLRB, STCLRLB", "short_desc": "Atomic bit clear on byte in memory, without return", "full_desc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLRB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STCLRLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "UQDECH (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 16-bit predicate constraint element count", "syntax": ["UQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1SH (vector plus immediate)", "short_desc": "Gather load signed halfwords to vector (immediate index)", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1SH (scalar plus scalar)", "short_desc": "Contiguous load signed halfwords to vector (scalar index)", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 32-bit element variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "MLS (vector)", "short_desc": "Multiply-Subtract from accumulator (vector)", "full_desc": "Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SMINV", "short_desc": "Signed minimum reduction to scalar", "syntax": ["SMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINT64Z (scalar)", "short_desc": "Floating-point Round to 64-bit Integer toward Zero (scalar)", "full_desc": "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is not numerically equal to the {corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT64Z  <Sd>, <Sn>\t; Single-precision variant", "FRINT64Z  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "CMGE (register)", "short_desc": "Compare signed Greater than or Equal (vector)", "full_desc": "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGE  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "BIC (vector, register)", "short_desc": "Bitwise bit Clear (vector, register)", "full_desc": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "CFINV", "short_desc": "Invert Carry Flag", "full_desc": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.", "syntax": ["CFINV\t; System variant"], "symbols": []}, {"mnemonic": "PACGA", "short_desc": "Pointer Authentication Code, using Generic key", "full_desc": "Pointer Authentication Code, using Generic key. This instruction computes the pointer authentication code for an address in the first source register, using a modifier in the second source register, and the Generic key. The computed pointer authentication code is returned in the upper 32 bits of the destination register.", "syntax": ["PACGA  <Xd>, <Xn>, <Xm|SP>\t; Integer variant"], "symbols": []}, {"mnemonic": "LDRSH (immediate)", "short_desc": "Load Register Signed Halfword (immediate)", "full_desc": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSH  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "MOV (immediate, predicated, zeroing)", "short_desc": "Move signed integer immediate to vector elements (zeroing)", "syntax": ["MOV     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVT", "short_desc": "Floating-point convert precision (predicated)", "syntax": ["FCVT    <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to single-precision variant", "FCVT    <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to double-precision variant", "FCVT    <Zd>.H, <Pg>/M, <Zn>.S\t; Single-precision to half-precision variant", "FCVT    <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to double-precision variant", "FCVT    <Zd>.H, <Pg>/M, <Zn>.D\t; Double-precision to half-precision variant", "FCVT    <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to single-precision variant"], "symbols": []}, {"mnemonic": "FCSEL", "short_desc": "Floating-point Conditional Select (scalar)", "full_desc": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP destination register to take the value from either one or the other of two SIMD&FP source registers. If the condition passes, the first SIMD&FP source register value is taken, otherwise the second SIMD&FP source register value is taken.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCSEL  <Hd>, <Hn>, <Hm>, <cond>\t; Half-precision variant", "FCSEL  <Sd>, <Sn>, <Sm>, <cond>\t; Single-precision variant", "FCSEL  <Dd>, <Dn>, <Dm>, <cond>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "USDOT (indexed)", "short_desc": "Unsigned by signed integer indexed dot product", "syntax": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "CLASTB (SIMD&FP scalar)", "short_desc": "Conditionally extract last element to SIMD&FP scalar register", "syntax": ["CLASTB  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCMLT (vectors)", "short_desc": "Floating-point compare less than vector", "syntax": ["FCMLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than variant"], "symbols": []}, {"mnemonic": "FSUB (vectors, predicated)", "short_desc": "Floating-point subtract vectors (predicated)", "syntax": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SQSHRN, SQSHRN2", "short_desc": "Signed saturating Shift Right Narrow (immediate)", "full_desc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN.\n\nThe SQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "ADD (vectors, predicated)", "short_desc": "Add vectors (predicated)", "syntax": ["ADD     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STLXR", "short_desc": "Store-Release Exclusive Register", "full_desc": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PSB CSYNC", "short_desc": "Profiling Synchronization Barrier", "full_desc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following DSB instruction completes when the writes to the profiling buffer have completed.\n\nIf the Statistical Profiling Extension is not implemented, this instruction executes as a NOP.", "syntax": ["PSB CSYNC\t; System variant"], "symbols": []}, {"mnemonic": "MOV (predicate, predicated, zeroing)", "short_desc": "Move predicates (zeroing)", "syntax": ["MOV     <Pd>.B, <Pg>/Z, <Pn>.B\t; Not setting the condition flags variant"], "symbols": []}, {"mnemonic": "UADDW, UADDW2", "short_desc": "Unsigned Add Wide", "full_desc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.\n\nThe UADDW instruction extracts vector elements from the lower half of the second source register, while the UADDW2 instruction extracts vector elements from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LDAPURSW", "short_desc": "Load-Acquire RCpc Register Signed Word (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "CLASTA (scalar)", "short_desc": "Conditionally extract element after last to general-purpose register", "syntax": ["CLASTA  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UMULH", "short_desc": "Unsigned multiply returning high half (predicated)", "syntax": ["UMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STR (vector)", "short_desc": "Store vector register", "syntax": ["STR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "STEORB, STEORLB", "short_desc": "Atomic exclusive OR on byte in memory, without return", "full_desc": "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEORB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STEORLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "SQDECW (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count", "syntax": ["SQDECW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STP", "short_desc": "Store Pair of Registers", "full_desc": "Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ORR, ORRS (predicates)", "short_desc": "Bitwise inclusive OR predicate", "syntax": ["ORR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "ORRS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "FMUL (immediate)", "short_desc": "Floating-point multiply by immediate (predicated)", "syntax": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST2B (scalar plus immediate)", "short_desc": "Contiguous store two-byte structures from two vectors (immediate index)", "syntax": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDTRB", "short_desc": "Load Register Byte (unprivileged)", "full_desc": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "SM4EKEY", "short_desc": "SM4 Key", "full_desc": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP register and a 128-bit constant from the second SIMD&FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FMAXP (vector)", "short_desc": "Floating-point Maximum Pairwise (vector)", "full_desc": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SQDECP (scalar)", "short_desc": "Signed saturating decrement scalar by count of true predicate elements", "syntax": ["SQDECP  <Xdn>, <Pm>.<T>, <Wdn>\t; 32-bit variant", "SQDECP  <Xdn>, <Pm>.<T>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BFXIL", "short_desc": "Bitfield extract and insert at low end", "full_desc": "Bitfield Extract and Insert Low copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, leaving the other destination bits unchanged.", "syntax": ["BFXIL  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDAXRH", "short_desc": "Load-Acquire Exclusive Register Halfword", "full_desc": "Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "LDAPR", "short_desc": "Load-Acquire RCpc Register", "full_desc": "Load-Acquire RCpc Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from the derived address in memory, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPR  <Wt>, [<Xn|SP> {,#0}]\t; 32-bit variant", "LDAPR  <Xt>, [<Xn|SP> {,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SHLL, SHLL2", "short_desc": "Shift Left Long (by element size)", "full_desc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SHLL instruction extracts vector elements from the lower half of the source register, while the SHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "LSL (wide elements, predicated)", "short_desc": "Logical shift left by 64-bit wide elements (predicated)", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "PFIRST", "short_desc": "Set the first active predicate element to true", "syntax": ["PFIRST  <Pdn>.B, <Pg>, <Pdn>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "DUP (scalar)", "short_desc": "Broadcast general-purpose register to vector elements (unpredicated)", "syntax": ["DUP     <Zd>.<T>, <R><n|SP>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST4 (single structure)", "short_desc": "Store single 4-element structure from one lane of four registers", "full_desc": "Store single 4-element structure from one lane of four registers. This instruction stores a 4-element structure to memory from corresponding elements of four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset variant", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset variant", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset variant", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset variant", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "ST1B (scalar plus immediate)", "short_desc": "Contiguous store bytes from vector (immediate index)", "syntax": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDRB (immediate)", "short_desc": "Load Register Byte (immediate)", "full_desc": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "FMINNM (immediate)", "short_desc": "Floating-point minimum number with immediate (predicated)", "syntax": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "FNEG (vector)", "short_desc": "Floating-point Negate (vector)", "full_desc": "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNEG  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FNEG  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ORR (immediate)", "short_desc": "Bitwise OR (immediate)", "full_desc": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "ORR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FSUB (vector)", "short_desc": "Floating-point Subtract (vector)", "full_desc": "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UABD", "short_desc": "Unsigned Absolute Difference (vector)", "full_desc": "Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "MLS (by element)", "short_desc": "Multiply-Subtract from accumulator (vector, by element)", "full_desc": "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "LDNT1H (scalar plus immediate)", "short_desc": "Contiguous load non-temporal halfwords to vector (immediate index)", "syntax": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SQINCB", "short_desc": "Signed saturating increment scalar by multiple of 8-bit predicate constraint element count", "syntax": ["SQINCB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST2G", "short_desc": "Store Allocation Tags", "full_desc": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.", "syntax": ["ST2G  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index variant", "ST2G  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "UQDECD (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 64-bit predicate constraint element count", "syntax": ["UQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "ST4W (scalar plus scalar)", "short_desc": "Contiguous store four-word structures from four vectors (scalar index)", "syntax": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "SUB (extended register)", "short_desc": "Subtract (extended register)", "full_desc": "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD4D (scalar plus immediate)", "short_desc": "Contiguous load four-doubleword structures to four vectors (immediate index)", "syntax": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "BFM", "short_desc": "Bitfield Move", "full_desc": "Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits.\n\nIn both cases the other bits of the destination register remain unchanged.", "syntax": ["BFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "BFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CFP", "short_desc": "Control Flow Prediction Restriction by Context", "full_desc": "Control Flow Prediction Restriction by Context prevents control flow predictions that predict execution addresses, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels.\n\nFor more information, see CFP RCTX, Control Flow Prediction Restriction by Context.", "syntax": ["CFP  RCTX, <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "EOR3", "short_desc": "Three-way Exclusive OR", "full_desc": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FCVTZS (scalar, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTZS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTZS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTZS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTZS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTZS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "ST3W (scalar plus immediate)", "short_desc": "Contiguous store three-word structures from three vectors (immediate index)", "syntax": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "TST (immediate)", "short_desc": "Test bits (immediate)", "syntax": ["TST  <Wn>, #<imm>\t; 32-bit variant", "TST  <Xn>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CMGE (zero)", "short_desc": "Compare signed Greater than or Equal to zero (vector)", "full_desc": "Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGE  <V><d>, <V><n>, #0\t; Scalar variant", "CMGE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": []}, {"mnemonic": "LD3D (scalar plus scalar)", "short_desc": "Contiguous load three-doubleword structures to three vectors (scalar index)", "syntax": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "STRH (immediate)", "short_desc": "Store Register Halfword (immediate)", "full_desc": "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index variant", "STRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "FMAX (vectors)", "short_desc": "Floating-point maximum (predicated)", "syntax": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNF1B", "short_desc": "Contiguous load non-fault unsigned bytes to vector (immediate index)", "syntax": ["LDNF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 8-bit element variant", "LDNF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LDNF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LDNF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "ORN (vector)", "short_desc": "Bitwise inclusive OR NOT (vector)", "full_desc": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "UQADD (vectors)", "short_desc": "Unsigned saturating add vectors (unpredicated)", "syntax": ["UQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMAXNM (immediate)", "short_desc": "Floating-point maximum number with immediate (predicated)", "syntax": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LSRR", "short_desc": "Reversed logical shift right by vector (predicated)", "syntax": ["LSRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LSR (register)", "short_desc": "Logical Shift Right (register)", "full_desc": "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SDOT (vectors)", "short_desc": "Signed integer dot product", "syntax": ["SDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINTP (vector)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTP  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTP  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "BFDOT (by element)", "short_desc": "BFloat16 floating-point dot product (vector, by element)", "full_desc": "BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Each pair of elements in the first source vector is multiplied by the specified pair of elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the FPCR and does not update the FPSR exception status.\n\nThe BF16 pair within the second source vector is specified using an immediate index. The index range is from 0 to 3 inclusive. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.", "syntax": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "FADD (scalar)", "short_desc": "Floating-point Add (scalar)", "full_desc": "Floating-point Add (scalar). This instruction adds the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADD  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FADD  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FADD  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "PRFB (scalar plus immediate)", "short_desc": "Contiguous prefetch bytes (immediate index)", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "BRKPB, BRKPBS", "short_desc": "Break before first true condition, propagating from previous partition", "syntax": ["BRKPB   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "BRKPBS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "LD1ROD (scalar plus scalar)", "short_desc": "Contiguous load and replicate four doublewords (scalar index)", "syntax": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "FCMP", "short_desc": "Floating-point quiet Compare (scalar)", "full_desc": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nIt raises an Invalid Operation exception only if either operand is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMP  <Hn>, <Hm>\t; Half-precision variant", "FCMP  <Hn>, #0.0\t; Half-precision, zero variant", "FCMP  <Sn>, <Sm>\t; Single-precision variant", "FCMP  <Sn>, #0.0\t; Single-precision, zero variant", "FCMP  <Dn>, <Dm>\t; Double-precision variant", "FCMP  <Dn>, #0.0\t; Double-precision, zero variant"], "symbols": []}, {"mnemonic": "UADDV", "short_desc": "Unsigned add reduction to scalar", "syntax": ["UADDV   <Dd>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1RQH (scalar plus scalar)", "short_desc": "Contiguous load and replicate eight halfwords (scalar index)", "syntax": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "INSR (SIMD&FP scalar)", "short_desc": "Insert SIMD&FP scalar register in shifted vector", "syntax": ["INSR    <Zdn>.<T>, <V><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDEOR, LDEORA, LDEORAL, LDEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory", "full_desc": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEOR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEOR variant", "LDEORA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORA variant", "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORAL variant", "LDEORL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORL variant", "LDEOR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEOR variant", "LDEORA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORA variant", "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORAL variant", "LDEORL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORL variant"], "symbols": []}, {"mnemonic": "TLBI", "short_desc": "TLB Invalidate operation", "full_desc": "TLB Invalidate operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions.", "syntax": ["TLBI  <tlbi_op>{, <Xt>}\t; System variant"], "symbols": []}, {"mnemonic": "STUMIN, STUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMIN  <Ws>, [<Xn|SP>]\t; 32-bit LDUMIN alias variant", "STUMINL  <Ws>, [<Xn|SP>]\t; 32-bit LDUMINL alias variant", "STUMIN  <Xs>, [<Xn|SP>]\t; 64-bit LDUMIN alias variant", "STUMINL  <Xs>, [<Xn|SP>]\t; 64-bit LDUMINL alias variant"], "symbols": []}, {"mnemonic": "LD3 (single structure)", "short_desc": "Load single 3-element structure to one lane of three registers)", "full_desc": "Load single 3-element structure to one lane of three registers). This instruction loads a 3-element structure from memory and writes the result to the corresponding elements of the three SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset variant", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset variant", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset variant", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset variant", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "ORR (vector, register)", "short_desc": "Bitwise inclusive OR (vector, register)", "full_desc": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "CNTB, CNTD, CNTH, CNTW", "short_desc": "Set scalar to multiple of predicate constraint element count", "syntax": ["CNTB    <Xd>{, <pattern>{, MUL #<imm>}}\t; Byte variant", "CNTD    <Xd>{, <pattern>{, MUL #<imm>}}\t; Doubleword variant", "CNTH    <Xd>{, <pattern>{, MUL #<imm>}}\t; Halfword variant", "CNTW    <Xd>{, <pattern>{, MUL #<imm>}}\t; Word variant"], "symbols": []}, {"mnemonic": "ASR (wide elements, predicated)", "short_desc": "Arithmetic shift right by 64-bit wide elements (predicated)", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "ADDVL", "short_desc": "Add multiple of vector register size to scalar register", "syntax": ["ADDVL   <Xd|SP>, <Xn|SP>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOVI", "short_desc": "Move Immediate (vector)", "full_desc": "Move Immediate (vector). This instruction places an immediate constant into every vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOVI  <Vd>.<T>, #<imm8>{, LSL #0}\t; 8-bit variant", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate variant", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate variant", "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones variant", "MOVI  <Dd>, #<imm>\t; 64-bit scalar variant", "MOVI  <Vd>.2D, #<imm>\t; 64-bit vector variant"], "symbols": []}, {"mnemonic": "FCMLE (vectors)", "short_desc": "Floating-point compare less than or equal to vector", "syntax": ["FCMLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal variant"], "symbols": []}, {"mnemonic": "SEL (predicates)", "short_desc": "Conditionally select elements from two predicates", "syntax": ["SEL     <Pd>.B, <Pg>, <Pn>.B, <Pm>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFM (literal)", "short_desc": "Prefetch Memory (literal)", "full_desc": "Prefetch Memory (literal) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), <label>\t; Literal variant"], "symbols": []}, {"mnemonic": "FRINTA (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTA  <Hd>, <Hn>\t; Half-precision variant", "FRINTA  <Sd>, <Sn>\t; Single-precision variant", "FRINTA  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "FTSMUL", "short_desc": "Floating-point trigonometric starting value", "syntax": ["FTSMUL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDTRSH", "short_desc": "Load Register Signed Halfword (unprivileged)", "full_desc": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMADD", "short_desc": "Floating-point fused Multiply-Add (scalar)", "full_desc": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "CSDB", "short_desc": "Consumption of Speculative Data Barrier", "full_desc": "Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value prediction.\n\nNo instruction other than branch instructions appearing in program order after the CSDB can be speculatively executed using the results of any:", "syntax": ["CSDB\t; System variant"], "symbols": []}, {"mnemonic": "UXTL, UXTL2", "short_desc": "Unsigned extend Long", "full_desc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe UXTL instruction extracts vector elements from the lower half of the source register, while the UXTL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "STURB", "short_desc": "Store Register Byte (unscaled)", "full_desc": "Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "FMINNMP (scalar)", "short_desc": "Floating-point Minimum Number of Pair of elements (scalar)", "full_desc": "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory", "full_desc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXAH variant", "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXALH variant", "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXH variant", "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXLH variant"], "symbols": []}, {"mnemonic": "LD2H (scalar plus scalar)", "short_desc": "Contiguous load two-halfword structures to two vectors (scalar index)", "syntax": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "FADDV", "short_desc": "Floating-point add recursive reduction to scalar", "syntax": ["FADDV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADD (immediate)", "short_desc": "Add (immediate)", "full_desc": "Add (immediate) adds a register value and an optionally-shifted immediate value, and writes the result to the destination register.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ZIP1, ZIP2 (vectors)", "short_desc": "Interleave elements from two half vectors", "syntax": ["ZIP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; High halves variant", "ZIP2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; High halves (quadwords) variant", "ZIP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Low halves variant", "ZIP1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Low halves (quadwords) variant"], "symbols": []}, {"mnemonic": "LD1D (scalar plus vector)", "short_desc": "Gather load doublewords to vector (vector index)", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset variant", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset variant", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "STGM", "short_desc": "Store Tag Multiple", "full_desc": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and the Allocation Tag written to address A is taken from the source register at 4*A<7:4>+3:4*A<7:4>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "syntax": ["STGM  <Xt>, [<Xn|SP>]\t; Integer variant"], "symbols": []}, {"mnemonic": "STNT1D (scalar plus scalar)", "short_desc": "Contiguous store non-temporal doublewords from vector (scalar index)", "syntax": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (vector, unpredicated)", "short_desc": "Move vector register (unpredicated)", "syntax": ["MOV     <Zd>.D, <Zn>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "ADRP", "short_desc": "Form PC-relative address to 4KB page", "full_desc": "Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.", "syntax": ["ADRP  <Xd>, <label>\t; Literal variant"], "symbols": []}, {"mnemonic": "FNMLS", "short_desc": "Floating-point negated fused multiply-subtract vectors (predicated), writing addend [Zda = -Zda + Zn * Zm]", "syntax": ["FNMLS   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTMU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTMU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTMU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTMU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTMU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTMU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "FMOV (zero, predicated)", "short_desc": "Move floating-point +0.0 to vector elements (predicated)", "syntax": ["FMOV    <Zd>.<T>, <Pg>/M, #0.0\t; SVE variant"], "symbols": []}, {"mnemonic": "STUMAX, STUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAX  <Ws>, [<Xn|SP>]\t; 32-bit LDUMAX alias variant", "STUMAXL  <Ws>, [<Xn|SP>]\t; 32-bit LDUMAXL alias variant", "STUMAX  <Xs>, [<Xn|SP>]\t; 64-bit LDUMAX alias variant", "STUMAXL  <Xs>, [<Xn|SP>]\t; 64-bit LDUMAXL alias variant"], "symbols": []}, {"mnemonic": "ORR (vectors, unpredicated)", "short_desc": "Bitwise inclusive OR vectors (unpredicated)", "syntax": ["ORR     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "SQADD (immediate)", "short_desc": "Signed saturating add immediate (unpredicated)", "syntax": ["SQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "CNEG", "short_desc": "Conditional Negate", "full_desc": "Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CNEG  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CNEG  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1SW (scalar plus vector)", "short_desc": "Gather load signed words to vector (vector index)", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "SHA256H", "short_desc": "SHA256 hash update (part 1)", "full_desc": "SHA256 hash update (part 1).", "syntax": ["SHA256H  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FMINNMP (vector)", "short_desc": "Floating-point Minimum Number Pairwise (vector)", "full_desc": "Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LD1ROW (scalar plus scalar)", "short_desc": "Contiguous load and replicate eight words (scalar index)", "syntax": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "UQINCP (vector)", "short_desc": "Unsigned saturating increment vector by count of true predicate elements", "syntax": ["UQINCP  <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "PTRUE, PTRUES", "short_desc": "Initialise predicate from named constraint", "syntax": ["PTRUE   <Pd>.<T>{, <pattern>}\t; Not setting the condition flags variant", "PTRUES  <Pd>.<T>{, <pattern>}\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "STSMINH, STSMINLH", "short_desc": "Atomic signed minimum on halfword in memory, without return", "full_desc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMINH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMINLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "ADD (extended register)", "short_desc": "Add (extended register)", "full_desc": "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STR (immediate)", "short_desc": "Store Register (immediate)", "full_desc": "Store Register (immediate) stores a word or a doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "STR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "STR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMLAL, SMLAL2 (by element)", "short_desc": "Signed Multiply-Add Long (vector, by element)", "full_desc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.\n\nThe SMLAL instruction extracts vector elements from the lower half of the first source register, while the SMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SQXTN, SQXTN2", "short_desc": "Signed saturating extract Narrow", "full_desc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQXTN  <Vb><d>, <Va><n>\t; Scalar variant", "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": []}, {"mnemonic": "SHSUB", "short_desc": "Signed Halving Subtract", "full_desc": "Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "STLUR", "short_desc": "Store-Release Register (unscaled)", "full_desc": "Store-Release Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STLUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQDMULH (vector)", "short_desc": "Signed saturating Doubling Multiply returning High half", "full_desc": "Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "AND (vectors, predicated)", "short_desc": "Bitwise AND vectors (predicated)", "syntax": ["AND     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SHA512SU1", "short_desc": "SHA512 Schedule Update 1", "full_desc": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SQINCH (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count", "syntax": ["SQINCH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STLRB", "short_desc": "Store-Release Register Byte", "full_desc": "Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "ST2H (scalar plus immediate)", "short_desc": "Contiguous store two-halfword structures from two vectors (immediate index)", "syntax": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "USHLL, USHLL2", "short_desc": "Unsigned Shift Left Long (immediate)", "full_desc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe USHLL instruction extracts vector elements from the lower half of the source register, while the USHLL2 instruction extracts vector elements from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "BRK", "short_desc": "Breakpoint instruction", "full_desc": "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction exception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and captures the value of the immediate argument in ESR_ELx.ISS.", "syntax": ["BRK  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "LD1W (scalar plus vector)", "short_desc": "Gather load unsigned words to vector (vector index)", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "PSSBB", "short_desc": "Physical Speculative Store Bypass Barrier", "full_desc": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same physical address.\n\nThe semantics of the Physical Speculative Store Bypass Barrier are:", "syntax": ["PSSBB\t; System variant"], "symbols": []}, {"mnemonic": "SUBHN, SUBHN2", "short_desc": "Subtract returning High Narrow", "full_desc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nThe results are truncated. For rounded results, see RSUBHN.\n\nThe SUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "STNT1W (scalar plus scalar)", "short_desc": "Contiguous store non-temporal words from vector (scalar index)", "syntax": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFM (immediate)", "short_desc": "Prefetch Memory (immediate)", "full_desc": "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more information, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "UMAX", "short_desc": "Unsigned Maximum (vector)", "full_desc": "Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FRECPE", "short_desc": "Floating-point reciprocal estimate (unpredicated)", "syntax": ["FRECPE  <Zd>.<T>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "INCP (vector)", "short_desc": "Increment vector by count of true predicate elements", "syntax": ["INCP    <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUQADD", "short_desc": "Signed saturating Accumulate of Unsigned value", "full_desc": "Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SUQADD  <V><d>, <V><n>\t; Scalar variant", "SUQADD  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "STRB (register)", "short_desc": "Store Register Byte (register)", "full_desc": "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register variant", "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register variant"], "symbols": []}, {"mnemonic": "USMMLA", "short_desc": "Unsigned by signed integer matrix multiply-accumulate", "syntax": ["USMMLA  <Zda>.S, <Zn>.B, <Zm>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "IC", "short_desc": "Instruction Cache operation", "full_desc": "Instruction Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions.", "syntax": ["IC  <ic_op>{, <Xt>}\t; System variant"], "symbols": []}, {"mnemonic": "UMMLA (vector)", "short_desc": "Unsigned 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector variant"], "symbols": []}, {"mnemonic": "BFMLALB (vectors)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (bottom)", "syntax": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1B (scalar plus scalar)", "short_desc": "Contiguous load unsigned bytes to vector (scalar index)", "syntax": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 8-bit element variant", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 16-bit element variant", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 32-bit element variant", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1B (vector plus immediate)", "short_desc": "Gather load unsigned bytes to vector (immediate index)", "syntax": ["LD1B    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LD1B    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SUB (immediate)", "short_desc": "Subtract (immediate)", "full_desc": "Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "URHADD", "short_desc": "Unsigned Rounding Halving Add", "full_desc": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see UHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FCMLE (zero)", "short_desc": "Floating-point Compare Less than or Equal to zero (vector)", "full_desc": "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLE  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMLE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LD1SB (scalar plus scalar)", "short_desc": "Contiguous load signed bytes to vector (scalar index)", "syntax": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 16-bit element variant", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 32-bit element variant", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1SB (vector plus immediate)", "short_desc": "Gather load signed bytes to vector (immediate index)", "syntax": ["LD1SB   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "USUBL, USUBL2", "short_desc": "Unsigned Subtract Long", "full_desc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.\n\nThe USUBL instruction extracts each source vector from the lower half of each source register, while the USUBL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LD2R", "short_desc": "Load single 2-element structure and Replicate to all lanes of two registers", "full_desc": "Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "FMAXP (scalar)", "short_desc": "Floating-point Maximum of Pair of elements (scalar)", "full_desc": "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SUBR (vectors)", "short_desc": "Reversed subtract vectors (predicated)", "syntax": ["SUBR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SABA", "short_desc": "Signed Absolute difference and Accumulate", "full_desc": "Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SADDLP", "short_desc": "Signed Add Long Pairwise", "full_desc": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "SB", "short_desc": "Speculation Barrier", "full_desc": "Speculation Barrier is a barrier that controls speculation.\n\nThe semantics of the Speculation Barrier are that the execution, until the barrier completes, of any instruction that appears later in the program order than the barrier:\n\nIn particular, any instruction that appears later in the program order than the barrier cannot cause a speculative allocation into any caching structure where the allocation of that entry could be indicative of any data value present in memory or in the registers.\n\nThe SB instruction:\n\nWhen the prediction of the instruction stream is not informed by data taken from the register outputs of the speculative execution of instructions appearing in program order after an uncompleted SB instruction, the SB instruction has no effect on the use of prediction resources to predict the instruction stream that is being fetched.", "syntax": ["SB\t; System variant"], "symbols": []}, {"mnemonic": "FADD (vectors, unpredicated)", "short_desc": "Floating-point add vector (unpredicated)", "syntax": ["FADD    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRECPS", "short_desc": "Floating-point reciprocal step (unpredicated)", "syntax": ["FRECPS  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTPS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTPS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UQADD", "short_desc": "Unsigned saturating Add", "full_desc": "Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQRSHL", "short_desc": "Signed saturating Rounding Shift Left (register)", "full_desc": "Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see SQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "CMPLE (vectors)", "short_desc": "Compare signed less than or equal to vector, setting the condition flags", "syntax": ["CMPLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal variant"], "symbols": []}, {"mnemonic": "FMAXNMV", "short_desc": "Floating-point Maximum Number across Vector", "full_desc": "Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SQDMLAL, SQDMLAL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Add Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts vector elements from the lower half of the first source register, while the SQDMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "ST4D (scalar plus scalar)", "short_desc": "Contiguous store four-doubleword structures from four vectors (scalar index)", "syntax": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "CNTP", "short_desc": "Set scalar to count of true predicate elements", "syntax": ["CNTP    <Xd>, <Pg>, <Pn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDRH (register)", "short_desc": "Load Register Halfword (register)", "full_desc": "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant"], "symbols": []}, {"mnemonic": "SXTB, SXTH, SXTW", "short_desc": "Signed byte / halfword / word extend (predicated)", "syntax": ["SXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte variant", "SXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword variant", "SXTW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word variant"], "symbols": []}, {"mnemonic": "LD4W (scalar plus immediate)", "short_desc": "Contiguous load four-word structures to four vectors (immediate index)", "syntax": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINT32X (scalar)", "short_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar)", "full_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT32X  <Sd>, <Sn>\t; Single-precision variant", "FRINT32X  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "UQINCW (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 32-bit predicate constraint element count", "syntax": ["UQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "SQRDMLAH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SMAX (vectors)", "short_desc": "Signed maximum vectors (predicated)", "syntax": ["SMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST3D (scalar plus immediate)", "short_desc": "Contiguous store three-doubleword structures from three vectors (immediate index)", "syntax": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD3W (scalar plus scalar)", "short_desc": "Contiguous load three-word structures to three vectors (scalar index)", "syntax": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDADDB, LDADDAB, LDADDALB, LDADDLB", "short_desc": "Atomic add on byte in memory", "full_desc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADDAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDAB variant", "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDALB variant", "LDADDB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDB variant", "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDLB variant"], "symbols": []}, {"mnemonic": "STADDB, STADDLB", "short_desc": "Atomic add on byte in memory, without return", "full_desc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADDB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STADDLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "FCVTNS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTNS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "DUP (indexed)", "short_desc": "Broadcast indexed element to vector (unpredicated)", "syntax": ["DUP     <Zd>.<T>, <Zn>.<T>[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "SADDW, SADDW2", "short_desc": "Signed Add Wide", "full_desc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.\n\nThe SADDW instruction extracts the second source vector from the lower half of the second source register, while the SADDW2 instruction extracts the second source vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "ADDPL", "short_desc": "Add multiple of predicate register size to scalar register", "syntax": ["ADDPL   <Xd|SP>, <Xn|SP>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "SBFIZ", "short_desc": "Signed Bitfield Insert in Zero", "full_desc": "Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, setting the destination bits below the bitfield to zero, and the bits above the bitfield to a copy of the most significant bit of the bitfield.", "syntax": ["SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STR (register)", "short_desc": "Store Register (register)", "full_desc": "Store Register (register) calculates an address from a base register value and an offset register value, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMMLA (vector)", "short_desc": "Signed 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector variant"], "symbols": []}, {"mnemonic": "TBL", "short_desc": "Table vector Lookup", "full_desc": "Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table variant", "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table variant"], "symbols": []}, {"mnemonic": "LD1ROB (scalar plus immediate)", "short_desc": "Contiguous load and replicate thirty-two bytes (immediate index)", "syntax": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "STR (predicate)", "short_desc": "Store predicate register", "syntax": ["STR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDRSW (literal)", "short_desc": "Load Register Signed Word (literal)", "full_desc": "Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, <label>\t; Literal variant"], "symbols": []}, {"mnemonic": "MOV (SIMD&FP scalar, unpredicated)", "short_desc": "Move indexed element or SIMD&FP scalar to vector (unpredicated)", "syntax": ["MOV     <Zd>.<T>, <V><n>\t;  variant", "MOV     <Zd>.<T>, <Zn>.<T>[<imm>]\t;  variant", "\t;  variant", "\t;  variant"], "symbols": []}, {"mnemonic": "RBIT (vector)", "short_desc": "Reverse Bit order (vector)", "full_desc": "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RBIT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "STR (register, SIMD&FP)", "short_desc": "Store SIMD&FP register (register offset)", "full_desc": "Store SIMD&FP register (register offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-fsreg,STR-8-fsreg variant", "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-fsreg,STR-8-fsreg variant", "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-fsreg,STR-16-fsreg variant", "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-fsreg,STR-32-fsreg variant", "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-fsreg,STR-64-fsreg variant", "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-fsreg,STR-128-fsreg variant"], "symbols": []}, {"mnemonic": "ORN (shifted register)", "short_desc": "Bitwise OR NOT (shifted register)", "full_desc": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "NEG", "short_desc": "Negate (predicated)", "syntax": ["NEG     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MUL (vector)", "short_desc": "Multiply (vector)", "full_desc": "Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "ST3 (multiple structures)", "short_desc": "Store multiple 3-element structures from three registers", "full_desc": "Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to memory from three SIMD&FP registers, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "STNT1B (scalar plus immediate)", "short_desc": "Contiguous store non-temporal bytes from vector (immediate index)", "syntax": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDRSH (register)", "short_desc": "Load Register Signed Halfword (register)", "full_desc": "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FCVTMS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTMS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTMS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTMS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTMS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTMS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "LDR (literal)", "short_desc": "Load Register (literal)", "full_desc": "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDR  <Wt>, <label>\t; 32-bit variant", "LDR  <Xt>, <label>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BRKA, BRKAS", "short_desc": "Break after first true condition", "syntax": ["BRKA    <Pd>.B, <Pg>/<ZM>, <Pn>.B\t; Not setting the condition flags variant", "BRKAS   <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "BIC (vector, immediate)", "short_desc": "Bitwise bit Clear (vector, immediate)", "full_desc": "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit variant", "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit variant"], "symbols": []}, {"mnemonic": "UQINCH (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 16-bit predicate constraint element count", "syntax": ["UQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "FCMGT (register)", "short_desc": "Floating-point Compare Greater than (vector)", "full_desc": "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FMAXNM (scalar)", "short_desc": "Floating-point Maximum Number (scalar)", "full_desc": "Floating-point Maximum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the larger of the two floating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNM  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMAXNM  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMAXNM  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SUB (vectors, predicated)", "short_desc": "Subtract vectors (predicated)", "syntax": ["SUB     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FADD (vectors, predicated)", "short_desc": "Floating-point add vector (predicated)", "syntax": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (to/from SP)", "short_desc": "Move between register and stack pointer", "syntax": ["MOV  <Wd|WSP>, <Wn|WSP>\t; 32-bit variant", "MOV  <Xd|SP>, <Xn|SP>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FEXPA", "short_desc": "Floating-point exponential accelerator", "syntax": ["FEXPA   <Zd>.<T>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADDS (shifted register)", "short_desc": "Add (shifted register), setting flags", "full_desc": "Add (shifted register), setting flags, adds a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "NOT", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["NOT  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "MNEG", "short_desc": "Multiply-Negate", "full_desc": "Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register.", "syntax": ["MNEG  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "MNEG  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STLXRH", "short_desc": "Store-Release Exclusive Register Halfword", "full_desc": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "CMLE (zero)", "short_desc": "Compare signed Less than or Equal to zero (vector)", "full_desc": "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMLE  <V><d>, <V><n>, #0\t; Scalar variant", "CMLE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": []}, {"mnemonic": "UABDL, UABDL2", "short_desc": "Unsigned Absolute Difference Long", "full_desc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UABDL instruction extracts each source vector from the lower half of each source register, while the UABDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "WFE", "short_desc": "Wait For Event", "full_desc": "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event.\n\nAs described in Wait For Event mechanism and Send event, the execution of a WFE instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See:", "syntax": ["WFE\t; System variant"], "symbols": []}, {"mnemonic": "UMAXV", "short_desc": "Unsigned maximum reduction to scalar", "syntax": ["UMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUB (shifted register)", "short_desc": "Subtract (shifted register)", "full_desc": "Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST1D (vector plus immediate)", "short_desc": "Scatter store doublewords from a vector (immediate index)", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1D (scalar plus scalar)", "short_desc": "Contiguous store doublewords from vector (scalar index)", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1W (scalar plus immediate)", "short_desc": "Contiguous load unsigned words to vector (immediate index)", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "GMI", "short_desc": "Tag Mask Insert", "full_desc": "Tag Mask Insert inserts the tag in the first source register into the excluded set specified in the second source register, writing the new excluded set to the destination register.", "syntax": ["GMI  <Xd>, <Xn|SP>, <Xm>\t; Integer variant"], "symbols": []}, {"mnemonic": "SABD", "short_desc": "Signed Absolute Difference", "full_desc": "Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LD4 (multiple structures)", "short_desc": "Load multiple 4-element structures to four registers", "full_desc": "Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "TRN1, TRN2 (predicates)", "short_desc": "Interleave even or odd elements from two predicates", "syntax": ["TRN1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Even variant", "TRN2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Odd variant"], "symbols": []}, {"mnemonic": "SUBG", "short_desc": "Subtract with Tag", "full_desc": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.", "syntax": ["SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>\t; Integer variant"], "symbols": []}, {"mnemonic": "LDURB", "short_desc": "Load Register Byte (unscaled)", "full_desc": "Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "STNP", "short_desc": "Store Pair of Registers, with non-temporal hint", "full_desc": "Store Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes. For information about Non-temporal pair instructions, see Load/Store Non-temporal pair.", "syntax": ["STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "REV64", "short_desc": "Reverse elements in 64-bit doublewords (vector)", "full_desc": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV64  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SUBP", "short_desc": "Subtract Pointer", "full_desc": "Subtract Pointer subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register.", "syntax": ["SUBP  <Xd>, <Xn|SP>, <Xm|SP>\t; Integer variant"], "symbols": []}, {"mnemonic": "LD3B (scalar plus immediate)", "short_desc": "Contiguous load three-byte structures to three vectors (immediate index)", "syntax": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "DGH", "short_desc": "Data Gathering Hint", "full_desc": "DGH is a hint instruction. A DGH instruction is not expected to be performance optimal to merge memory accesses with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect.", "syntax": ["DGH\t; System variant"], "symbols": []}, {"mnemonic": "FCCMPE", "short_desc": "Floating-point Conditional signaling Compare (scalar)", "full_desc": "Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision variant", "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision variant", "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SQINCW (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count", "syntax": ["SQINCW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "RBIT", "short_desc": "Reverse bits (predicated)", "syntax": ["RBIT    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UDIV", "short_desc": "Unsigned divide (predicated)", "syntax": ["UDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDLARB", "short_desc": "Load LOAcquire Register Byte", "full_desc": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FMAXV", "short_desc": "Floating-point maximum recursive reduction to scalar", "syntax": ["FMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", "short_desc": "Atomic bit clear on byte in memory", "full_desc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRAB variant", "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRALB variant", "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRB variant", "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRLB variant"], "symbols": []}, {"mnemonic": "FCVTZS (scalar, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit variant", "FCVTZS  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit variant", "FCVTZS  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit variant", "FCVTZS  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit variant", "FCVTZS  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit variant", "FCVTZS  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "PTEST", "short_desc": "Set condition flags for predicate", "syntax": ["PTEST   <Pg>, <Pn>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "LD4B (scalar plus scalar)", "short_desc": "Contiguous load four-byte structures to four vectors (scalar index)", "syntax": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFD (scalar plus scalar)", "short_desc": "Contiguous prefetch doublewords (scalar index)", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFD (vector plus immediate)", "short_desc": "Gather prefetch doublewords (vector plus immediate)", "syntax": ["PRFD    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "PRFD    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "UDOT (vectors)", "short_desc": "Unsigned integer dot product", "syntax": ["UDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>\t; SVE variant"], "symbols": []}, {"mnemonic": "BFCVT", "short_desc": "Floating-point down convert to BFloat16 format (predicated)", "syntax": ["BFCVT   <Zd>.H, <Pg>/M, <Zn>.S\t; SVE variant"], "symbols": []}, {"mnemonic": "RADDHN, RADDHN2", "short_desc": "Rounding Add returning High Narrow", "full_desc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see ADDHN.\n\nThe RADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "STSMAXH, STSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory, without return", "full_desc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMAXLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "ADDS (immediate)", "short_desc": "Add (immediate), setting flags", "full_desc": "Add (immediate), setting flags, adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1SW (scalar plus immediate)", "short_desc": "Contiguous load signed words to vector (immediate index)", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MUL (immediate)", "short_desc": "Multiply by immediate (unpredicated)", "syntax": ["MUL     <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "SQADD (vectors)", "short_desc": "Signed saturating add vectors (unpredicated)", "syntax": ["SQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UMLAL, UMLAL2 (by element)", "short_desc": "Unsigned Multiply-Add Long (vector, by element)", "full_desc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "CMP (shifted register)", "short_desc": "Compare (shifted register)", "full_desc": "Compare (shifted register) subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "CMP  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ORR (immediate)", "short_desc": "Bitwise inclusive OR with immediate (unpredicated)", "syntax": ["ORR     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADDS (extended register)", "short_desc": "Add (extended register), setting flags", "full_desc": "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", "short_desc": "Atomic signed minimum on halfword in memory", "full_desc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINAH variant", "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINALH variant", "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINH variant", "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINLH variant"], "symbols": []}, {"mnemonic": "SHA256SU1", "short_desc": "SHA256 schedule update 1", "full_desc": "SHA256 schedule update 1.", "syntax": ["SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SQDECD (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count", "syntax": ["SQDECD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "SQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FJCVTZS", "short_desc": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero", "full_desc": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. This instruction converts the double-precision floating-point value in the SIMD&FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too large to be accommodated as a signed 32-bit integer, then the result is the integer modulo 232, as held in a 32-bit signed integer.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FJCVTZS  <Wd>, <Dn>\t; Double-precision to 32-bit variant"], "symbols": []}, {"mnemonic": "ABS", "short_desc": "Absolute value (vector)", "full_desc": "Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ABS  <V><d>, <V><n>\t; Scalar variant", "ABS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "FRINT64X (vector)", "short_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (vector)", "full_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT64X  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "BIC (vectors, unpredicated)", "short_desc": "Bitwise clear vectors (unpredicated)", "syntax": ["BIC     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "FSQRT (vector)", "short_desc": "Floating-point Square Root (vector)", "full_desc": "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSQRT  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FSQRT  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "TBZ", "short_desc": "Test bit and Branch if Zero", "full_desc": "Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset variant"], "symbols": []}, {"mnemonic": "FNMSUB", "short_desc": "Floating-point Negated fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "ST1W (vector plus immediate)", "short_desc": "Scatter store words from a vector (immediate index)", "syntax": ["ST1W    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "ST1W    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "ST1W (scalar plus scalar)", "short_desc": "Contiguous store words from vector (scalar index)", "syntax": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1D (scalar plus immediate)", "short_desc": "Contiguous load doublewords to vector (immediate index)", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FMINP (vector)", "short_desc": "Floating-point Minimum Pairwise (vector)", "full_desc": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "TRN1", "short_desc": "Transpose vectors (primary)", "full_desc": "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "INCB, INCD, INCH, INCW (scalar)", "short_desc": "Increment scalar by multiple of predicate constraint element count", "syntax": ["INCB    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Byte variant", "INCD    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Doubleword variant", "INCH    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Halfword variant", "INCW    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Word variant"], "symbols": []}, {"mnemonic": "LDFF1SH (vector plus immediate)", "short_desc": "Gather load first-fault signed halfwords to vector (immediate index)", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDFF1SH (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed halfwords to vector (scalar index)", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 32-bit element variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "MLA (by element)", "short_desc": "Multiply-Add to accumulator (vector, by element)", "full_desc": "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "PRFW (scalar plus scalar)", "short_desc": "Contiguous prefetch words (scalar index)", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFW (vector plus immediate)", "short_desc": "Gather prefetch words (vector plus immediate)", "syntax": ["PRFW    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "PRFW    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SM3TT2A", "short_desc": "SM3TT2A", "full_desc": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:\n\nA three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 19.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "MSR (immediate)", "short_desc": "Move immediate value to Special Register", "full_desc": "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see Process state, PSTATE.\n\nThe bits that can be written by this instruction are:", "syntax": ["MSR  <pstatefield>, #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "FMLAL, FMLAL2 (by element)", "short_desc": "Floating-point fused Multiply-Add Long to accumulator (by element)", "full_desc": "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLAL variant", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLAL2 variant"], "symbols": []}, {"mnemonic": "UABA", "short_desc": "Unsigned Absolute difference and Accumulate", "full_desc": "Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "BIF", "short_desc": "Bitwise Insert if False", "full_desc": "Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&FP register into the destination SIMD&FP register if the corresponding bit of the second source SIMD&FP register is 0, otherwise leaves the bit in the destination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LD4R", "short_desc": "Load single 4-element structure and Replicate to all lanes of four registers", "full_desc": "Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "STSET, STSETL", "short_desc": "Atomic bit set on word or doubleword in memory, without return", "full_desc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSET  <Ws>, [<Xn|SP>]\t; 32-bit LDSET alias variant", "STSETL  <Ws>, [<Xn|SP>]\t; 32-bit LDSETL alias variant", "STSET  <Xs>, [<Xn|SP>]\t; 64-bit LDSET alias variant", "STSETL  <Xs>, [<Xn|SP>]\t; 64-bit LDSETL alias variant"], "symbols": []}, {"mnemonic": "MOVS (predicated)", "short_desc": "Move predicates (zeroing), setting the condition flags", "syntax": ["MOVS    <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "ST3B (scalar plus scalar)", "short_desc": "Contiguous store three-byte structures from three vectors (scalar index)", "syntax": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "ERET", "short_desc": "Exception Return", "full_desc": "Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores PSTATE from the SPSR, and branches to the address held in the ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from AArch64 state.", "syntax": ["ERET\t; System variant"], "symbols": []}, {"mnemonic": "FNEG (scalar)", "short_desc": "Floating-point Negate (scalar)", "full_desc": "Floating-point Negate (scalar). This instruction negates the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNEG  <Hd>, <Hn>\t; Half-precision variant", "FNEG  <Sd>, <Sn>\t; Single-precision variant", "FNEG  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "UXTB, UXTH, UXTW", "short_desc": "Unsigned byte / halfword / word extend (predicated)", "syntax": ["UXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte variant", "UXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword variant", "UXTW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word variant"], "symbols": []}, {"mnemonic": "INSR (scalar)", "short_desc": "Insert general-purpose register in shifted vector", "syntax": ["INSR    <Zdn>.<T>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUBS (shifted register)", "short_desc": "Subtract (shifted register), setting flags", "full_desc": "Subtract (shifted register), setting flags, subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST4B (scalar plus immediate)", "short_desc": "Contiguous store four-byte structures from four vectors (immediate index)", "syntax": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD3R", "short_desc": "Load single 3-element structure and Replicate to all lanes of three registers", "full_desc": "Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "PRFB (scalar plus vector)", "short_desc": "Gather prefetch bytes (scalar plus vector)", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit scaled offset variant", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked scaled offset variant", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit scaled offset variant"], "symbols": []}, {"mnemonic": "UQRSHRN, UQRSHRN2", "short_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN.\n\nThe UQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "URSHR", "short_desc": "Unsigned Rounding Shift Right (immediate)", "full_desc": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSHR  <V><d>, <V><n>, #<shift>\t; Scalar variant", "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "EXT", "short_desc": "Extract vector from pair of vectors", "full_desc": "Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source SIMD&FP register and the highest vector elements from the first source SIMD&FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "UUNPKHI, UUNPKLO", "short_desc": "Unsigned unpack and extend half of vector", "syntax": ["UUNPKHI <Zd>.<T>, <Zn>.<Tb>\t; High half variant", "UUNPKLO <Zd>.<T>, <Zn>.<Tb>\t; Low half variant"], "symbols": []}, {"mnemonic": "FCMLA", "short_desc": "Floating-point Complex Multiply Accumulate", "full_desc": "Floating-point Complex Multiply Accumulate.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers and the destination register:\n\nThe multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>\t; Vector variant"], "symbols": []}, {"mnemonic": "LDR (vector)", "short_desc": "Load vector register", "syntax": ["LDR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "STR (immediate, SIMD&FP)", "short_desc": "Store SIMD&FP register (immediate offset)", "full_desc": "Store SIMD&FP register (immediate offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit variant", "STR  <St>, [<Xn|SP>], #<simm>\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit variant", "STR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit variant", "STR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit variant", "STR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit variant", "STR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit variant", "STR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "STR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant", "STR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "UQADD (immediate)", "short_desc": "Unsigned saturating add immediate (unpredicated)", "syntax": ["UQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "ORN, ORNS (predicates)", "short_desc": "Bitwise inclusive OR inverted predicate", "syntax": ["ORN     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "ORNS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "LDRSB (immediate)", "short_desc": "Load Register Signed Byte (immediate)", "full_desc": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSB  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQINCP (vector)", "short_desc": "Signed saturating increment vector by count of true predicate elements", "syntax": ["SQINCP  <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "USMMLA (vector)", "short_desc": "Unsigned and signed 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector variant"], "symbols": []}, {"mnemonic": "CLASTB (vectors)", "short_desc": "Conditionally extract last element to vector register", "syntax": ["CLASTB  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINT32Z (vector)", "short_desc": "Floating-point Round to 32-bit Integer toward Zero (vector)", "full_desc": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT32Z  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDFF1H (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned halfwords to vector (scalar index)", "syntax": ["LDFF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 16-bit element variant", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 32-bit element variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SMSUBL", "short_desc": "Signed Multiply-Subtract Long", "full_desc": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDFF1H (vector plus immediate)", "short_desc": "Gather load first-fault unsigned halfwords to vector (immediate index)", "syntax": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1RH", "short_desc": "Load and broadcast unsigned halfword to vector", "syntax": ["LD1RH   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element variant", "LD1RH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element variant", "LD1RH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "FMLS (vectors)", "short_desc": "Floating-point fused multiply-subtract vectors (predicated), writing addend [Zda = Zda + -Zn * Zm]", "syntax": ["FMLS    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOVPRFX (unpredicated)", "short_desc": "Move prefix (unpredicated)", "syntax": ["MOVPRFX <Zd>, <Zn>\t; SVE variant"], "symbols": []}, {"mnemonic": "UDOT (vector)", "short_desc": "Dot Product unsigned arithmetic (vector)", "full_desc": "Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "SDOT (by element)", "short_desc": "Dot Product signed arithmetic (vector, by element)", "full_desc": "Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SSBB", "short_desc": "Speculative Store Bypass Barrier", "full_desc": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions.\n\nThe semantics of the Speculative Store Bypass Barrier are:", "syntax": ["SSBB\t; System variant"], "symbols": []}, {"mnemonic": "LDEORB, LDEORAB, LDEORALB, LDEORLB", "short_desc": "Atomic exclusive OR on byte in memory", "full_desc": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEORAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORAB variant", "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORALB variant", "LDEORB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORB variant", "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORLB variant"], "symbols": []}, {"mnemonic": "MOV (to general)", "short_desc": "Move vector element to general-purpose register", "full_desc": "Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Wd>, <Vn>.S[<index>]\t; 32-bit variant", "MOV  <Xd>, <Vn>.D[<index>]\t; 64-reg,UMOV-64-reg variant"], "symbols": []}, {"mnemonic": "ZIP2", "short_desc": "Zip vectors (secondary)", "full_desc": "Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "BFDOT (vectors)", "short_desc": "BFloat16 floating-point dot product", "syntax": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H\t; SVE variant"], "symbols": []}, {"mnemonic": "LSLV", "short_desc": "Logical Shift Left Variable", "full_desc": "Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSLV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "LSLV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1RSH", "short_desc": "Load and broadcast signed halfword to vector", "syntax": ["LD1RSH  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element variant", "LD1RSH  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "UDOT (indexed)", "short_desc": "Unsigned integer indexed dot product", "syntax": ["UDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; 32-bit variant", "UDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SM3PARTW1", "short_desc": "SM3PARTW1", "full_desc": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory", "full_desc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMIN variant", "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINA variant", "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINAL variant", "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINL variant", "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMIN variant", "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINA variant", "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINAL variant", "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINL variant"], "symbols": []}, {"mnemonic": "ST1B (scalar plus vector)", "short_desc": "Scatter store bytes from a vector (vector index)", "syntax": ["ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "ST1B    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "SMULH", "short_desc": "Signed Multiply High", "full_desc": "Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["SMULH  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UDF", "short_desc": "Permanently Undefined", "full_desc": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC = 0b000000). The encodings for UDF used in this section are defined as permanently undefined in the Armv8-A architecture.", "syntax": ["UDF  #<imm>\t; Integer variant"], "symbols": []}, {"mnemonic": "SMAX", "short_desc": "Signed Maximum (vector)", "full_desc": "Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LDRSW (immediate)", "short_desc": "Load Register Signed Word (immediate)", "full_desc": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRSW  <Xt>, [<Xn|SP>], #<simm>\t; Post-index variant", "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!\t; Pre-index variant", "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset variant"], "symbols": []}, {"mnemonic": "ZIP1, ZIP2 (predicates)", "short_desc": "Interleave elements from two half predicates", "syntax": ["ZIP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; High halves variant", "ZIP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Low halves variant"], "symbols": []}, {"mnemonic": "FMLA (by element)", "short_desc": "Floating-point fused Multiply-Add to accumulator (by element)", "full_desc": "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results in the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLA  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UBFM", "short_desc": "Unsigned Bitfield Move", "full_desc": "Unigned Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits.\n\nIn both cases the destination bits below and above the bitfield are set to zero.", "syntax": ["UBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "UBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMUL (indexed)", "short_desc": "Floating-point multiply by indexed elements", "syntax": ["FMUL    <Zd>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision variant", "FMUL    <Zd>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision variant", "FMUL    <Zd>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision variant"], "symbols": []}, {"mnemonic": "MOVPRFX (predicated)", "short_desc": "Move prefix (predicated)", "syntax": ["MOVPRFX <Zd>.<T>, <Pg>/<ZM>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMSB", "short_desc": "Floating-point fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za + -Zdn * Zm]", "syntax": ["FMSB    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDSET, LDSETA, LDSETAL, LDSETL", "short_desc": "Atomic bit set on word or doubleword in memory", "full_desc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSET  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSET variant", "LDSETA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETA variant", "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETAL variant", "LDSETL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETL variant", "LDSET  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSET variant", "LDSETA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETA variant", "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETAL variant", "LDSETL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETL variant"], "symbols": []}, {"mnemonic": "FMINNM (vectors)", "short_desc": "Floating-point minimum number (predicated)", "syntax": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "REV16", "short_desc": "Reverse bytes in 16-bit halfwords", "full_desc": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register.", "syntax": ["REV16  <Wd>, <Wn>\t; 32-bit variant", "REV16  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "AND (vector)", "short_desc": "Bitwise AND (vector)", "full_desc": "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SMLSL, SMLSL2 (vector)", "short_desc": "Signed Multiply-Subtract Long (vector)", "full_desc": "Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts each source vector from the lower half of each source register, while the SMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LD3 (multiple structures)", "short_desc": "Load multiple 3-element structures to three registers", "full_desc": "Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&FP registers, with de-interleaving.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset variant", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "SSUBW, SSUBW2", "short_desc": "Signed Subtract Wide", "full_desc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.\n\nThe SSUBW instruction extracts the second source vector from the lower half of the second source register, while the SSUBW2 instruction extracts the second source vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "SQSHLU", "short_desc": "Signed saturating Shift Left Unsigned (immediate)", "full_desc": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHLU  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "UQINCH (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count", "syntax": ["UQINCH  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1D (vector plus immediate)", "short_desc": "Gather load doublewords to vector (immediate index)", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1D (scalar plus scalar)", "short_desc": "Contiguous load doublewords to vector (scalar index)", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "UMULL, UMULL2 (by element)", "short_desc": "Unsigned Multiply Long (vector, by element)", "full_desc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMULL instruction extracts vector elements from the lower half of the first source register, while the UMULL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTZS (vector, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": []}, {"mnemonic": "FDIV (vector)", "short_desc": "Floating-point Divide (vector)", "full_desc": "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ST1W (scalar plus immediate)", "short_desc": "Contiguous store words from vector (immediate index)", "syntax": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "NOTS", "short_desc": "Bitwise invert predicate, setting the condition flags", "syntax": ["NOTS    <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "PRFW (scalar plus immediate)", "short_desc": "Contiguous prefetch words (immediate index)", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDTRSW", "short_desc": "Load Register Signed Word (unprivileged)", "full_desc": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "STLRH", "short_desc": "Store-Release Register Halfword", "full_desc": "Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "BFMMLA", "short_desc": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix", "full_desc": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This instruction multiplies the 2x4 matrix of BF16 values held in the first 128-bit source vector by the 4x2 BF16 matrix in the second 128-bit source vector. The resulting 2x2 single-precision matrix product is then added destructively to the 2x2 single-precision matrix in the 128-bit destination vector. This is equivalent to performing a 4-way dot product per destination element. The instruction ignores the FPCR and does not update the FPSR exception status.", "syntax": ["BFMMLA  <Vd>.4S, <Vn>.8H, <Vm>.8H\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTPS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTPS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTPS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTPS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTPS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTPS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "LDNF1W", "short_desc": "Contiguous load non-fault unsigned words to vector (immediate index)", "syntax": ["LDNF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LDNF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "BFCVT", "short_desc": "Floating-point convert from single-precision to BFloat16 format (scalar)", "full_desc": "Floating-point convert from single-precision to BFloat16 format (scalar) converts the single-precision floating-point value in the 32-bit SIMD&FP source register to BFloat16 format and writes the result in the 16-bit SIMD&FP destination register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. This instruction can generate a floating-point exception that causes a cumulative exception bit in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.", "syntax": ["BFCVT  <Hd>, <Sn>\t; Single-precision to BFloat16 variant"], "symbols": []}, {"mnemonic": "CLZ", "short_desc": "Count leading zero bits (predicated)", "syntax": ["CLZ     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "BFCVTN, BFCVTN2", "short_desc": "Floating-point convert from single-precision to BFloat16 format (vector)", "full_desc": "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&FP destination vector. The result elements are half the width of the source elements.\n\nThe BFCVTN instruction writes the half-width results to the lower half of the destination vector and clears the upper half to zero, while the BFCVTN2 instruction writes the results to the upper half of the destination vector without affecting the other bits in the register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR.", "syntax": ["BFCVTN{2}  <Vd>.<Ta>, <Vn>.4S\t; Vector single-precision to BFloat16 variant"], "symbols": []}, {"mnemonic": "FMAXNM (vectors)", "short_desc": "Floating-point maximum number (predicated)", "syntax": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMULX", "short_desc": "Floating-point Multiply extended", "full_desc": "Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMULX  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FMULX  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ASR (immediate)", "short_desc": "Arithmetic Shift Right (immediate)", "full_desc": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register.", "syntax": ["ASR  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "ASR  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMAX (immediate)", "short_desc": "Floating-point maximum with immediate (predicated)", "syntax": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST3B (scalar plus immediate)", "short_desc": "Contiguous store three-byte structures from three vectors (immediate index)", "syntax": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "BRAA, BRAAZ, BRAB, BRABZ", "short_desc": "Branch to Register, with pointer authentication", "full_desc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by <Xn>, using a modifier and the specified key, and branches to the authenticated address.\n\nThe modifier is:\n\nKey A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.", "syntax": ["BRAAZ  <Xn>\t; Key A, zero modifier variant", "BRAA  <Xn>, <Xm|SP>\t; Key A, register modifier variant", "BRABZ  <Xn>\t; Key B, zero modifier variant", "BRAB  <Xn>, <Xm|SP>\t; Key B, register modifier variant"], "symbols": []}, {"mnemonic": "SHA512H", "short_desc": "SHA512 Hash update part 1", "full_desc": "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["SHA512H  <Qd>, <Qn>, <Vm>.2D\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "ST4B (scalar plus scalar)", "short_desc": "Contiguous store four-byte structures from four vectors (scalar index)", "syntax": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "STEORH, STEORLH", "short_desc": "Atomic exclusive OR on halfword in memory, without return", "full_desc": "Atomic exclusive OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEORH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STEORLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "CSNEG", "short_desc": "Conditional Select Negation", "full_desc": "Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register.", "syntax": ["CSNEG  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSNEG  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CMN (immediate)", "short_desc": "Compare Negative (immediate)", "full_desc": "Compare Negative (immediate) adds a register value and an optionally-shifted immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "CMN  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDR (literal, SIMD&FP)", "short_desc": "Load SIMD&FP Register (PC-relative literal)", "full_desc": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from the PC value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <St>, <label>\t; 32-bit variant", "LDR  <Dt>, <label>\t; 64-bit variant", "LDR  <Qt>, <label>\t; 128-bit variant"], "symbols": []}, {"mnemonic": "SQDMLSL, SQDMLSL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long", "full_desc": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts each source vector from the lower half of each source register, while the SQDMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "FRINTM (vector)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTM  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTM  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FADD (vector)", "short_desc": "Floating-point Add (vector)", "full_desc": "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SQRDMLSH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "CRC32B, CRC32H, CRC32W, CRC32X", "short_desc": "CRC32 checksum", "full_desc": "In Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for all implementations to implement it.", "syntax": ["CRC32B  <Wd>, <Wn>, <Wm>\t; CRC32B variant", "CRC32H  <Wd>, <Wn>, <Wm>\t; CRC32H variant", "CRC32W  <Wd>, <Wn>, <Wm>\t; CRC32W variant", "CRC32X  <Wd>, <Wn>, <Xm>\t; CRC32X variant"], "symbols": []}, {"mnemonic": "SCVTF (scalar, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (scalar)", "full_desc": "Signed fixed-point Convert to Floating-point (scalar). This instruction converts the signed value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision variant", "SCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision variant", "SCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision variant", "SCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision variant", "SCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision variant", "SCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "FCVTNS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTNS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTNS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTNS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTNS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTNS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "SQINCW (vector)", "short_desc": "Signed saturating increment vector by multiple of 32-bit predicate constraint element count", "syntax": ["SQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "EOR, EORS (predicates)", "short_desc": "Bitwise exclusive OR predicates", "syntax": ["EOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "EORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "UMAX (vectors)", "short_desc": "Unsigned maximum vectors (predicated)", "syntax": ["UMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ASR (immediate, predicated)", "short_desc": "Arithmetic shift right by immediate (predicated)", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDR (register)", "short_desc": "Load Register (register)", "full_desc": "Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDR (register, SIMD&FP)", "short_desc": "Load SIMD&FP Register (register offset)", "full_desc": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-fsreg,LDR-8-fsreg variant", "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-fsreg,LDR-8-fsreg variant", "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-fsreg,LDR-16-fsreg variant", "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-fsreg,LDR-32-fsreg variant", "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-fsreg,LDR-64-fsreg variant", "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-fsreg,LDR-128-fsreg variant"], "symbols": []}, {"mnemonic": "MOVZ", "short_desc": "Move wide with zero", "full_desc": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVZ  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVZ  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST4 (multiple structures)", "short_desc": "Store multiple 4-element structures from four registers", "full_desc": "Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to memory from four SIMD&FP registers, with interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset variant", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "CBZ", "short_desc": "Compare and Branch on Zero", "full_desc": "Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["CBZ  <Wt>, <label>\t; 32-bit variant", "CBZ  <Xt>, <label>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDNF1SH", "short_desc": "Contiguous load non-fault signed halfwords to vector (immediate index)", "syntax": ["LDNF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LDNF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "CMLT (zero)", "short_desc": "Compare signed Less than zero (vector)", "full_desc": "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMLT  <V><d>, <V><n>, #0\t; Scalar variant", "CMLT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector variant"], "symbols": []}, {"mnemonic": "CMHI (register)", "short_desc": "Compare unsigned Higher (vector)", "full_desc": "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMHI  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "ERETAA, ERETAB", "short_desc": "Exception Return, with pointer authentication", "full_desc": "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address.\n\nKey A is used for ERETAA, and key B is used for ERETAB.\n\nIf the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from AArch64 state.", "syntax": ["ERETAA\t; ERETAA variant", "ERETAB\t; ERETAB variant"], "symbols": []}, {"mnemonic": "UABAL, UABAL2", "short_desc": "Unsigned Absolute difference and Accumulate Long", "full_desc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UABAL instruction extracts each source vector from the lower half of each source register, while the UABAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "CCMP (register)", "short_desc": "Conditional Compare (register)", "full_desc": "Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STCLRH, STCLRLH", "short_desc": "Atomic bit clear on halfword in memory, without return", "full_desc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLRH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STCLRLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "TST (shifted register)", "short_desc": "Test (shifted register)", "full_desc": "Test (shifted register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "TST  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDXR", "short_desc": "Load Exclusive Register", "full_desc": "Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CSET", "short_desc": "Conditional Set", "full_desc": "Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.", "syntax": ["CSET  <Wd>, <cond>\t; 32-bit variant", "CSET  <Xd>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQABS", "short_desc": "Signed saturating Absolute value", "full_desc": "Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQABS  <V><d>, <V><n>\t; Scalar variant", "SQABS  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "DSB", "short_desc": "Data Synchronization Barrier", "full_desc": "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier.", "syntax": ["DSB  <option>|#<imm>\t; System variant"], "symbols": []}, {"mnemonic": "LDAR", "short_desc": "Load-Acquire Register", "full_desc": "Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STSETB, STSETLB", "short_desc": "Atomic bit set on byte in memory, without return", "full_desc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSETB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSETLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "LDR (immediate, SIMD&FP)", "short_desc": "Load SIMD&FP Register (immediate offset)", "full_desc": "Load SIMD&FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit variant", "LDR  <St>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit variant", "LDR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit variant", "LDR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit variant", "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit variant", "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit variant", "LDR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant", "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "LD1R", "short_desc": "Load one single-element structure and Replicate to all lanes (of one register)", "full_desc": "Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1R  { <Vt>.<T> }, [<Xn|SP>]\t; No offset variant", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "FMUL (vector)", "short_desc": "Floating-point Multiply (vector)", "full_desc": "Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ASRV", "short_desc": "Arithmetic Shift Right Variable", "full_desc": "Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASRV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ASRV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1ROB (scalar plus scalar)", "short_desc": "Contiguous load and replicate thirty-two bytes (scalar index)", "syntax": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "FCMEQ (zero)", "short_desc": "Floating-point Compare Equal to zero (vector)", "full_desc": "Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMEQ  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMEQ  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SRSHL", "short_desc": "Signed Rounding Shift Left (register)", "full_desc": "Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For a truncating shift, see SSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "RSHRN, RSHRN2", "short_desc": "Rounding Shift Right Narrow (immediate)", "full_desc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "LDXP", "short_desc": "Load Exclusive Pair of Registers", "full_desc": "Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UMAX (immediate)", "short_desc": "Unsigned maximum with immediate (unpredicated)", "syntax": ["UMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "CMN (shifted register)", "short_desc": "Compare Negative (shifted register)", "full_desc": "Compare Negative (shifted register) adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "CMN  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "AND (vectors, unpredicated)", "short_desc": "Bitwise AND vectors (unpredicated)", "syntax": ["AND     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "SQINCP (scalar)", "short_desc": "Signed saturating increment scalar by count of true predicate elements", "syntax": ["SQINCP  <Xdn>, <Pm>.<T>, <Wdn>\t; 32-bit variant", "SQINCP  <Xdn>, <Pm>.<T>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1SB (scalar plus vector)", "short_desc": "Gather load signed bytes to vector (vector index)", "syntax": ["LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "AXFLAG", "short_desc": "Convert floating-point condition flags from Arm to external format", "full_desc": "Convert floating-point condition flags from Arm to external format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction to an alternative representation required by some software.", "syntax": ["AXFLAG\t; System variant"], "symbols": []}, {"mnemonic": "BIC, BICS (predicates)", "short_desc": "Bitwise clear predicates", "syntax": ["BIC     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "BICS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "FCVTZU (scalar, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTZU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTZU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTZU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTZU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTZU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "AESIMC", "short_desc": "AES inverse mix columns", "full_desc": "AES inverse mix columns.", "syntax": ["AESIMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "EON (shifted register)", "short_desc": "Bitwise Exclusive OR NOT (shifted register)", "full_desc": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STNT1B (scalar plus scalar)", "short_desc": "Contiguous store non-temporal bytes from vector (scalar index)", "syntax": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "UQINCB", "short_desc": "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint element count", "syntax": ["UQINCB  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PFALSE", "short_desc": "Set all predicate elements to false", "syntax": ["PFALSE  <Pd>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "UMULL", "short_desc": "Unsigned Multiply Long", "full_desc": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["UMULL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "MOV (element)", "short_desc": "Move vector element to another vector element", "full_desc": "Move vector element to another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "UQSUB", "short_desc": "Unsigned saturating Subtract", "full_desc": "Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "LD1B (scalar plus vector)", "short_desc": "Gather load unsigned bytes to vector (vector index)", "syntax": ["LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "TBNZ", "short_desc": "Test bit and Branch if Nonzero", "full_desc": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBNZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset variant"], "symbols": []}, {"mnemonic": "SQDECD (vector)", "short_desc": "Signed saturating decrement vector by multiple of 64-bit predicate constraint element count", "syntax": ["SQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "STCLR, STCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory, without return", "full_desc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STCLR  <Ws>, [<Xn|SP>]\t; 32-bit LDCLR alias variant", "STCLRL  <Ws>, [<Xn|SP>]\t; 32-bit LDCLRL alias variant", "STCLR  <Xs>, [<Xn|SP>]\t; 64-bit LDCLR alias variant", "STCLRL  <Xs>, [<Xn|SP>]\t; 64-bit LDCLRL alias variant"], "symbols": []}, {"mnemonic": "REVB, REVH, REVW", "short_desc": "Reverse bytes / halfwords / words within elements (predicated)", "syntax": ["REVB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte variant", "REVH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword variant", "REVW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word variant"], "symbols": []}, {"mnemonic": "PMULL, PMULL2", "short_desc": "Polynomial Multiply Long", "full_desc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0, 1}.\n\nThe PMULL instruction extracts each source vector from the lower half of each source register, while the PMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "HINT", "short_desc": "Hint instruction", "full_desc": "Hint instruction is for the instruction set space that is reserved for architectural hint instructions.\n\nSome encodings described here are not allocated in this revision of the architecture, and behave as NOPs. These encodings might be allocated to other hint functionality in future revisions of the architecture and therefore must not be used by software.", "syntax": ["HINT  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "CMN (extended register)", "short_desc": "Compare Negative (extended register)", "full_desc": "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQSHL (immediate)", "short_desc": "Unsigned saturating Shift Left (immediate)", "full_desc": "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "PUNPKHI, PUNPKLO", "short_desc": "Unpack and widen half of predicate", "syntax": ["PUNPKHI <Pd>.H, <Pn>.B\t; High half variant", "PUNPKLO <Pd>.H, <Pn>.B\t; Low half variant"], "symbols": []}, {"mnemonic": "CLASTA (vectors)", "short_desc": "Conditionally extract element after last to vector register", "syntax": ["CLASTA  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FNMAD", "short_desc": "Floating-point negated fused multiply-add vectors (predicated), writing multiplicand [Zdn = -Za + -Zdn * Zm]", "syntax": ["FNMAD   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMINNM (vector)", "short_desc": "Floating-point Minimum Number (vector)", "full_desc": "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SUB (vectors, unpredicated)", "short_desc": "Subtract vectors (unpredicated)", "syntax": ["SUB     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOVS (unpredicated)", "short_desc": "Move predicate (unpredicated), setting the condition flags", "syntax": ["MOVS    <Pd>.B, <Pn>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "AND (shifted register)", "short_desc": "Bitwise AND (shifted register)", "full_desc": "Bitwise AND (shifted register) performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SSHL", "short_desc": "Signed Shift Left (register)", "full_desc": "Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see SRSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "WFI", "short_desc": "Wait For Interrupt", "full_desc": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFI instruction that  would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See:", "syntax": ["WFI\t; System variant"], "symbols": []}, {"mnemonic": "ANDS (shifted register)", "short_desc": "Bitwise AND (shifted register), setting flags", "full_desc": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1W (vector plus immediate)", "short_desc": "Gather load unsigned words to vector (immediate index)", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LD1W (scalar plus scalar)", "short_desc": "Contiguous load unsigned words to vector (scalar index)", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; 32-bit element variant", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "WHILELE", "short_desc": "While incrementing signed scalar less than or equal to scalar", "syntax": ["WHILELE <Pd>.<T>, <R><n>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1D (scalar plus immediate)", "short_desc": "Contiguous store doublewords from vector (immediate index)", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "STUMAXH, STUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory, without return", "full_desc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMAXLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "LDTRSB", "short_desc": "Load Register Signed Byte (unprivileged)", "full_desc": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BCAX", "short_desc": "Bit Clear and XOR", "full_desc": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "MLA", "short_desc": "Multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "syntax": ["MLA     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STURH", "short_desc": "Store Register Halfword (unscaled)", "full_desc": "Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", "short_desc": "Atomic signed maximum on byte in memory", "full_desc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXAB variant", "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXALB variant", "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXB variant", "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXLB variant"], "symbols": []}, {"mnemonic": "MOVN", "short_desc": "Move wide with NOT", "full_desc": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVN  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVN  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CSEL", "short_desc": "Conditional Select", "full_desc": "Conditional Select returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register.", "syntax": ["CSEL  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSEL  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FNEG", "short_desc": "Floating-point negate (predicated)", "syntax": ["FNEG    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "BRKN, BRKNS", "short_desc": "Propagate break to next partition", "syntax": ["BRKN    <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B\t; Not setting the condition flags variant", "BRKNS   <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "FRINTZ (scalar)", "short_desc": "Floating-point Round to Integral, toward Zero (scalar)", "full_desc": "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTZ  <Hd>, <Hn>\t; Half-precision variant", "FRINTZ  <Sd>, <Sn>\t; Single-precision variant", "FRINTZ  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SHADD", "short_desc": "Signed Halving Add", "full_desc": "Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SRHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "UQSHRN, UQSHRN2", "short_desc": "Unsigned saturating Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN.\n\nThe UQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "SEV", "short_desc": "Send Event", "full_desc": "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see Wait for Event mechanism and Send event.", "syntax": ["SEV\t; System variant"], "symbols": []}, {"mnemonic": "LDTR", "short_desc": "Load Register (unprivileged)", "full_desc": "Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMOV (zero, unpredicated)", "short_desc": "Move floating-point +0.0 to vector elements (unpredicated)", "syntax": ["FMOV    <Zd>.<T>, #0.0\t; SVE variant"], "symbols": []}, {"mnemonic": "LD3B (scalar plus scalar)", "short_desc": "Contiguous load three-byte structures to three vectors (scalar index)", "syntax": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "STGP", "short_desc": "Store Allocation Tag and Pair of registers", "full_desc": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from two registers. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the base register.\n\nThis instruction generates an Unchecked access.", "syntax": ["STGP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; Post-index variant", "STGP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; Pre-index variant", "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; Signed offset variant"], "symbols": []}, {"mnemonic": "BFMLALT (vectors)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (top)", "syntax": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H\t; SVE variant"], "symbols": []}, {"mnemonic": "LD4B (scalar plus immediate)", "short_desc": "Contiguous load four-byte structures to four vectors (immediate index)", "syntax": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FNMADD", "short_desc": "Floating-point Negated fused Multiply-Add (scalar)", "full_desc": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FNMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FNMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SXTW", "short_desc": "Sign Extend Word", "full_desc": "Sign Extend Word sign-extends a word to the size of the register, and writes the result to the destination register.", "syntax": ["SXTW  <Xd>, <Wn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BFDOT (indexed)", "short_desc": "BFloat16 floating-point indexed dot product", "syntax": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "SADDV", "short_desc": "Signed add reduction to scalar", "syntax": ["SADDV   <Dd>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFD (scalar plus immediate)", "short_desc": "Contiguous prefetch doublewords (immediate index)", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FMOV (immediate, predicated)", "short_desc": "Move 8-bit floating-point immediate to vector elements (predicated)", "syntax": ["FMOV    <Zd>.<T>, <Pg>/M, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMOV (immediate, unpredicated)", "short_desc": "Move 8-bit floating-point immediate to vector elements (unpredicated)", "syntax": ["FMOV    <Zd>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory", "full_desc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLR variant", "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRA variant", "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRAL variant", "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRL variant", "LDCLR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLR variant", "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRA variant", "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRAL variant", "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRL variant"], "symbols": []}, {"mnemonic": "LD1SW (vector plus immediate)", "short_desc": "Gather load signed words to vector (immediate index)", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1SW (scalar plus scalar)", "short_desc": "Contiguous load signed words to vector (scalar index)", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNF1D", "short_desc": "Contiguous load non-fault doublewords to vector (immediate index)", "syntax": ["LDNF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "AT", "short_desc": "Address Translate", "full_desc": "Address Translate. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions.", "syntax": ["AT  <at_op>, <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "ADR", "short_desc": "Compute vector address", "syntax": ["ADR     <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod> <amount>}]\t; Packed offsets variant", "ADR     <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{ <amount>}]\t; Unpacked 32-bit signed offsets variant", "ADR     <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{ <amount>}]\t; Unpacked 32-bit unsigned offsets variant"], "symbols": []}, {"mnemonic": "FABD", "short_desc": "Floating-point Absolute Difference (vector)", "full_desc": "Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FABD  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FABD  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SBFX", "short_desc": "Signed Bitfield Extract", "full_desc": "Signed Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most significant bit of the bitfield.", "syntax": ["SBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "SBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", "short_desc": "Atomic signed minimum on byte in memory", "full_desc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINAB variant", "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINALB variant", "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINB variant", "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINLB variant"], "symbols": []}, {"mnemonic": "NEG (shifted register)", "short_desc": "Negate (shifted register)", "full_desc": "Negate (shifted register) negates an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["NEG  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "NEG  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "AESE", "short_desc": "AES single round encryption", "full_desc": "AES single round encryption.", "syntax": ["AESE  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SCVTF (scalar, integer)", "short_desc": "Signed integer Convert to Floating-point (scalar)", "full_desc": "Signed integer Convert to Floating-point (scalar). This instruction converts the signed integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Wn>\t; 32-bit to half-precision variant", "SCVTF  <Sd>, <Wn>\t; 32-bit to single-precision variant", "SCVTF  <Dd>, <Wn>\t; 32-bit to double-precision variant", "SCVTF  <Hd>, <Xn>\t; 64-bit to half-precision variant", "SCVTF  <Sd>, <Xn>\t; 64-bit to single-precision variant", "SCVTF  <Dd>, <Xn>\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "PRFD (scalar plus vector)", "short_desc": "Gather prefetch doublewords (scalar plus vector)", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]\t; 32-bit scaled offset variant", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset variant", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset variant"], "symbols": []}, {"mnemonic": "AESMC", "short_desc": "AES mix columns", "full_desc": "AES mix columns.", "syntax": ["AESMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "MUL (vectors)", "short_desc": "Multiply vectors (predicated)", "syntax": ["MUL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "WRFFR", "short_desc": "Write the first-fault register", "syntax": ["WRFFR   <Pn>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "RDVL", "short_desc": "Read multiple of vector register size to scalar register", "syntax": ["RDVL    <Xd>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDUR", "short_desc": "Load Register (unscaled)", "full_desc": "Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FDUP", "short_desc": "Broadcast 8-bit floating-point immediate to vector elements (unpredicated)", "syntax": ["FDUP    <Zd>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "FRINT<r>", "short_desc": "Floating-point round to integral value (predicated)", "syntax": ["FRINTI  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Current mode variant", "FRINTX  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Current mode signalling inexact variant", "FRINTA  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Nearest with ties to away variant", "FRINTN  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Nearest with ties to even variant", "FRINTZ  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward zero variant", "FRINTM  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward minus infinity variant", "FRINTP  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward plus infinity variant"], "symbols": []}, {"mnemonic": "LD4 (single structure)", "short_desc": "Load single 4-element structure to one lane of four registers", "full_desc": "Load single 4-element structure to one lane of four registers. This instruction loads a 4-element structure from memory and writes the result to the corresponding elements of the four SIMD&FP registers without affecting the other bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset variant", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset variant", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset variant", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset variant", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "UMINP", "short_desc": "Unsigned Minimum Pairwise", "full_desc": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FRECPX", "short_desc": "Floating-point reciprocal exponent (predicated)", "syntax": ["FRECPX  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "BFCVTNT", "short_desc": "Floating-point down convert and narrow to BFloat16 (top, predicated)", "syntax": ["BFCVTNT <Zd>.H, <Pg>/M, <Zn>.S\t; SVE variant"], "symbols": []}, {"mnemonic": "TBL", "short_desc": "Programmable table lookup in single vector table", "syntax": ["TBL     <Zd>.<T>, { <Zn>.<T> }, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UXTB", "short_desc": "Unsigned Extend Byte", "full_desc": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTB  <Wd>, <Wn>\t; 32-bit variant"], "symbols": []}, {"mnemonic": "MOV (predicate, predicated, merging)", "short_desc": "Move predicates (merging)", "syntax": ["MOV     <Pd>.B, <Pg>/M, <Pn>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1ROW (scalar plus immediate)", "short_desc": "Contiguous load and replicate eight words (immediate index)", "syntax": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SMADDL", "short_desc": "Signed Multiply-Add Long", "full_desc": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMLSL, FMLSL2 (vector)", "short_desc": "Floating-point fused Multiply-Subtract Long from accumulator (vector)", "full_desc": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This instruction negates the values in the vector of one SIMD&FP register, multiplies these with the corresponding values in another vector, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLSL variant", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLSL2 variant"], "symbols": []}, {"mnemonic": "FCVTNU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTNU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTNU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTNU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTNU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTNU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTNU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "RETAA, RETAB", "short_desc": "Return from subroutine, with pointer authentication", "full_desc": "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return.\n\nKey A is used for RETAA, and key B is used for RETAB.\n\nIf the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to LR.", "syntax": ["RETAA\t; RETAA variant", "RETAB\t; RETAB variant"], "symbols": []}, {"mnemonic": "FDIV", "short_desc": "Floating-point divide by vector (predicated)", "syntax": ["FDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "DECD, DECH, DECW (vector)", "short_desc": "Decrement vector by multiple of predicate constraint element count", "syntax": ["DECD    <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; Doubleword variant", "DECH    <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; Halfword variant", "DECW    <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; Word variant"], "symbols": []}, {"mnemonic": "SHA256H2", "short_desc": "SHA256 hash update (part 2)", "full_desc": "SHA256 hash update (part 2).", "syntax": ["SHA256H2  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "CCMN (immediate)", "short_desc": "Conditional Compare Negative (immediate)", "full_desc": "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SXTH", "short_desc": "Sign Extend Halfword", "full_desc": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTH  <Wd>, <Wn>\t; 32-bit variant", "SXTH  <Xd>, <Wn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "USDOT (by element)", "short_desc": "Dot Product with unsigned and signed integers (vector, by element)", "full_desc": "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "CMGT (register)", "short_desc": "Compare signed Greater than (vector)", "full_desc": "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMGT  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "FMAD", "short_desc": "Floating-point fused multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "syntax": ["FMAD    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory", "full_desc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAX variant", "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXA variant", "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXAL variant", "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXL variant", "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAX variant", "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXA variant", "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXAL variant", "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXL variant"], "symbols": []}, {"mnemonic": "USQADD", "short_desc": "Unsigned saturating Accumulate of Signed value", "full_desc": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USQADD  <V><d>, <V><n>\t; Scalar variant", "USQADD  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCMGT (zero)", "short_desc": "Floating-point Compare Greater than zero (vector)", "full_desc": "Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGT  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMGT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FMSUB", "short_desc": "Floating-point Fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision variant", "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision variant", "FMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "UMAXP", "short_desc": "Unsigned Maximum Pairwise", "full_desc": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "STUMINH, STUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory, without return", "full_desc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STUMINH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STUMINLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "UQDECD (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count", "syntax": ["UQDECD  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST1D (scalar plus vector)", "short_desc": "Scatter store doublewords from a vector (vector index)", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset variant", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset variant", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "TRN1, TRN2 (vectors)", "short_desc": "Interleave even or odd elements from two vectors", "syntax": ["TRN1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Even variant", "TRN1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Even (quadwords) variant", "TRN2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Odd variant", "TRN2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Odd (quadwords) variant"], "symbols": []}, {"mnemonic": "URSRA", "short_desc": "Unsigned Rounding Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "ST2H (scalar plus scalar)", "short_desc": "Contiguous store two-halfword structures from two vectors (scalar index)", "syntax": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "STNT1W (scalar plus immediate)", "short_desc": "Contiguous store non-temporal words from vector (immediate index)", "syntax": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FADD (immediate)", "short_desc": "Floating-point add immediate (predicated)", "syntax": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUB (immediate)", "short_desc": "Subtract immediate (unpredicated)", "syntax": ["SUB     <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "BRKB, BRKBS", "short_desc": "Break before first true condition", "syntax": ["BRKB    <Pd>.B, <Pg>/<ZM>, <Pn>.B\t; Not setting the condition flags variant", "BRKBS   <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "ST3 (single structure)", "short_desc": "Store single 3-element structure from one lane of three registers", "full_desc": "Store single 3-element structure from one lane of three registers. This instruction stores a 3-element structure to memory from corresponding elements of three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset variant", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset variant", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset variant", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset variant", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "CLZ", "short_desc": "Count Leading Zeros", "full_desc": "Count Leading Zeros counts the number of binary zero bits before the first binary one bit in the value of the source register, and writes the result to the destination register.", "syntax": ["CLZ  <Wd>, <Wn>\t; 32-bit variant", "CLZ  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SDOT (indexed)", "short_desc": "Signed integer indexed dot product", "syntax": ["SDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; 32-bit variant", "SDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CSINV", "short_desc": "Conditional Select Invert", "full_desc": "Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register.", "syntax": ["CSINV  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSINV  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PMUL", "short_desc": "Polynomial Multiply", "full_desc": "Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0, 1}.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FSUB (scalar)", "short_desc": "Floating-point Subtract (scalar)", "full_desc": "Floating-point Subtract (scalar). This instruction subtracts the floating-point value of the second source SIMD&FP register from the floating-point value of the first source SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSUB  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FSUB  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FSUB  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "FMOV (scalar, immediate)", "short_desc": "Floating-point move immediate (scalar)", "full_desc": "Floating-point move immediate (scalar). This instruction copies a floating-point immediate constant into the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Hd>, #<imm>\t; Half-precision variant", "FMOV  <Sd>, #<imm>\t; Single-precision variant", "FMOV  <Dd>, #<imm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LD1B (scalar plus immediate)", "short_desc": "Contiguous load unsigned bytes to vector (immediate index)", "syntax": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 8-bit element variant", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "FMINNMV", "short_desc": "Floating-point minimum number recursive reduction to scalar", "syntax": ["FMINNMV <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FTSSEL", "short_desc": "Floating-point trigonometric select coefficient", "syntax": ["FTSSEL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOVK", "short_desc": "Move wide with keep", "full_desc": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged.", "syntax": ["MOVK  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit variant", "MOVK  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BRKPA, BRKPAS", "short_desc": "Break after first true condition, propagating from previous partition", "syntax": ["BRKPA   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "BRKPAS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "FCVTZS (vector, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTZS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "XTN, XTN2", "short_desc": "Extract Narrow", "full_desc": "Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.\n\nThe XTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the XTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQSHL (immediate)", "short_desc": "Signed saturating Shift Left (immediate)", "full_desc": "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHL  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTMS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTMS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LD1SB (scalar plus immediate)", "short_desc": "Contiguous load signed bytes to vector (immediate index)", "syntax": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "FRINTA (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTA  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTA  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "DUP (element)", "short_desc": "Duplicate vector element to vector or scalar", "full_desc": "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["DUP  <V><d>, <Vn>.<T>[<index>]\t; Scalar variant", "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "AND (immediate)", "short_desc": "Bitwise AND with immediate (unpredicated)", "syntax": ["AND     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "FACLE", "short_desc": "Floating-point absolute compare less than or equal", "syntax": ["FACLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal variant"], "symbols": []}, {"mnemonic": "FMAXNMV", "short_desc": "Floating-point maximum number recursive reduction to scalar", "syntax": ["FMAXNMV <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDEORH, LDEORAH, LDEORALH, LDEORLH", "short_desc": "Atomic exclusive OR on halfword in memory", "full_desc": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDEORAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORAH variant", "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORALH variant", "LDEORH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORH variant", "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORLH variant"], "symbols": []}, {"mnemonic": "SUNPKHI, SUNPKLO", "short_desc": "Signed unpack and extend half of vector", "syntax": ["SUNPKHI <Zd>.<T>, <Zn>.<Tb>\t; High half variant", "SUNPKLO <Zd>.<T>, <Zn>.<Tb>\t; Low half variant"], "symbols": []}, {"mnemonic": "FCADD", "short_desc": "Floating-point Complex Add", "full_desc": "Floating-point Complex Add.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers:\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>\t; Vector variant"], "symbols": []}, {"mnemonic": "ORN (immediate)", "short_desc": "Bitwise inclusive OR with inverted immediate (unpredicated)", "syntax": ["ORN     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "UZP2", "short_desc": "Unzip vectors (secondary)", "full_desc": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SUBS (immediate)", "short_desc": "Subtract (immediate), setting flags", "full_desc": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit variant", "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD4W (scalar plus scalar)", "short_desc": "Contiguous load four-word structures to four vectors (scalar index)", "syntax": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "ST4D (scalar plus immediate)", "short_desc": "Contiguous store four-doubleword structures from four vectors (immediate index)", "syntax": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDAXP", "short_desc": "Load-Acquire Exclusive Pair of Registers", "full_desc": "Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD3W (scalar plus immediate)", "short_desc": "Contiguous load three-word structures to three vectors (immediate index)", "syntax": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTPU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTPU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTPU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTPU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTPU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTPU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTPU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "ST3D (scalar plus scalar)", "short_desc": "Contiguous store three-doubleword structures from three vectors (scalar index)", "syntax": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "REV16 (vector)", "short_desc": "Reverse elements in 16-bit halfwords (vector)", "full_desc": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV16  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "ST1B (scalar plus scalar)", "short_desc": "Contiguous store bytes from vector (scalar index)", "syntax": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "DUPM", "short_desc": "Broadcast logical bitmask immediate to vector (unpredicated)", "syntax": ["DUPM    <Zd>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1B (vector plus immediate)", "short_desc": "Scatter store bytes from a vector (immediate index)", "syntax": ["ST1B    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "ST1B    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "DUP (immediate)", "short_desc": "Broadcast signed immediate to vector elements (unpredicated)", "syntax": ["DUP     <Zd>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "STP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers", "full_desc": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit variant", "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit variant", "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "LDADDH, LDADDAH, LDADDALH, LDADDLH", "short_desc": "Atomic add on halfword in memory", "full_desc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDADDAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDAH variant", "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDALH variant", "LDADDH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDH variant", "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDLH variant"], "symbols": []}, {"mnemonic": "USHL", "short_desc": "Unsigned Shift Left (register)", "full_desc": "Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see URSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQINCH (vector)", "short_desc": "Signed saturating increment vector by multiple of 16-bit predicate constraint element count", "syntax": ["SQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "FCMLT (zero)", "short_desc": "Floating-point Compare Less than zero (vector)", "full_desc": "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMLT  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMLT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FRINT64X (scalar)", "short_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar)", "full_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT64X  <Sd>, <Sn>\t; Single-precision variant", "FRINT64X  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LDAXR", "short_desc": "Load-Acquire Exclusive Register", "full_desc": "Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "LDAXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMIN (immediate)", "short_desc": "Signed minimum with immediate (unpredicated)", "syntax": ["SMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "UADDLV", "short_desc": "Unsigned sum Long across Vector", "full_desc": "Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SUBS (extended register)", "short_desc": "Subtract (extended register), setting flags", "full_desc": "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit variant", "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMLS (by element)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (by element)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLS  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UBFX", "short_desc": "Unsigned Bitfield Extract", "full_desc": "Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to zero.", "syntax": ["UBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "UBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "INCP (scalar)", "short_desc": "Increment scalar by count of true predicate elements", "syntax": ["INCP    <Xdn>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (bitmask immediate)", "short_desc": "Move logical bitmask immediate to vector (unpredicated)", "syntax": ["MOV     <Zd>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "XAR", "short_desc": "Exclusive OR and Rotate", "full_desc": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors in the two source SIMD&FP registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate value, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FCMLA (vectors)", "short_desc": "Floating-point complex multiply-add with rotate (predicated)", "syntax": ["FCMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADDG", "short_desc": "Add with Tag", "full_desc": "Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.", "syntax": ["ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>\t; Integer variant"], "symbols": []}, {"mnemonic": "FNMSB", "short_desc": "Floating-point negated fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = -Za + Zdn * Zm]", "syntax": ["FNMSB   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNT1H (scalar plus scalar)", "short_desc": "Contiguous load non-temporal halfwords to vector (scalar index)", "syntax": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "SQDMULL, SQDMULL2 (by element)", "short_desc": "Signed saturating Doubling Multiply Long (by element)", "full_desc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts the first source vector from the lower half of the first source register, while the SQDMULL2 instruction extracts the first source vector from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SQRSHRUN, SQRSHRUN2", "short_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN.\n\nThe SQRSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar variant", "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "CMHS (register)", "short_desc": "Compare unsigned Higher or Same (vector)", "full_desc": "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMHS  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQRDMULH (vector)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "SXTB", "short_desc": "Signed Extend Byte", "full_desc": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTB  <Wd>, <Wn>\t; 32-bit variant", "SXTB  <Xd>, <Wn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMINV", "short_desc": "Signed Minimum across Vector", "full_desc": "Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FCVTAU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTAU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SMAXV", "short_desc": "Signed Maximum across Vector", "full_desc": "Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LD4D (scalar plus scalar)", "short_desc": "Contiguous load four-doubleword structures to four vectors (scalar index)", "syntax": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDFF1H (scalar plus vector)", "short_desc": "Gather load first-fault unsigned halfwords to vector (vector index)", "syntax": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "ST4W (scalar plus immediate)", "short_desc": "Contiguous store four-word structures from four vectors (immediate index)", "syntax": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MVN  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "LD3D (scalar plus immediate)", "short_desc": "Contiguous load three-doubleword structures to three vectors (immediate index)", "syntax": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "ST3W (scalar plus scalar)", "short_desc": "Contiguous store three-word structures from three vectors (scalar index)", "syntax": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDP", "short_desc": "Load Pair of Registers", "full_desc": "Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UXTH", "short_desc": "Unsigned Extend Halfword", "full_desc": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTH  <Wd>, <Wn>\t; 32-bit variant"], "symbols": []}, {"mnemonic": "ASR (vectors)", "short_desc": "Arithmetic shift right by vector (predicated)", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ANDV", "short_desc": "Bitwise AND reduction to scalar", "syntax": ["ANDV    <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMAX (vector)", "short_desc": "Floating-point Maximum (vector)", "full_desc": "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "WHILELS", "short_desc": "While incrementing unsigned scalar lower or same as scalar", "syntax": ["WHILELS <Pd>.<T>, <R><n>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "CSINC", "short_desc": "Conditional Select Increment", "full_desc": "Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1.", "syntax": ["CSINC  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit variant", "CSINC  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PRFB (vector plus immediate)", "short_desc": "Gather prefetch bytes (vector plus immediate)", "syntax": ["PRFB    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "PRFB    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "PRFB (scalar plus scalar)", "short_desc": "Contiguous prefetch bytes (scalar index)", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "UDIV", "short_desc": "Unsigned Divide", "full_desc": "Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["UDIV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "UDIV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CSETM", "short_desc": "Conditional Set Mask", "full_desc": "Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0.", "syntax": ["CSETM  <Wd>, <cond>\t; 32-bit variant", "CSETM  <Xd>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STLXRB", "short_desc": "Store-Release Exclusive Register Byte", "full_desc": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FRINT64Z (vector)", "short_desc": "Floating-point Round to 64-bit Integer toward Zero (vector)", "full_desc": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT64Z  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SADALP", "short_desc": "Signed Add and Accumulate Long Pairwise", "full_desc": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "LD1RQH (scalar plus immediate)", "short_desc": "Contiguous load and replicate eight halfwords (immediate index)", "syntax": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "EOR (vector)", "short_desc": "Bitwise Exclusive OR (vector)", "full_desc": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SM3TT1A", "short_desc": "SM3TT1A", "full_desc": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register.  It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:\n\nThe result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LD1ROD (scalar plus immediate)", "short_desc": "Contiguous load and replicate four doublewords (immediate index)", "syntax": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FMLA (indexed)", "short_desc": "Floating-point fused multiply-add by indexed elements (Zda = Zda + Zn * Zm[indexed])", "syntax": ["FMLA    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision variant", "FMLA    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision variant", "FMLA    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SMULL, SMULL2 (by element)", "short_desc": "Signed Multiply Long (vector, by element)", "full_desc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMULL instruction extracts vector elements from the lower half of the first source register, while the SMULL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SETFFR", "short_desc": "Initialise the first-fault register to all true", "syntax": ["SETFFR\t; SVE variant"], "symbols": []}, {"mnemonic": "BFMLALB, BFMLALT (by element)", "short_desc": "BFloat16 floating-point widening multiply-add long (by element)", "full_desc": "BFloat16 floating-point widening multiply-add long (by element) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first source vector, and the indexed element in the second source vector from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.", "syntax": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "ADDP (scalar)", "short_desc": "Add Pair of elements (scalar)", "full_desc": "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDP  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "UMLSL, UMLSL2 (vector)", "short_desc": "Unsigned Multiply-Subtract Long (vector)", "full_desc": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMLSL instruction extracts each source vector from the lower half of each source register, while the UMLSL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LDR (immediate)", "short_desc": "Load Register (immediate)", "full_desc": "Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes. The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it to the base register value.", "syntax": ["LDR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit variant", "LDR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit variant", "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit variant", "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQINCW (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count", "syntax": ["UQINCW  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMAXV", "short_desc": "Floating-point Maximum across Vector", "full_desc": "Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SDIV", "short_desc": "Signed divide (predicated)", "syntax": ["SDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDG", "short_desc": "Load Allocation Tag", "full_desc": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base register and an immediate signed offset scaled by the Tag granule.", "syntax": ["LDG  <Xt>, [<Xn|SP>{, #<simm>}]\t; Integer variant"], "symbols": []}, {"mnemonic": "UQINCP (scalar)", "short_desc": "Unsigned saturating increment scalar by count of true predicate elements", "syntax": ["UQINCP  <Wdn>, <Pm>.<T>\t; 32-bit variant", "UQINCP  <Xdn>, <Pm>.<T>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PRFW (scalar plus vector)", "short_desc": "Gather prefetch words (scalar plus vector)", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset variant", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant"], "symbols": []}, {"mnemonic": "FCVTZU (scalar, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit variant", "FCVTZU  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit variant", "FCVTZU  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit variant", "FCVTZU  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit variant", "FCVTZU  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit variant", "FCVTZU  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "LDURH", "short_desc": "Load Register Halfword (unscaled)", "full_desc": "Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "SBCS", "short_desc": "Subtract with Carry, setting flags", "full_desc": "Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SBCS  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SBCS  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ORR (vectors, predicated)", "short_desc": "Bitwise inclusive OR vectors (predicated)", "syntax": ["ORR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1W (scalar plus vector)", "short_desc": "Scatter store words from a vector (vector index)", "syntax": ["ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset variant", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset variant", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset variant", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "CAS, CASA, CASAL, CASL", "short_desc": "Compare and Swap word or doubleword in memory", "full_desc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in the register before the instruction was executed.", "syntax": ["CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CAS variant", "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASA variant", "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASAL variant", "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASL variant", "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CAS variant", "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASA variant", "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASAL variant", "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASL variant"], "symbols": []}, {"mnemonic": "LDFF1SH (scalar plus vector)", "short_desc": "Gather load first-fault signed halfwords to vector (vector index)", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "FRINTI (scalar)", "short_desc": "Floating-point Round to Integral, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTI  <Hd>, <Hn>\t; Half-precision variant", "FRINTI  <Sd>, <Sn>\t; Single-precision variant", "FRINTI  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LDLARH", "short_desc": "Load LOAcquire Register Halfword", "full_desc": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDLARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "CLS", "short_desc": "Count Leading Sign bits", "full_desc": "Count Leading Sign bits counts the number of leading bits of the source register that have the same value as the most significant bit of the register, and writes the result to the destination register. This count does not include the most significant bit of the source register.", "syntax": ["CLS  <Wd>, <Wn>\t; 32-bit variant", "CLS  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD2H (scalar plus immediate)", "short_desc": "Contiguous load two-halfword structures to two vectors (immediate index)", "syntax": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "BFI", "short_desc": "Bitfield Insert", "full_desc": "Bitfield Insert copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, leaving the other destination bits unchanged.", "syntax": ["BFI  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit variant", "BFI  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMAXNM (vector)", "short_desc": "Floating-point Maximum Number (vector)", "full_desc": "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "TBX", "short_desc": "Table vector lookup extension", "full_desc": "Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table variant", "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table variant"], "symbols": []}, {"mnemonic": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", "short_desc": "Atomic bit clear on halfword in memory", "full_desc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRAH variant", "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRALH variant", "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRH variant", "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRLH variant"], "symbols": []}, {"mnemonic": "STNT1D (scalar plus immediate)", "short_desc": "Contiguous store non-temporal doublewords from vector (immediate index)", "syntax": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SHA1SU0", "short_desc": "SHA1 schedule update 0", "full_desc": "SHA1 schedule update 0.", "syntax": ["SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FRINT32X (vector)", "short_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector)", "full_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT32X  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FMINV", "short_desc": "Floating-point Minimum across Vector", "full_desc": "Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UADDL, UADDL2", "short_desc": "Unsigned Add Long (vector)", "full_desc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.\n\nThe UADDL instruction extracts each source vector from the lower half of each source register, while the UADDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "INS (general)", "short_desc": "Insert vector element from general-purpose register", "full_desc": "Insert vector element from general-purpose register. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["INS  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SMAXV", "short_desc": "Signed maximum reduction to scalar", "syntax": ["SMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "CPY (scalar)", "short_desc": "Copy general-purpose register to vector elements (predicated)", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, <R><n|SP>\t; SVE variant"], "symbols": []}, {"mnemonic": "LSL (vectors)", "short_desc": "Logical shift left by vector (predicated)", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUBPS", "short_desc": "Subtract Pointer, setting Flags", "full_desc": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register. It updates the condition flags based on the result of the subtraction.", "syntax": ["SUBPS  <Xd>, <Xn|SP>, <Xm|SP>\t; Integer variant"], "symbols": []}, {"mnemonic": "UMADDL", "short_desc": "Unsigned Multiply-Add Long", "full_desc": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD1H (scalar plus immediate)", "short_desc": "Contiguous load unsigned halfwords to vector (immediate index)", "syntax": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "RBIT", "short_desc": "Reverse Bits", "full_desc": "Reverse Bits reverses the bit order in a register.", "syntax": ["RBIT  <Wd>, <Wn>\t; 32-bit variant", "RBIT  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDXRB", "short_desc": "Load Exclusive Register Byte", "full_desc": "Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FMIN (vectors)", "short_desc": "Floating-point minimum (predicated)", "syntax": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STSMAX, STSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory, without return", "full_desc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAX  <Ws>, [<Xn|SP>]\t; 32-bit LDSMAX alias variant", "STSMAXL  <Ws>, [<Xn|SP>]\t; 32-bit LDSMAXL alias variant", "STSMAX  <Xs>, [<Xn|SP>]\t; 64-bit LDSMAX alias variant", "STSMAXL  <Xs>, [<Xn|SP>]\t; 64-bit LDSMAXL alias variant"], "symbols": []}, {"mnemonic": "CMTST", "short_desc": "Compare bitwise Test bits nonzero (vector)", "full_desc": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMTST  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "UZP1, UZP2 (predicates)", "short_desc": "Concatenate even or odd elements from two predicates", "syntax": ["UZP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Even variant", "UZP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Odd variant"], "symbols": []}, {"mnemonic": "URSQRTE", "short_desc": "Unsigned Reciprocal Square Root Estimate", "full_desc": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "REV32 (vector)", "short_desc": "Reverse elements in 32-bit words (vector)", "full_desc": "Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["REV32  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "UQDECB", "short_desc": "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint element count", "syntax": ["UQDECB  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SHRN, SHRN2", "short_desc": "Shift Right Narrow (immediate)", "full_desc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "SUDOT", "short_desc": "Signed by unsigned integer indexed dot product", "syntax": ["SUDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "STSMIN, STSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory, without return", "full_desc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMIN  <Ws>, [<Xn|SP>]\t; 32-bit LDSMIN alias variant", "STSMINL  <Ws>, [<Xn|SP>]\t; 32-bit LDSMINL alias variant", "STSMIN  <Xs>, [<Xn|SP>]\t; 64-bit LDSMIN alias variant", "STSMINL  <Xs>, [<Xn|SP>]\t; 64-bit LDSMINL alias variant"], "symbols": []}, {"mnemonic": "FMLS (vector)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (vector)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "NOT (predicate)", "short_desc": "Bitwise invert predicate", "syntax": ["NOT     <Pd>.B, <Pg>/Z, <Pn>.B\t; Not setting the condition flags variant"], "symbols": []}, {"mnemonic": "SQINCD (vector)", "short_desc": "Signed saturating increment vector by multiple of 64-bit predicate constraint element count", "syntax": ["SQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "CMPLS (vectors)", "short_desc": "Compare unsigned lower or same as vector, setting the condition flags", "syntax": ["CMPLS   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Higher or same variant"], "symbols": []}, {"mnemonic": "SM3SS1", "short_desc": "SM3SS1", "full_desc": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&FP register, with the bottom 96 bits of the vector being written to 0.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "SM3TT1B", "short_desc": "SM3TT1B", "full_desc": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:\n\nThe result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", "syntax": ["SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "MOV (from general)", "short_desc": "Move general-purpose register to a vector element", "full_desc": "Move general-purpose register to a vector element. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "MOV (register)", "short_desc": "Move (register)", "full_desc": "Move (register) copies the value in a source register to the destination register.", "syntax": ["MOV  <Wd>, <Wm>\t; 32-bit variant", "MOV  <Xd>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQRDMULH (by element)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf any of the results overflows, they are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "SCVTF (vector, integer)", "short_desc": "Signed integer Convert to Floating-point (vector)", "full_desc": "Signed integer Convert to Floating-point (vector). This instruction converts each element in a vector from signed integer to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <Hd>, <Hn>\t; Scalar half precision variant", "SCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SQDMULL, SQDMULL2 (vector)", "short_desc": "Signed saturating Doubling Multiply Long", "full_desc": "Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts each source vector from the lower half of each source register, while the SQDMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar variant", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "UHADD", "short_desc": "Unsigned Halving Add", "full_desc": "Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see URHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FMUL (scalar)", "short_desc": "Floating-point Multiply (scalar)", "full_desc": "Floating-point Multiply (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMUL  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMUL  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "ADDP (vector)", "short_desc": "Add Pairwise (vector)", "full_desc": "Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LD1SH (scalar plus immediate)", "short_desc": "Contiguous load signed halfwords to vector (immediate index)", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "FMOV (register)", "short_desc": "Floating-point Move register without conversion", "full_desc": "Floating-point Move register without conversion. This instruction copies the floating-point value in the SIMD&FP source register to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Hd>, <Hn>\t; Half-precision variant", "FMOV  <Sd>, <Sn>\t; Single-precision variant", "FMOV  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "PACDA, PACDZA", "short_desc": "Pointer Authentication Code for Data address, using key A", "full_desc": "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:", "syntax": ["PACDA  <Xd>, <Xn|SP>\t; PACDA variant", "PACDZA  <Xd>\t; PACDZA variant"], "symbols": []}, {"mnemonic": "STNP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "LDFF1D (scalar plus scalar)", "short_desc": "Contiguous load first-fault doublewords to vector (scalar index)", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDFF1D (vector plus immediate)", "short_desc": "Gather load first-fault doublewords to vector (immediate index)", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MADD", "short_desc": "Multiply-Add", "full_desc": "Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination register.", "syntax": ["MADD  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit variant", "MADD  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMINP (scalar)", "short_desc": "Floating-point Minimum of Pair of elements (scalar)", "full_desc": "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "RMIF", "short_desc": "Rotate, Mask Insert Flags", "full_desc": "Performs a rotation right of a value held in a general purpose register by an immediate value, and then inserts a selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second immediate mask.", "syntax": ["RMIF  <Xn>, #<shift>, #<mask>\t; Integer variant"], "symbols": []}, {"mnemonic": "SMMLA", "short_desc": "Signed integer matrix multiply-accumulate", "syntax": ["SMMLA   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "REV", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a register.", "syntax": ["REV  <Wd>, <Wn>\t; 32-bit variant", "REV  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "URSHL", "short_desc": "Unsigned Rounding Shift Left (register)", "full_desc": "Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["URSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "BICS (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register), setting flags", "full_desc": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDSETB, LDSETAB, LDSETALB, LDSETLB", "short_desc": "Atomic bit set on byte in memory", "full_desc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSETAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETAB variant", "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETALB variant", "LDSETB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETB variant", "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETLB variant"], "symbols": []}, {"mnemonic": "NGCS", "short_desc": "Negate with Carry, setting flags", "full_desc": "Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NGCS  <Wd>, <Wm>\t; 32-bit variant", "NGCS  <Xd>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UQSHL (register)", "short_desc": "Unsigned saturating Shift Left (register)", "full_desc": "Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "CASH, CASAH, CASALH, CASLH", "short_desc": "Compare and Swap halfword in memory", "full_desc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.", "syntax": ["CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASAH variant", "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASALH variant", "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASH variant", "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASLH variant"], "symbols": []}, {"mnemonic": "LSR (immediate)", "short_desc": "Logical Shift Right (immediate)", "full_desc": "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSR  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "LSR  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "WHILELT", "short_desc": "While incrementing signed scalar less than scalar", "syntax": ["WHILELT <Pd>.<T>, <R><n>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "BLR", "short_desc": "Branch with Link to Register", "full_desc": "Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.", "syntax": ["BLR  <Xn>\t; Integer variant"], "symbols": []}, {"mnemonic": "SHA256SU0", "short_desc": "SHA256 schedule update 0", "full_desc": "SHA256 schedule update 0.", "syntax": ["SHA256SU0  <Vd>.4S, <Vn>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "EOR (immediate)", "short_desc": "Bitwise Exclusive OR (immediate)", "full_desc": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["EOR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "EOR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD2 (multiple structures)", "short_desc": "Load multiple 2-element structures to two registers", "full_desc": "Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset variant", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset variant", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset variant"], "symbols": []}, {"mnemonic": "SEL (vectors)", "short_desc": "Conditionally select elements from two vectors", "syntax": ["SEL     <Zd>.<T>, <Pg>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "BFMLALB, BFMLALT (vector)", "short_desc": "BFloat16 floating-point widening multiply-add long (vector)", "full_desc": "BFloat16 floating-point widening multiply-add long (vector) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether these instruction is supported.", "syntax": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.8H\t; Vector variant"], "symbols": []}, {"mnemonic": "LSR (vectors)", "short_desc": "Logical shift right by vector (predicated)", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ASR (register)", "short_desc": "Arithmetic Shift Right (register)", "full_desc": "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ASR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UMLSL, UMLSL2 (by element)", "short_desc": "Unsigned Multiply-Subtract Long (vector, by element)", "full_desc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe UMLSL instruction extracts vector elements from the lower half of the first source register, while the UMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "STLURH", "short_desc": "Store-Release Register Halfword (unscaled)", "full_desc": "Store-Release Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "STTRH", "short_desc": "Store Register Halfword (unprivileged)", "full_desc": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "ADCS", "short_desc": "Add with Carry, setting flags", "full_desc": "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADCS  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ADCS  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMULL, SMULL2 (vector)", "short_desc": "Signed Multiply Long (vector)", "full_desc": "Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nThe destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMULL instruction extracts each source vector from the lower half of each source register, while the SMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB", "short_desc": "Authenticate Instruction address, using key B", "full_desc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B.\n\nThe address is:\n\nThe modifier is:\n\nIf the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.", "syntax": ["AUTIB  <Xd>, <Xn|SP>\t; AUTIB variant", "AUTIZB  <Xd>\t; AUTIZB variant", "AUTIB1716\t; AUTIB1716 variant", "AUTIBSP\t; AUTIBSP variant", "AUTIBZ\t; AUTIBZ variant"], "symbols": []}, {"mnemonic": "ST2B (scalar plus scalar)", "short_desc": "Contiguous store two-byte structures from two vectors (scalar index)", "syntax": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (SIMD&FP scalar, predicated)", "short_desc": "Move SIMD&FP scalar register to vector elements (predicated)", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <V><n>\t; SVE variant"], "symbols": []}, {"mnemonic": "ASR (immediate, unpredicated)", "short_desc": "Arithmetic shift right by immediate (unpredicated)", "syntax": ["ASR     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "SQSUB", "short_desc": "Signed saturating Subtract", "full_desc": "Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSUB  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "DRPS", "short_desc": "Debug restore process state", "syntax": ["DRPS\t; System variant"], "symbols": []}, {"mnemonic": "FMAXNMP (scalar)", "short_desc": "Floating-point Maximum Number of Pair of elements (scalar)", "full_desc": "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMP  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMAXNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FCPY", "short_desc": "Copy 8-bit floating-point immediate to vector elements (predicated)", "syntax": ["FCPY    <Zd>.<T>, <Pg>/M, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1RD", "short_desc": "Load and broadcast doubleword to vector", "syntax": ["LD1RD   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SQNEG", "short_desc": "Signed saturating Negate", "full_desc": "Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQNEG  <V><d>, <V><n>\t; Scalar variant", "SQNEG  <Vd>.<T>, <Vn>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "STXR", "short_desc": "Store Exclusive Register", "full_desc": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SHA512H2", "short_desc": "SHA512 Hash update part 2", "full_desc": "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["SHA512H2  <Qd>, <Qn>, <Vm>.2D\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FADDA", "short_desc": "Floating-point add strictly-ordered reduction, accumulating in scalar", "syntax": ["FADDA   <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "CMEQ (register)", "short_desc": "Compare bitwise Equal (vector)", "full_desc": "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["CMEQ  <V><d>, <V><n>, <V><m>\t; Scalar variant", "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCM<cc> (vectors)", "short_desc": "Floating-point compare vectors", "syntax": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Equal variant", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than variant", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal variant", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Not equal variant", "FCMUO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Unordered variant"], "symbols": []}, {"mnemonic": "CCMP (immediate)", "short_desc": "Conditional Compare (immediate)", "full_desc": "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STXP", "short_desc": "Store Exclusive Pair of registers", "full_desc": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about memory accesses see Load/Store addressing modes.", "syntax": ["STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "UMULH", "short_desc": "Unsigned Multiply High", "full_desc": "Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["UMULH  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STSMAXB, STSMAXLB", "short_desc": "Atomic signed maximum on byte in memory, without return", "full_desc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMAXLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "LDURSH", "short_desc": "Load Register Signed Halfword (unscaled)", "full_desc": "Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "USDOT (vector)", "short_desc": "Dot Product with unsigned and signed integers (vector)", "full_desc": "Dot Product vector form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in the corresponding 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "UMIN", "short_desc": "Unsigned Minimum (vector)", "full_desc": "Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "SCVTF", "short_desc": "Signed integer convert to floating-point (predicated)", "syntax": ["SCVTF   <Zd>.H, <Pg>/M, <Zn>.H\t; 16-bit to half-precision variant", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.S\t; 32-bit to half-precision variant", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.S\t; 32-bit to single-precision variant", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.S\t; 32-bit to double-precision variant", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.D\t; 64-bit to half-precision variant", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.D\t; 64-bit to single-precision variant", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.D\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "FCVT", "short_desc": "Floating-point Convert precision (scalar)", "full_desc": "Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&FP source register to the precision for the destination register data type using the rounding mode that is determined by the FPCR and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVT  <Sd>, <Hn>\t; Half-precision to single-precision variant", "FCVT  <Dd>, <Hn>\t; Half-precision to double-precision variant", "FCVT  <Hd>, <Sn>\t; Single-precision to half-precision variant", "FCVT  <Dd>, <Sn>\t; Single-precision to double-precision variant", "FCVT  <Hd>, <Dn>\t; Double-precision to half-precision variant", "FCVT  <Sd>, <Dn>\t; Double-precision to single-precision variant"], "symbols": []}, {"mnemonic": "FRINTN (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTN  <Hd>, <Hn>\t; Half-precision variant", "FRINTN  <Sd>, <Sn>\t; Single-precision variant", "FRINTN  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "ADD (immediate)", "short_desc": "Add immediate (unpredicated)", "syntax": ["ADD     <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "UCVTF (scalar, integer)", "short_desc": "Unsigned integer Convert to Floating-point (scalar)", "full_desc": "Unsigned integer Convert to Floating-point (scalar). This instruction converts the unsigned integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Wn>\t; 32-bit to half-precision variant", "UCVTF  <Sd>, <Wn>\t; 32-bit to single-precision variant", "UCVTF  <Dd>, <Wn>\t; 32-bit to double-precision variant", "UCVTF  <Hd>, <Xn>\t; 64-bit to half-precision variant", "UCVTF  <Sd>, <Xn>\t; 64-bit to single-precision variant", "UCVTF  <Dd>, <Xn>\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "LD1RQB (scalar plus immediate)", "short_desc": "Contiguous load and replicate sixteen bytes (immediate index)", "syntax": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "UQDECH (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count", "syntax": ["UQDECH  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "STLLRH", "short_desc": "Store LORelease Register Halfword", "full_desc": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FMMLA", "short_desc": "Floating-point matrix multiply-accumulate", "syntax": ["FMMLA   <Zda>.S, <Zn>.S, <Zm>.S\t; 32-bit element variant", "FMMLA   <Zda>.D, <Zn>.D, <Zm>.D\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDFF1W (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned words to vector (scalar index)", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; 32-bit element variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "LDFF1W (vector plus immediate)", "short_desc": "Gather load first-fault unsigned words to vector (immediate index)", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SMNEGL", "short_desc": "Signed Multiply-Negate Long", "full_desc": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["SMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "AND, ANDS (predicates)", "short_desc": "Bitwise AND predicates", "syntax": ["AND     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "ANDS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "UZP1", "short_desc": "Unzip vectors (primary)", "full_desc": "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LD1 (single structure)", "short_desc": "Load one single-element structure to one lane of one register", "full_desc": "Load one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&FP register without affecting the other bits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LD1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset variant", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset variant", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset variant", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset variant", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "MAD", "short_desc": "Multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "syntax": ["MAD     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1RW", "short_desc": "Load and broadcast unsigned word to vector", "syntax": ["LD1RW   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element variant", "LD1RW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "USDOT (vectors)", "short_desc": "Unsigned by signed integer dot product", "syntax": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (predicate, unpredicated)", "short_desc": "Move predicate (unpredicated)", "syntax": ["MOV     <Pd>.B, <Pn>.B\t; Not setting the condition flags variant"], "symbols": []}, {"mnemonic": "RET", "short_desc": "Return from subroutine", "full_desc": "Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return.", "syntax": ["RET  {<Xn>}\t; Integer variant"], "symbols": []}, {"mnemonic": "CMP<cc> (wide elements)", "short_desc": "Compare vector to 64-bit wide elements", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Equal variant", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Greater than variant", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Greater than or equal variant", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Higher variant", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Higher or same variant", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Less than variant", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Less than or equal variant", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Lower variant", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Lower or same variant", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Not equal variant"], "symbols": []}, {"mnemonic": "UCVTF (vector, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (vector)", "full_desc": "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCMGE (zero)", "short_desc": "Floating-point Compare Greater than or Equal to zero (vector)", "full_desc": "Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGE  <Hd>, <Hn>, #0.0\t; Scalar half precision variant", "FCMGE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FMOV (general)", "short_desc": "Floating-point Move to or from general-purpose register without conversion", "full_desc": "Floating-point Move to or from general-purpose register without conversion. This instruction transfers the contents of a SIMD&FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FMOV  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FMOV  <Hd>, <Wn>\t; 32-bit to half-precision variant", "FMOV  <Sd>, <Wn>\t; 32-bit to single-precision variant", "FMOV  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FMOV  <Hd>, <Xn>\t; 64-bit to half-precision variant", "FMOV  <Dd>, <Xn>\t; 64-bit to double-precision variant", "FMOV  <Vd>.D[1], <Xn>\t; 64-bit to top half of 128-bit variant", "FMOV  <Xd>, <Dn>\t; Double-precision to 64-bit variant", "FMOV  <Xd>, <Vn>.D[1]\t; Top half of 128-bit to 64-bit variant"], "symbols": []}, {"mnemonic": "MOV (scalar)", "short_desc": "Move vector element to scalar", "full_desc": "Move vector element to scalar. This instruction duplicates the specified vector element in the SIMD&FP source register into a scalar, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MOV  <V><d>, <Vn>.<T>[<index>]\t; Scalar variant"], "symbols": []}, {"mnemonic": "DVP", "short_desc": "Data Value Prediction Restriction by Context", "full_desc": "Data Value Prediction Restriction by Context prevents data value predictions, based on information gathered from earlier execution within an particular execution context, from allowing later speculative execution within that context to be observable through side-channels.\n\nFor more information, see DVP RCTX, Data Value Prediction Restriction by Context.", "syntax": ["DVP  RCTX, <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "FRINT32Z (scalar)", "short_desc": "Floating-point Round to 32-bit Integer toward Zero (scalar)", "full_desc": "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is not numerically equal to the {corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINT32Z  <Sd>, <Sn>\t; Single-precision variant", "FRINT32Z  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "LD1RSW", "short_desc": "Load and broadcast signed word to vector", "syntax": ["LD1RSW  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT", "full_desc": "Bitwise NOT writes the bitwise inverse of a register value to the destination register.", "syntax": ["MVN  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit variant", "MVN  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMLSL, FMLSL2 (by element)", "short_desc": "Floating-point fused Multiply-Subtract Long from accumulator (by element)", "full_desc": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is mandatory for all implementations to support it.", "syntax": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLSL variant", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLSL2 variant"], "symbols": []}, {"mnemonic": "SQDECP (vector)", "short_desc": "Signed saturating decrement vector by count of true predicate elements", "syntax": ["SQDECP  <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ANDS (immediate)", "short_desc": "Bitwise AND (immediate), setting flags", "full_desc": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, #<imm>\t; 32-bit variant", "ANDS  <Xd>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ROR (register)", "short_desc": "Rotate Right (register)", "full_desc": "Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ROR  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "ROR  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SABAL, SABAL2", "short_desc": "Signed Absolute difference and Accumulate Long", "full_desc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nThe SABAL instruction extracts each source vector from the lower half of each source register, while the SABAL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LDFF1SB (scalar plus vector)", "short_desc": "Gather load first-fault signed bytes to vector (vector index)", "syntax": ["LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "SUBR (immediate)", "short_desc": "Reversed subtract from immediate (unpredicated)", "syntax": ["SUBR    <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTAS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAS  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTAS  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTAS  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTAS  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTAS  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTAS  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "LD2B (scalar plus immediate)", "short_desc": "Contiguous load two-byte structures to two vectors (immediate index)", "syntax": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LSR (immediate, unpredicated)", "short_desc": "Logical shift right by immediate (unpredicated)", "syntax": ["LSR     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "NOP", "short_desc": "No Operation", "full_desc": "No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.", "syntax": ["NOP\t; System variant"], "symbols": []}, {"mnemonic": "EOR (vectors, unpredicated)", "short_desc": "Bitwise exclusive OR vectors (unpredicated)", "syntax": ["EOR     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE variant"], "symbols": []}, {"mnemonic": "SMIN (vectors)", "short_desc": "Signed minimum vectors (predicated)", "syntax": ["SMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTZU (vector, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": []}, {"mnemonic": "SMAX (immediate)", "short_desc": "Signed maximum with immediate (unpredicated)", "syntax": ["SMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNT1B (scalar plus scalar)", "short_desc": "Contiguous load non-temporal bytes to vector (scalar index)", "syntax": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE variant"], "symbols": []}, {"mnemonic": "FNMLA", "short_desc": "Floating-point negated fused multiply-add vectors (predicated), writing addend [Zda = -Zda + -Zn * Zm]", "syntax": ["FNMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ESB", "short_desc": "Error Synchronization Barrier", "full_desc": "Error Synchronization Barrier is an error synchronization event that might also update DISR_EL1 and VDISR_EL2.\n\nThis instruction can be used at all Exception levels and in Debug state.\n\nIn Debug state, this instruction behaves as if SError interrupts are masked at all Exception levels. See Error Synchronization Barrier in the Arm(R) Reliability, Availability, and Serviceability (RAS) Specification, Armv8, for Armv8-A architecture profile.\n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.", "syntax": ["ESB\t; System variant"], "symbols": []}, {"mnemonic": "NOR, NORS", "short_desc": "Bitwise NOR predicates", "syntax": ["NOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags variant", "NORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags variant"], "symbols": []}, {"mnemonic": "USUBW, USUBW2", "short_desc": "Unsigned Subtract Wide", "full_desc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.\n\nThe vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register.\n\nThe USUBW instruction extracts vector elements from the lower half of the first source register, while the USUBW2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "SQDECW (vector)", "short_desc": "Signed saturating decrement vector by multiple of 32-bit predicate constraint element count", "syntax": ["SQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "PACDB, PACDZB", "short_desc": "Pointer Authentication Code for Data address, using key B", "full_desc": "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:", "syntax": ["PACDB  <Xd>, <Xn|SP>\t; PACDB variant", "PACDZB  <Xd>\t; PACDZB variant"], "symbols": []}, {"mnemonic": "CPP", "short_desc": "Cache Prefetch Prediction Restriction by Context", "full_desc": "Cache Prefetch Prediction Restriction by Context prevents cache allocation predictions, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels.\n\nFor more information, see CPP RCTX, Cache Prefetch Prediction Restriction by Context.", "syntax": ["CPP  RCTX, <Xt>\t; System variant"], "symbols": []}, {"mnemonic": "COMPACT", "short_desc": "Shuffle active elements of vector to the right and fill with zero", "syntax": ["COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDFF1SW (vector plus immediate)", "short_desc": "Gather load first-fault signed words to vector (immediate index)", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDFF1SW (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed words to vector (scalar index)", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; SVE variant"], "symbols": []}, {"mnemonic": "SBFM", "short_desc": "Signed Bitfield Move", "full_desc": "Signed Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits.\n\nIn both cases the destination bits below the bitfield are set to zero, and the bits above the bitfield are set to a copy of the most significant bit of the bitfield.", "syntax": ["SBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit variant", "SBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST1H (vector plus immediate)", "short_desc": "Scatter store halfwords from a vector (immediate index)", "syntax": ["ST1H    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "ST1H    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "SLI", "short_desc": "Shift Left and Insert (immediate)", "full_desc": "Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SLI  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "ST1H (scalar plus scalar)", "short_desc": "Contiguous store halfwords from vector (scalar index)", "syntax": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "STADDH, STADDLH", "short_desc": "Atomic add on halfword in memory, without return", "full_desc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STADDH  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STADDLH  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "SYSL", "short_desc": "System instruction with result", "full_desc": "System instruction with result. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.", "syntax": ["SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>\t; System variant"], "symbols": []}, {"mnemonic": "FRSQRTS", "short_desc": "Floating-point reciprocal square root step (unpredicated)", "syntax": ["FRSQRTS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "USRA", "short_desc": "Unsigned Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["USRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "PRFH (scalar plus scalar)", "short_desc": "Contiguous prefetch halfwords (scalar index)", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "PRFH (vector plus immediate)", "short_desc": "Gather prefetch halfwords (vector plus immediate)", "syntax": ["PRFH    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element variant", "PRFH    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "HVC", "short_desc": "Hypervisor Call", "full_desc": "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a service.\n\nThe HVC instruction is undefined:\n\nOn executing an HVC instruction, the PE records the exception as a Hypervisor Call exception in ESR_ELx, using the EC value 0x16, and the value of the immediate argument.", "syntax": ["HVC  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "LDAPURH", "short_desc": "Load-Acquire RCpc Register Halfword (unscaled)", "full_desc": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "INDEX (scalar, immediate)", "short_desc": "Create index starting from general-purpose register and incremented by immediate", "syntax": ["INDEX   <Zd>.<T>, <R><n>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "ORV", "short_desc": "Bitwise inclusive OR reduction to scalar", "syntax": ["ORV     <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FACLT", "short_desc": "Floating-point absolute compare less than", "syntax": ["FACLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than variant"], "symbols": []}, {"mnemonic": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA", "short_desc": "Authenticate Instruction address, using key A", "full_desc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A.\n\nThe address is:\n\nThe modifier is:\n\nIf the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.", "syntax": ["AUTIA  <Xd>, <Xn|SP>\t; AUTIA variant", "AUTIZA  <Xd>\t; AUTIZA variant", "AUTIA1716\t; AUTIA1716 variant", "AUTIASP\t; AUTIASP variant", "AUTIAZ\t; AUTIAZ variant"], "symbols": []}, {"mnemonic": "SHA1P", "short_desc": "SHA1 hash update (parity)", "full_desc": "SHA1 hash update (parity).", "syntax": ["SHA1P  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory", "full_desc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINAH variant", "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINALH variant", "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINH variant", "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINLH variant"], "symbols": []}, {"mnemonic": "STTR", "short_desc": "Store Register (unprivileged)", "full_desc": "Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMULL", "short_desc": "Signed Multiply Long", "full_desc": "Signed Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["SMULL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SVC", "short_desc": "Supervisor Call", "full_desc": "Supervisor Call causes an exception to be taken to EL1.\n\nOn executing an SVC instruction, the PE records the exception as a Supervisor Call exception in ESR_ELx, using the EC value 0x15, and the value of the immediate argument.", "syntax": ["SVC  #<imm>\t; System variant"], "symbols": []}, {"mnemonic": "LDFF1B (scalar plus vector)", "short_desc": "Gather load first-fault unsigned bytes to vector (vector index)", "syntax": ["LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "SWP, SWPA, SWPAL, SWPL", "short_desc": "Swap word or doubleword in memory", "full_desc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWP  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWP variant", "SWPA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPA variant", "SWPAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPAL variant", "SWPL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPL variant", "SWP  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWP variant", "SWPA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPA variant", "SWPAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPAL variant", "SWPL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPL variant"], "symbols": []}, {"mnemonic": "LDARB", "short_desc": "Load-Acquire Register Byte", "full_desc": "Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FMUL (vectors, unpredicated)", "short_desc": "Floating-point multiply vectors (unpredicated)", "syntax": ["FMUL    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "ROR (immediate)", "short_desc": "Rotate right (immediate)", "full_desc": "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.", "syntax": ["ROR  <Wd>, <Ws>, #<shift>\t; 32-bit variant", "ROR  <Xd>, <Xs>, #<shift>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMINNM (scalar)", "short_desc": "Floating-point Minimum Number (scalar)", "full_desc": "Floating-point Minimum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNM  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMINNM  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMINNM  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "SQDECH (vector)", "short_desc": "Signed saturating decrement vector by multiple of 16-bit predicate constraint element count", "syntax": ["SQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1RQW (scalar plus scalar)", "short_desc": "Contiguous load and replicate four words (scalar index)", "syntax": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "LSL (immediate, unpredicated)", "short_desc": "Logical shift left by immediate (unpredicated)", "syntax": ["LSL     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "CTERMEQ, CTERMNE", "short_desc": "Compare and terminate loop", "syntax": ["CTERMEQ <R><n>, <R><m>\t; Equal variant", "CTERMNE <R><n>, <R><m>\t; Not equal variant"], "symbols": []}, {"mnemonic": "STXRB", "short_desc": "Store Exclusive Register Byte", "full_desc": "Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "BR", "short_desc": "Branch to Register", "full_desc": "Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.", "syntax": ["BR  <Xn>\t; Integer variant"], "symbols": []}, {"mnemonic": "UABD", "short_desc": "Unsigned absolute difference (predicated)", "syntax": ["UABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SXTL, SXTL2", "short_desc": "Signed extend Long", "full_desc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SXTL instruction extracts the source vector from the lower half of the source register, while the SXTL2 instruction extracts the source vector from the upper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "FMOV (vector, immediate)", "short_desc": "Floating-point move immediate (vector)", "full_desc": "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMOV  <Vd>.<T>, #<imm>\t; Half-precision variant", "FMOV  <Vd>.<T>, #<imm>\t; Single-precision variant", "FMOV  <Vd>.2D, #<imm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "BIT", "short_desc": "Bitwise Insert if True", "full_desc": "Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&FP register into the SIMD&FP destination register if the corresponding bit of the second source SIMD&FP register is 1, otherwise leaves the bit in the destination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LASTA (SIMD&FP scalar)", "short_desc": "Extract element after last to SIMD&FP scalar register", "syntax": ["LASTA   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "AUTDB, AUTDZB", "short_desc": "Authenticate Data address, using key B", "full_desc": "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n\nIf the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.", "syntax": ["AUTDB  <Xd>, <Xn|SP>\t; AUTDB variant", "AUTDZB  <Xd>\t; AUTDZB variant"], "symbols": []}, {"mnemonic": "FRINTP (scalar)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTP  <Hd>, <Hn>\t; Half-precision variant", "FRINTP  <Sd>, <Sn>\t; Single-precision variant", "FRINTP  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "STUR", "short_desc": "Store Register (unscaled)", "full_desc": "Store Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "STUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LD2W (scalar plus scalar)", "short_desc": "Contiguous load two-word structures to two vectors (scalar index)", "syntax": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE variant"], "symbols": []}, {"mnemonic": "FMAXNMP (vector)", "short_desc": "Floating-point Maximum Number Pairwise (vector)", "full_desc": "Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "ST2D (scalar plus immediate)", "short_desc": "Contiguous store two-doubleword structures from two vectors (immediate index)", "syntax": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FSQRT (scalar)", "short_desc": "Floating-point Square Root (scalar)", "full_desc": "Floating-point Square Root (scalar). This instruction calculates the square root of the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FSQRT  <Hd>, <Hn>\t; Half-precision variant", "FSQRT  <Sd>, <Sn>\t; Single-precision variant", "FSQRT  <Dd>, <Dn>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "FRSQRTE", "short_desc": "Floating-point reciprocal square root estimate (unpredicated)", "syntax": ["FRSQRTE <Zd>.<T>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SADDL, SADDL2", "short_desc": "Signed Add Long (vector)", "full_desc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.\n\nThe SADDL instruction extracts each source vector from the lower half of each source register, while the SADDL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory", "full_desc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXAH variant", "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXALH variant", "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXH variant", "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXLH variant"], "symbols": []}, {"mnemonic": "FMUL (by element)", "short_desc": "Floating-point Multiply (by element)", "full_desc": "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMUL  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LASTB (scalar)", "short_desc": "Extract last element to general-purpose register", "syntax": ["LASTB   <R><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "STEOR, STEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory, without return", "full_desc": "Atomic exclusive OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STEOR  <Ws>, [<Xn|SP>]\t; 32-bit LDEOR alias variant", "STEORL  <Ws>, [<Xn|SP>]\t; 32-bit LDEORL alias variant", "STEOR  <Xs>, [<Xn|SP>]\t; 64-bit LDEOR alias variant", "STEORL  <Xs>, [<Xn|SP>]\t; 64-bit LDEORL alias variant"], "symbols": []}, {"mnemonic": "ST2 (single structure)", "short_desc": "Store single 2-element structure from one lane of two registers", "full_desc": "Store single 2-element structure from one lane of two registers. This instruction stores a 2-element structure to memory from corresponding elements of two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit variant", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset variant", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset variant", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset variant", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset variant", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset variant"], "symbols": []}, {"mnemonic": "SRI", "short_desc": "Shift Right and Insert (immediate)", "full_desc": "Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRI  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "FCVTMU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTMU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTMU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FACGT", "short_desc": "Floating-point Absolute Compare Greater than (vector)", "full_desc": "Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FACGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FACGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "EOR (immediate)", "short_desc": "Bitwise exclusive OR with immediate (unpredicated)", "syntax": ["EOR     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNF1SB", "short_desc": "Contiguous load non-fault signed bytes to vector (immediate index)", "syntax": ["LDNF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element variant", "LDNF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element variant", "LDNF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element variant"], "symbols": []}, {"mnemonic": "REV64", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register.\n\nWhen assembling for Armv8.2, an assembler must support this pseudo-instruction. It is optional whether an assembler supports this pseudo-instruction when assembling for an architecture earlier than Armv8.2.", "syntax": ["REV64  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA", "short_desc": "Pointer Authentication Code for Instruction address, using key A", "full_desc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A.\n\nThe address is:\n\nThe modifier is:", "syntax": ["PACIA  <Xd>, <Xn|SP>\t; PACIA variant", "PACIZA  <Xd>\t; PACIZA variant", "PACIA1716\t; PACIA1716 variant", "PACIASP\t; PACIASP variant", "PACIAZ\t; PACIAZ variant"], "symbols": []}, {"mnemonic": "FRECPS", "short_desc": "Floating-point Reciprocal Step", "full_desc": "Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPS  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FRECPS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "MSUB", "short_desc": "Multiply-Subtract", "full_desc": "Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register.", "syntax": ["MSUB  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit variant", "MSUB  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BSL", "short_desc": "Bitwise Select", "full_desc": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "UMINV", "short_desc": "Unsigned Minimum across Vector", "full_desc": "Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "CINV", "short_desc": "Conditional Invert", "full_desc": "Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINV  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CINV  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ADDV", "short_desc": "Add across Vector", "full_desc": "Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADDV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "UQDECW (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count", "syntax": ["UQDECW  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FMLA (vectors)", "short_desc": "Floating-point fused multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "syntax": ["FMLA    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SUDOT (by element)", "short_desc": "Dot product with signed and unsigned integers (vector, by element)", "full_desc": "Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "syntax": ["SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "FMINV", "short_desc": "Floating-point minimum recursive reduction to scalar", "syntax": ["FMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "MVNI", "short_desc": "Move inverted Immediate (vector)", "full_desc": "Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate variant", "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate variant", "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones variant"], "symbols": []}, {"mnemonic": "LDNT1W (scalar plus immediate)", "short_desc": "Contiguous load non-temporal words to vector (immediate index)", "syntax": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "UMNEGL", "short_desc": "Unsigned Multiply-Negate Long", "full_desc": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["UMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "ST4H (scalar plus scalar)", "short_desc": "Contiguous store four-halfword structures from four vectors (scalar index)", "syntax": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "MOV (immediate, unpredicated)", "short_desc": "Move signed immediate to vector elements (unpredicated)", "syntax": ["MOV     <Zd>.<T>, #<imm>{, <shift>}\t; SVE variant"], "symbols": []}, {"mnemonic": "SDIV", "short_desc": "Signed Divide", "full_desc": "Signed Divide divides a signed integer register value by another signed integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["SDIV  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SDIV  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SBC", "short_desc": "Subtract with Carry", "full_desc": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.", "syntax": ["SBC  <Wd>, <Wn>, <Wm>\t; 32-bit variant", "SBC  <Xd>, <Xn>, <Xm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FSUBR (immediate)", "short_desc": "Floating-point reversed subtract from immediate (predicated)", "syntax": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ADD (vectors, unpredicated)", "short_desc": "Add vectors (unpredicated)", "syntax": ["ADD     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "Shared Pseudocode Functions", "short_desc": "This page displays common pseudocode functions shared by many pages", "syntax": [], "symbols": []}, {"mnemonic": "INS (element)", "short_desc": "Insert vector element from another vector element", "full_desc": "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "STSMINB, STSMINLB", "short_desc": "Atomic signed minimum on byte in memory, without return", "full_desc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["STSMINB  <Ws>, [<Xn|SP>]\t; No memory ordering variant", "STSMINLB  <Ws>, [<Xn|SP>]\t; Release variant"], "symbols": []}, {"mnemonic": "LDTRH", "short_desc": "Load Register Halfword (unprivileged)", "full_desc": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n\nOtherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset variant"], "symbols": []}, {"mnemonic": "ST3H (scalar plus immediate)", "short_desc": "Contiguous store three-halfword structures from three vectors (immediate index)", "syntax": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "LDUR (SIMD&FP)", "short_desc": "Load SIMD&FP Register (unscaled offset)", "full_desc": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit variant", "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit variant", "LDUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant", "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "SCVTF (vector, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (vector)", "full_desc": "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["SCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar variant", "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector variant"], "symbols": []}, {"mnemonic": "FMAX (scalar)", "short_desc": "Floating-point Maximum (scalar)", "full_desc": "Floating-point Maximum (scalar). This instruction compares the two source SIMD&FP registers, and writes the larger of the two floating-point values to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMAX  <Hd>, <Hn>, <Hm>\t; Half-precision variant", "FMAX  <Sd>, <Sn>, <Sm>\t; Single-precision variant", "FMAX  <Dd>, <Dn>, <Dm>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "UMINV", "short_desc": "Unsigned minimum reduction to scalar", "syntax": ["UMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "SHA512SU0", "short_desc": "SHA512 Schedule Update 0", "full_desc": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", "syntax": ["SHA512SU0  <Vd>.2D, <Vn>.2D\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "DCPS1", "short_desc": "Debug Change PE State to EL1.", "full_desc": "Debug Change PE State to EL1, when executed in Debug state:\n\nThe target exception level of a DCPS1 instruction is:\n\nWhen the target Exception level of a DCPS1 instruction is ELx, on executing this instruction:\n\nThis instruction is undefined at EL0 in Non-secure state if EL2 is implemented and HCR_EL2.TGE == 1.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS1  {#<imm>}\t; System variant"], "symbols": []}, {"mnemonic": "LDAXRB", "short_desc": "Load-Acquire Exclusive Register Byte", "full_desc": "Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes.", "syntax": ["LDAXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset variant"], "symbols": []}, {"mnemonic": "FRINTX (vector)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.\n\nWhen a result value is not numerically equal to the corresponding input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTX  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTX  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "UMAXV", "short_desc": "Unsigned Maximum across Vector", "full_desc": "Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "EORV", "short_desc": "Bitwise exclusive OR reduction to scalar", "syntax": ["EORV    <V><d>, <Pg>, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FDIVR", "short_desc": "Floating-point reversed divide by vector (predicated)", "syntax": ["FDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "DCPS3", "short_desc": "Debug Change PE State to EL3", "full_desc": "Debug Change PE State to EL3, when executed in Debug state:\n\nThe target exception level of a DCPS3 instruction is EL3.\n\nOn executing a DCPS3 instruction:\n\nThis instruction is undefined at all exception levels if either:\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS3  {#<imm>}\t; System variant"], "symbols": []}, {"mnemonic": "FCVTZU (vector, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTZU  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTZU  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "PNEXT", "short_desc": "Find next active predicate", "syntax": ["PNEXT   <Pdn>.<T>, <Pg>, <Pdn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LDNT1D (scalar plus immediate)", "short_desc": "Contiguous load non-temporal doublewords to vector (immediate index)", "syntax": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "FCCMP", "short_desc": "Floating-point Conditional quiet Compare (scalar)", "full_desc": "Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.\n\nIt raises an Invalid Operation exception only if either operand is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision variant", "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision variant", "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision variant"], "symbols": []}, {"mnemonic": "MOV (scalar, predicated)", "short_desc": "Move general-purpose register to vector elements (predicated)", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <R><n|SP>\t; SVE variant"], "symbols": []}, {"mnemonic": "SQSHL (register)", "short_desc": "Signed saturating Shift Left (register)", "full_desc": "Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see SQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "MSB", "short_desc": "Multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za - Zdn * Zm]", "syntax": ["MSB     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "AND (immediate)", "short_desc": "Bitwise AND (immediate)", "full_desc": "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["AND  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit variant", "AND  <Xd|SP>, <Xn>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "CLASTB (scalar)", "short_desc": "Conditionally extract last element to general-purpose register", "syntax": ["CLASTB  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LSL (immediate)", "short_desc": "Logical Shift Left (immediate)", "full_desc": "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSL  <Wd>, <Wn>, #<shift>\t; 32-bit variant", "LSL  <Xd>, <Xn>, #<shift>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FCADD", "short_desc": "Floating-point complex add with rotate (predicated)", "syntax": ["FCADD   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "WHILELO", "short_desc": "While incrementing unsigned scalar lower than scalar", "syntax": ["WHILELO <Pd>.<T>, <R><n>, <R><m>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTN, FCVTN2", "short_desc": "Floating-point Convert to lower precision Narrow (vector)", "full_desc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.\n\nThe FCVTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDRAA, LDRAB", "short_desc": "Load Register, with pointer authentication", "full_desc": "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register.\n\nKey A is used for LDRAA, and key B is used for LDRAB.\n\nIf the authentication passes, the PE behaves the same as for an LDR instruction. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the base register, unless the pre-indexed variant of the instruction is used. In this case, the address that is written back to the base register does not include the pointer authentication code.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]\t; Key A, offset variant", "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!\t; Key A, pre-indexed variant", "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]\t; Key B, offset variant", "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!\t; Key B, pre-indexed variant"], "symbols": []}, {"mnemonic": "LSR (immediate, predicated)", "short_desc": "Logical shift right by immediate (predicated)", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "AUTDA, AUTDZA", "short_desc": "Authenticate Data address, using key A", "full_desc": "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n\nIf the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.", "syntax": ["AUTDA  <Xd>, <Xn|SP>\t; AUTDA variant", "AUTDZA  <Xd>\t; AUTDZA variant"], "symbols": []}, {"mnemonic": "SHA1C", "short_desc": "SHA1 hash update (choose)", "full_desc": "SHA1 hash update (choose).", "syntax": ["SHA1C  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FMULX (by element)", "short_desc": "Floating-point Multiply extended (by element)", "full_desc": "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&FP register by the specified floating-point value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMULX  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision variant", "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision variant", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LSLR", "short_desc": "Reversed logical shift left by vector (predicated)", "syntax": ["LSLR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "INCD, INCH, INCW (vector)", "short_desc": "Increment vector by multiple of predicate constraint element count", "syntax": ["INCD    <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; Doubleword variant", "INCH    <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; Halfword variant", "INCW    <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; Word variant"], "symbols": []}, {"mnemonic": "LDAPURSH", "short_desc": "Load-Acquire RCpc Register Signed Halfword (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPURSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit variant", "LDAPURSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SSRA", "short_desc": "Signed Shift Right and Accumulate (immediate)", "full_desc": "Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "DECP (vector)", "short_desc": "Decrement vector by count of true predicate elements", "syntax": ["DECP    <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FMLA (vector)", "short_desc": "Floating-point fused Multiply-Add to accumulator (vector)", "full_desc": "Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision variant", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SWPH, SWPAH, SWPALH, SWPLH", "short_desc": "Swap halfword in memory", "full_desc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["SWPAH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPAH variant", "SWPALH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPALH variant", "SWPH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPH variant", "SWPLH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPLH variant"], "symbols": []}, {"mnemonic": "FRINTN (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRINTN  <Vd>.<T>, <Vn>.<T>\t; Half-precision variant", "FRINTN  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LD4H (scalar plus immediate)", "short_desc": "Contiguous load four-halfword structures to four vectors (immediate index)", "syntax": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "UQINCD (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count", "syntax": ["UQINCD  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit variant", "UQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit variant"], "symbols": []}, {"mnemonic": "LDP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers", "full_desc": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["LDP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit variant", "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit variant", "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit variant", "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit variant", "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit variant"], "symbols": []}, {"mnemonic": "CLREX", "short_desc": "Clear Exclusive", "full_desc": "Clear Exclusive clears the local monitor of the executing PE.", "syntax": ["CLREX  {#<imm>}\t; System variant"], "symbols": []}, {"mnemonic": "FABS", "short_desc": "Floating-point absolute value (predicated)", "syntax": ["FABS    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "UMULL, UMULL2 (vector)", "short_desc": "Unsigned Multiply long (vector)", "full_desc": "Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMULL instruction extracts each source vector from the lower half of each source register, while the UMULL2 instruction extracts each source vector from the upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type variant"], "symbols": []}, {"mnemonic": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB", "short_desc": "Pointer Authentication Code for Instruction address, using key B", "full_desc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B.\n\nThe address is:\n\nThe modifier is:", "syntax": ["PACIB  <Xd>, <Xn|SP>\t; PACIB variant", "PACIZB  <Xd>\t; PACIZB variant", "PACIB1716\t; PACIB1716 variant", "PACIBSP\t; PACIBSP variant", "PACIBZ\t; PACIBZ variant"], "symbols": []}, {"mnemonic": "LD3H (scalar plus scalar)", "short_desc": "Contiguous load three-halfword structures to three vectors (scalar index)", "syntax": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "SMLSL, SMLSL2 (by element)", "short_desc": "Signed Multiply-Subtract Long (vector, by element)", "full_desc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts vector elements from the lower half of the first source register, while the SMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "CLASTA (SIMD&FP scalar)", "short_desc": "Conditionally extract element after last to SIMD&FP scalar register", "syntax": ["CLASTA  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1SH (scalar plus vector)", "short_desc": "Gather load signed halfwords to vector (vector index)", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "LDAPRH", "short_desc": "Load-Acquire RCpc Register Halfword", "full_desc": "Load-Acquire RCpc Register Halfword derives an address from a base register value, loads a halfword from the derived address in memory, zero-extends it and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.", "syntax": ["LDAPRH  <Wt>, [<Xn|SP> {,#0}]\t; Integer variant"], "symbols": []}, {"mnemonic": "REV32", "short_desc": "Reverse bytes in 32-bit words", "full_desc": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register.", "syntax": ["REV32  <Xd>, <Xn>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "MOV (bitmask immediate)", "short_desc": "Move (bitmask immediate)", "full_desc": "Move (bitmask immediate) writes a bitmask immediate value to a register.", "syntax": ["MOV  <Wd|WSP>, #<imm>\t; 32-bit variant", "MOV  <Xd|SP>, #<imm>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SMINP", "short_desc": "Signed Minimum Pairwise", "full_desc": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "FCMPE", "short_desc": "Floating-point signaling Compare (scalar)", "full_desc": "Floating-point signaling Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMPE  <Hn>, <Hm>\t; Half-precision variant", "FCMPE  <Hn>, #0.0\t; Half-precision, zero variant", "FCMPE  <Sn>, <Sm>\t; Single-precision variant", "FCMPE  <Sn>, #0.0\t; Single-precision, zero variant", "FCMPE  <Dn>, <Dm>\t; Double-precision variant", "FCMPE  <Dn>, #0.0\t; Double-precision, zero variant"], "symbols": []}, {"mnemonic": "SMIN", "short_desc": "Signed Minimum (vector)", "full_desc": "Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "ADD (vector)", "short_desc": "Add (vector)", "full_desc": "Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ADD  <V><d>, <V><n>, <V><m>\t; Scalar variant", "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "CCMN (register)", "short_desc": "Conditional Compare Negative (register)", "full_desc": "Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit variant", "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "FCMGE (register)", "short_desc": "Floating-point Compare Greater than or Equal (vector)", "full_desc": "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCMGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision variant", "FCMGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision variant", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FSUB (immediate)", "short_desc": "Floating-point subtract immediate (predicated)", "syntax": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE variant"], "symbols": []}, {"mnemonic": "LD1ROH (scalar plus scalar)", "short_desc": "Contiguous load and replicate sixteen halfwords (scalar index)", "syntax": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "UCVTF (scalar, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (scalar)", "full_desc": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision variant", "UCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision variant", "UCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision variant", "UCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision variant", "UCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision variant", "UCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision variant"], "symbols": []}, {"mnemonic": "LD1RQD (scalar plus scalar)", "short_desc": "Contiguous load and replicate two doublewords (scalar index)", "syntax": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "UQRSHL", "short_desc": "Unsigned saturating Rounding Shift Left (register)", "full_desc": "Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see UQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar variant", "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "UMIN (immediate)", "short_desc": "Unsigned minimum with immediate (unpredicated)", "syntax": ["UMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE variant"], "symbols": []}, {"mnemonic": "UADDLP", "short_desc": "Unsigned Add Long Pairwise", "full_desc": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["UADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector variant"], "symbols": []}, {"mnemonic": "FMINNMV", "short_desc": "Floating-point Minimum Number across Vector", "full_desc": "Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FMINNMV  <V><d>, <Vn>.<T>\t; Half-precision variant", "FMINNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "CINC", "short_desc": "Conditional Increment", "full_desc": "Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINC  <Wd>, <Wn>, <cond>\t; 32-bit variant", "CINC  <Xd>, <Xn>, <cond>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "SQRDMLSH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <V><m>\t; Scalar variant", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector variant"], "symbols": []}, {"mnemonic": "STLR", "short_desc": "Store-Release Register", "full_desc": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes.", "syntax": ["STLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit variant", "STLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit variant"], "symbols": []}, {"mnemonic": "BFMMLA", "short_desc": "BFloat16 floating-point matrix multiply-accumulate", "syntax": ["BFMMLA  <Zda>.S, <Zn>.H, <Zm>.H\t; SVE variant"], "symbols": []}, {"mnemonic": "UCVTF (vector, integer)", "short_desc": "Unsigned integer Convert to Floating-point (vector)", "full_desc": "Unsigned integer Convert to Floating-point (vector). This instruction converts each element in a vector from an unsigned integer value to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.", "syntax": ["UCVTF  <Hd>, <Hn>\t; Scalar half precision variant", "UCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "FRECPE", "short_desc": "Floating-point Reciprocal Estimate", "full_desc": "Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FRECPE  <Hd>, <Hn>\t; Scalar half precision variant", "FRECPE  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "SRSRA", "short_desc": "Signed Rounding Shift Right and Accumulate (immediate)", "full_desc": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRSRA  <V><d>, <V><n>, #<shift>\t; Scalar variant", "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector variant"], "symbols": []}, {"mnemonic": "SQDMLSL, SQDMLSL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts vector elements from the lower half of the first source register, while the SQDMLSL2 instruction extracts vector elements from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar variant", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector variant"], "symbols": []}, {"mnemonic": "DMB", "short_desc": "Data Memory Barrier", "full_desc": "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier.", "syntax": ["DMB  <option>|#<imm>\t; System variant"], "symbols": []}, {"mnemonic": "FMUL (vectors, predicated)", "short_desc": "Floating-point multiply vectors (predicated)", "syntax": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "FCVTAU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAU  <Wd>, <Hn>\t; Half-precision to 32-bit variant", "FCVTAU  <Xd>, <Hn>\t; Half-precision to 64-bit variant", "FCVTAU  <Wd>, <Sn>\t; Single-precision to 32-bit variant", "FCVTAU  <Xd>, <Sn>\t; Single-precision to 64-bit variant", "FCVTAU  <Wd>, <Dn>\t; Double-precision to 32-bit variant", "FCVTAU  <Xd>, <Dn>\t; Double-precision to 64-bit variant"], "symbols": []}, {"mnemonic": "SRHADD", "short_desc": "Signed Rounding Halving Add", "full_desc": "Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LD2D (scalar plus scalar)", "short_desc": "Contiguous load two-doubleword structures to two vectors (scalar index)", "syntax": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE variant"], "symbols": []}, {"mnemonic": "EON", "short_desc": "Bitwise exclusive OR with inverted immediate (unpredicated)", "syntax": ["EON     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "ST2W (scalar plus immediate)", "short_desc": "Contiguous store two-word structures from two vectors (immediate index)", "syntax": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE variant"], "symbols": []}, {"mnemonic": "ST1 (multiple structures)", "short_desc": "Store multiple single-element structures from one, two, three, or four registers", "full_desc": "Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to memory from one, two, three, or four SIMD&FP registers, without interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["ST1  { <Vt>.<T> }, [<Xn|SP>]\t; One register variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers variant", "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset variant", "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset variant", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset variant"], "symbols": []}, {"mnemonic": "BFC", "short_desc": "Bitfield Clear", "full_desc": "Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the destination register to zero, leaving the other destination bits unchanged.", "syntax": ["BFC  <Wd>, #<lsb>, #<width>\t; 32-bit variant", "BFC  <Xd>, #<lsb>, #<width>\t; 64-bit variant"], "symbols": []}, {"mnemonic": "DUP (general)", "short_desc": "Duplicate general-purpose register to vector", "full_desc": "Duplicate general-purpose register to vector. This instruction duplicates the contents of the source general-purpose register into a scalar or each element in a vector, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["DUP  <Vd>.<T>, <R><n>\t; Advanced SIMD variant"], "symbols": []}, {"mnemonic": "FCVTAS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["FCVTAS  <Hd>, <Hn>\t; Scalar half precision variant", "FCVTAS  <V><d>, <V><n>\t; Scalar single-precision and double-precision variant", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision variant", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision variant"], "symbols": []}, {"mnemonic": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory", "full_desc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.", "syntax": ["LDSMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAX variant", "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXA variant", "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXAL variant", "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXL variant", "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAX variant", "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXA variant", "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXAL variant", "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXL variant"], "symbols": []}, {"mnemonic": "SMAXP", "short_desc": "Signed Maximum Pairwise", "full_desc": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.", "syntax": ["SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type variant"], "symbols": []}, {"mnemonic": "LD1H (scalar plus vector)", "short_desc": "Gather load unsigned halfwords to vector (vector index)", "syntax": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset variant", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset variant", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset variant"], "symbols": []}, {"mnemonic": "UQDECP (vector)", "short_desc": "Unsigned saturating decrement vector by count of true predicate elements", "syntax": ["UQDECP  <Zdn>.<T>, <Pm>.<T>\t; SVE variant"], "symbols": []}, {"mnemonic": "CPY (SIMD&FP scalar)", "short_desc": "Copy SIMD&FP scalar register to vector elements (predicated)", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, <V><n>\t; SVE variant"], "symbols": []}, {"mnemonic": "STNT1H (scalar plus scalar)", "short_desc": "Contiguous store non-temporal halfwords from vector (scalar index)", "syntax": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE variant"], "symbols": []}, {"mnemonic": "DCPS2", "short_desc": "Debug Change PE State to EL2.", "full_desc": "Debug Change PE State to EL2, when executed in Debug state:\n\nThe target exception level of a DCPS2 instruction is:\n\nWhen the target Exception level of a DCPS2 instruction is ELx, on executing this instruction:\n\nThis instruction is undefined at the following exception levels:\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "syntax": ["DCPS2  {#<imm>}\t; System variant"], "symbols": []}, {"mnemonic": "LSL (immediate, predicated)", "short_desc": "Logical shift left by immediate (predicated)", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE variant"], "symbols": []}, {"mnemonic": "INDEX (immediate, scalar)", "short_desc": "Create index starting from immediate and incremented by general-purpose register", "syntax": ["INDEX   <Zd>.<T>, #<imm>, <R><m>\t; SVE variant"], "symbols": []}]